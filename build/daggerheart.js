'use strict';

const compendiumJournals = {
    welcome: 'Compendium.daggerheart.journals.JournalEntry.g7NhKvwltwafmMyR'
};

const ruleChoice = {
    on: {
        id: 'on',
        label: 'DAGGERHEART.CONFIG.RuleChoice.on'
    },
    of: {
        id: 'off',
        label: 'DAGGERHEART.CONFIG.RuleChoice.off'
    },
    onWithToggle: {
        id: 'onWithToggle',
        label: 'DAGGERHEART.CONFIG.RuleChoice.onWithToggle'
    },
    offWithToggle: {
        id: 'offWithToggle',
        label: 'DAGGERHEART.CONFIG.RuleChoice.offWithToggle'
    }
};

const templateRanges = {
    self: {
        id: 'self',
        short: 's',
        label: 'DAGGERHEART.CONFIG.Range.self.name',
        description: 'DAGGERHEART.CONFIG.Range.self.description',
        distance: 0
    },
    melee: {
        id: 'melee',
        short: 'm',
        label: 'DAGGERHEART.CONFIG.Range.melee.name',
        description: 'DAGGERHEART.CONFIG.Range.melee.description',
        distance: 1
    },
    veryClose: {
        id: 'veryClose',
        short: 'vc',
        label: 'DAGGERHEART.CONFIG.Range.veryClose.name',
        description: 'DAGGERHEART.CONFIG.Range.veryClose.description',
        distance: 3
    },
    close: {
        id: 'close',
        short: 'c',
        label: 'DAGGERHEART.CONFIG.Range.close.name',
        description: 'DAGGERHEART.CONFIG.Range.close.description',
        distance: 10
    },
    far: {
        id: 'far',
        short: 'f',
        label: 'DAGGERHEART.CONFIG.Range.far.name',
        description: 'DAGGERHEART.CONFIG.Range.far.description',
        distance: 20
    }
};

const range = {
    ...templateRanges,
    veryFar: {
        id: 'veryFar',
        short: 'vf',
        label: 'DAGGERHEART.CONFIG.Range.veryFar.name',
        description: 'DAGGERHEART.CONFIG.Range.veryFar.description',
        distance: 30
    }
};

const templateTypes = {
    ...CONST.MEASURED_TEMPLATE_TYPES,
    EMANATION: 'emanation',
    INFRONT: 'inFront'
};

const rangeInclusion = {
    withinRange: {
        id: 'withinRange',
        label: 'DAGGERHEART.CONFIG.RangeInclusion.withinRange'
    },
    outsideRange: {
        id: 'outsideRange',
        label: 'DAGGERHEART.CONFIG.RangeInclusion.outsideRange'
    }
};

const otherTargetTypes = {
    friendly: {
        id: 'friendly',
        label: 'DAGGERHEART.CONFIG.TargetTypes.friendly'
    },
    hostile: {
        id: 'hostile',
        label: 'DAGGERHEART.CONFIG.TargetTypes.hostile'
    },
    any: {
        id: 'any',
        label: 'DAGGERHEART.CONFIG.TargetTypes.any'
    }
};

const targetTypes = {
    self: {
        id: 'self',
        label: 'DAGGERHEART.CONFIG.TargetTypes.self'
    },
    ...otherTargetTypes
};

const burden = {
    oneHanded: {
        value: 'oneHanded',
        label: 'DAGGERHEART.CONFIG.Burden.oneHanded'
    },
    twoHanded: {
        value: 'twoHanded',
        label: 'DAGGERHEART.CONFIG.Burden.twoHanded'
    }
};

const damageTypes = {
    physical: {
        id: 'physical',
        label: 'DAGGERHEART.CONFIG.DamageType.physical.name',
        abbreviation: 'DAGGERHEART.CONFIG.DamageType.physical.abbreviation',
        icon: 'fa-hand-fist'
    },
    magical: {
        id: 'magical',
        label: 'DAGGERHEART.CONFIG.DamageType.magical.name',
        abbreviation: 'DAGGERHEART.CONFIG.DamageType.magical.abbreviation',
        icon: 'fa-wand-sparkles'
    }
};

const healingTypes = {
    hitPoints: {
        id: 'hitPoints',
        label: 'DAGGERHEART.CONFIG.HealingType.hitPoints.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.hitPoints.abbreviation'
    },
    stress: {
        id: 'stress',
        label: 'DAGGERHEART.CONFIG.HealingType.stress.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.stress.abbreviation'
    },
    hope: {
        id: 'hope',
        label: 'DAGGERHEART.CONFIG.HealingType.hope.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.hope.abbreviation'
    },
    armor: {
        id: 'armor',
        label: 'DAGGERHEART.CONFIG.HealingType.armor.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.armor.abbreviation'
    },
    fear: {
        id: 'fear',
        label: 'DAGGERHEART.CONFIG.HealingType.fear.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.fear.abbreviation'
    }
};

const defeatedConditions = () => {
    const defeated = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).defeated;
    return Object.keys(defeatedConditionChoices).reduce((acc, key) => {
        const choice = defeatedConditionChoices[key];
        acc[key] = {
            ...choice,
            img: defeated[`${choice.id}Icon`],
            description: `DAGGERHEART.CONFIG.Condition.${choice.id}.description`
        };

        return acc;
    }, {});
};

const defeatedConditionChoices = {
    defeated: {
        id: 'defeated',
        name: 'DAGGERHEART.CONFIG.Condition.defeated.name'
    },
    unconscious: {
        id: 'unconscious',
        name: 'DAGGERHEART.CONFIG.Condition.unconscious.name'
    },
    dead: {
        id: 'dead',
        name: 'DAGGERHEART.CONFIG.Condition.dead.name'
    }
};

const conditions = () => ({
    vulnerable: {
        id: 'vulnerable',
        name: 'DAGGERHEART.CONFIG.Condition.vulnerable.name',
        img: 'icons/magic/control/silhouette-fall-slip-prone.webp',
        description: 'DAGGERHEART.CONFIG.Condition.vulnerable.description'
    },
    hidden: {
        id: 'hidden',
        name: 'DAGGERHEART.CONFIG.Condition.hidden.name',
        img: 'icons/magic/perception/silhouette-stealth-shadow.webp',
        description: 'DAGGERHEART.CONFIG.Condition.hidden.description'
    },
    restrained: {
        id: 'restrained',
        name: 'DAGGERHEART.CONFIG.Condition.restrained.name',
        img: 'icons/magic/control/debuff-chains-shackle-movement-red.webp',
        description: 'DAGGERHEART.CONFIG.Condition.restrained.description'
    },
    ...defeatedConditions()
});

const defaultRestOptions = {
    shortRest: () => ({
        tendToWounds: {
            id: 'tendToWounds',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.tendToWounds.name'),
            icon: 'fa-solid fa-bandage',
            img: 'icons/magic/life/cross-worn-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.tendToWounds.description'),
            actions: {
                tendToWounds: {
                    type: 'healing',
                    systemPath: 'restMoves.shortRest.moves.tendToWounds.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.tendToWounds.name'),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.hitPoints.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '1d4 + @tier'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        clearStress: {
            id: 'clearStress',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.clearStress.name'),
            icon: 'fa-regular fa-face-surprise',
            img: 'icons/magic/perception/eye-ringed-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.clearStress.description'),
            actions: {
                clearStress: {
                    type: 'healing',
                    systemPath: 'restMoves.shortRest.moves.clearStress.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.clearStress.name'),
                    img: 'icons/magic/perception/eye-ringed-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.stress.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '1d4 + @tier'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        repairArmor: {
            id: 'repairArmor',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.repairArmor.name'),
            icon: 'fa-solid fa-hammer',
            img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.repairArmor.description'),
            actions: {
                repairArmor: {
                    type: 'healing',
                    systemPath: 'restMoves.shortRest.moves.repairArmor.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.repairArmor.name'),
                    img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.armor.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '1d4 + @tier'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        prepare: {
            id: 'prepare',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.prepare.name'),
            icon: 'fa-solid fa-dumbbell',
            img: 'icons/skills/trades/academics-merchant-scribe.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.prepare.description'),
            actions: {}
        }
    }),
    longRest: () => ({
        tendToWounds: {
            id: 'tendToWounds',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.tendToWounds.name'),
            icon: 'fa-solid fa-bandage',
            img: 'icons/magic/life/cross-worn-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.tendToWounds.description'),
            actions: {
                tendToWounds: {
                    type: 'healing',
                    systemPath: 'restMoves.longRest.moves.tendToWounds.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.tendToWounds.name'),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.hitPoints.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@system.resources.hitPoints.max'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        clearStress: {
            id: 'clearStress',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.clearStress.name'),
            icon: 'fa-regular fa-face-surprise',
            img: 'icons/magic/perception/eye-ringed-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.clearStress.description'),
            actions: {
                clearStress: {
                    type: 'healing',
                    systemPath: 'restMoves.longRest.moves.clearStress.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.clearStress.name'),
                    img: 'icons/magic/perception/eye-ringed-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.stress.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@system.resources.stress.max'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        repairArmor: {
            id: 'repairArmor',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.repairArmor.name'),
            icon: 'fa-solid fa-hammer',
            img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.repairArmor.description'),
            actions: {
                repairArmor: {
                    type: 'healing',
                    systemPath: 'restMoves.longRest.moves.repairArmor.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.repairArmor.name'),
                    img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.armor.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@system.armorScore'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        prepare: {
            id: 'prepare',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.prepare.name'),
            icon: 'fa-solid fa-dumbbell',
            img: 'icons/skills/trades/academics-merchant-scribe.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.prepare.description'),
            actions: {}
        },
        workOnAProject: {
            id: 'workOnAProject',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.workOnAProject.name'),
            icon: 'fa-solid fa-diagram-project',
            img: 'icons/skills/social/thumbsup-approval-like.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.workOnAProject.description'),
            actions: {}
        }
    })
};

const deathMoves = {
    avoidDeath: {
        id: 'avoidDeath',
        name: 'DAGGERHEART.CONFIG.DeathMoves.avoidDeath.name',
        img: 'icons/magic/time/hourglass-yellow-green.webp',
        icon: 'fa-person-running',
        description: 'DAGGERHEART.CONFIG.DeathMoves.avoidDeath.description'
    },
    riskItAll: {
        id: 'riskItAll',
        name: 'DAGGERHEART.CONFIG.DeathMoves.riskItAll.name',
        img: 'icons/sundries/gaming/dice-pair-white-green.webp',
        icon: 'fa-dice',
        description: 'DAGGERHEART.CONFIG.DeathMoves.riskItAll.description'
    },
    blazeOfGlory: {
        id: 'blazeOfGlory',
        name: 'DAGGERHEART.CONFIG.DeathMoves.blazeOfGlory.name',
        img: 'icons/magic/life/heart-cross-strong-flame-purple-orange.webp',
        icon: 'fa-burst',
        description: 'DAGGERHEART.CONFIG.DeathMoves.blazeOfGlory.description'
    }
};

const tiers = {
    1: {
        id: 1,
        label: 'DAGGERHEART.GENERAL.Tiers.1'
    },
    2: {
        id: 2,
        label: 'DAGGERHEART.GENERAL.Tiers.2'
    },
    3: {
        id: 3,
        label: 'DAGGERHEART.GENERAL.Tiers.3'
    },
    4: {
        id: 4,
        label: 'DAGGERHEART.GENERAL.Tiers.4'
    }
};

const diceTypes = {
    d4: 'd4',
    d6: 'd6',
    d8: 'd8',
    d10: 'd10',
    d12: 'd12',
    d20: 'd20'
};

const multiplierTypes = {
    prof: 'Proficiency',
    cast: 'Spellcast',
    scale: 'Cost Scaling',
    result: 'Roll Result',
    flat: 'Flat',
    tier: 'Tier'
};

const diceSetNumbers = {
    prof: 'Proficiency',
    cast: 'Spellcast',
    scale: 'Cost Scaling',
    flat: 'Flat'
};

const getDiceSoNicePreset = async (type, faces) => {
    const system = game.dice3d.DiceFactory.systems.get(type.system).dice.get(faces);
    if (!system) {
        ui.notifications.error(
            game.i18n.format('DAGGERHEART.UI.Notifications.noDiceSystem', {
                system: game.dice3d.DiceFactory.systems.get(type.system).name,
                faces: faces
            })
        );
        return;
    }

    if (system.modelFile && !system.modelLoaded) {
        await system.loadModel(game.dice3d.DiceFactory.loaderGLTF);
    } else {
        await system.loadTextures();
    }

    return {
        modelFile: system.modelFile,
        appearance: {
            ...system.appearance,
            ...type
        }
    };
};

const getDiceSoNicePresets = async (hopeFaces, fearFaces, advantageFaces = 'd6', disadvantageFaces = 'd6') => {
    const { diceSoNice } = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance);

    return {
        hope: await getDiceSoNicePreset(diceSoNice.hope, hopeFaces),
        fear: await getDiceSoNicePreset(diceSoNice.fear, fearFaces),
        advantage: await getDiceSoNicePreset(diceSoNice.advantage, advantageFaces),
        disadvantage: await getDiceSoNicePreset(diceSoNice.disadvantage, disadvantageFaces)
    };
};

const refreshTypes = {
    scene: {
        id: 'session',
        label: 'DAGGERHEART.GENERAL.RefreshType.scene'
    },
    session: {
        id: 'session',
        label: 'DAGGERHEART.GENERAL.RefreshType.session'
    },
    shortRest: {
        id: 'shortRest',
        label: 'DAGGERHEART.GENERAL.RefreshType.shortrest'
    },
    longRest: {
        id: 'longRest',
        label: 'DAGGERHEART.GENERAL.RefreshType.longrest'
    }
};

const itemAbilityCosts = {
    resource: {
        id: 'resource',
        label: 'DAGGERHEART.GENERAL.resource',
        group: 'Global'
    },
    quantity: {
        id: 'quantity',
        label: 'DAGGERHEART.GENERAL.quantity',
        group: 'Global'
    }
};

const abilityCosts = {
    hitPoints: {
        id: 'hitPoints',
        label: 'DAGGERHEART.CONFIG.HealingType.hitPoints.name',
        group: 'Global'
    },
    stress: {
        id: 'stress',
        label: 'DAGGERHEART.CONFIG.HealingType.stress.name',
        group: 'Global'
    },
    hope: {
        id: 'hope',
        label: 'DAGGERHEART.CONFIG.HealingType.hope.name',
        group: 'TYPES.Actor.character'
    },
    armor: {
        id: 'armor',
        label: 'DAGGERHEART.CONFIG.HealingType.armor.name',
        group: 'TYPES.Actor.character'
    },
    fear: {
        id: 'fear',
        label: 'DAGGERHEART.CONFIG.HealingType.fear.name',
        group: 'TYPES.Actor.adversary'
    },
    resource: itemAbilityCosts.resource
};

const countdownProgressionTypes = {
    actionRoll: {
        id: 'actionRoll',
        label: 'DAGGERHEART.CONFIG.CountdownType.actionRoll'
    },
    characterAttack: {
        id: 'characterAttack',
        label: 'DAGGERHEART.CONFIG.CountdownType.characterAttack'
    },
    characterSpotlight: {
        id: 'characterSpotlight',
        label: 'DAGGERHEART.CONFIG.CountdownType.characterSpotlight'
    },
    custom: {
        id: 'custom',
        label: 'DAGGERHEART.CONFIG.CountdownType.custom'
    },
    fear: {
        id: 'fear',
        label: 'DAGGERHEART.CONFIG.CountdownType.fear'
    },
    spotlight: {
        id: 'spotlight',
        label: 'DAGGERHEART.CONFIG.CountdownType.spotlight'
    }
};
const rollTypes = {
    attack: {
        id: 'attack',
        label: 'DAGGERHEART.CONFIG.RollTypes.attack.name'
    },
    spellcast: {
        id: 'spellcast',
        label: 'DAGGERHEART.CONFIG.RollTypes.spellcast.name',
        playerOnly: true
    },
    trait: {
        id: 'trait',
        label: 'DAGGERHEART.CONFIG.RollTypes.trait.name',
        playerOnly: true
    },
    diceSet: {
        id: 'diceSet',
        label: 'DAGGERHEART.CONFIG.RollTypes.diceSet.name'
    }
};

const attributionSources = {
    daggerheart: {
        label: 'Daggerheart',
        values: [{ label: 'Daggerheart SRD' }]
    }
};

const fearDisplay = {
    token: { value: 'token', label: 'DAGGERHEART.SETTINGS.Appearance.fearDisplay.token' },
    bar: { value: 'bar', label: 'DAGGERHEART.SETTINGS.Appearance.fearDisplay.bar' },
    hide: { value: 'hide', label: 'DAGGERHEART.SETTINGS.Appearance.fearDisplay.hide' }
};

const basicOwnershiplevels = {
    0: { value: 0, label: 'OWNERSHIP.NONE' },
    2: { value: 2, label: 'OWNERSHIP.OBSERVER' },
    3: { value: 3, label: 'OWNERSHIP.OWNER' }
};

const simpleOwnershiplevels = {
    [-1]: { value: -1, label: 'OWNERSHIP.INHERIT' },
    ...basicOwnershiplevels
};

const countdownBaseTypes = {
    narrative: {
        id: 'narrative',
        label: 'DAGGERHEART.APPLICATIONS.Countdown.types.narrative'
    },
    encounter: {
        id: 'encounter',
        label: 'DAGGERHEART.APPLICATIONS.Countdown.types.encounter'
    }
};

const countdownLoopingTypes = {
    noLooping: {
        id: 'noLooping',
        label: 'DAGGERHEART.APPLICATIONS.Countdown.loopingTypes.noLooping'
    },
    looping: {
        id: 'looping',
        label: 'DAGGERHEART.APPLICATIONS.Countdown.loopingTypes.looping'
    },
    increasing: {
        id: 'increasing',
        label: 'DAGGERHEART.APPLICATIONS.Countdown.loopingTypes.increasing'
    },
    decreasing: {
        id: 'decreasing',
        label: 'DAGGERHEART.APPLICATIONS.Countdown.loopingTypes.decreasing'
    }
};

const countdownAppMode = {
    textIcon: 'text-icon',
    iconOnly: 'icon-only'
};

const sceneRangeMeasurementSetting = {
    disable: {
        id: 'disable',
        label: 'Disable Daggerheart Range Measurement'
    },
    default: {
        id: 'default',
        label: 'Default'
    },
    custom: {
        id: 'custom',
        label: 'Custom'
    }
};

var GENERAL = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abilityCosts: abilityCosts,
    attributionSources: attributionSources,
    basicOwnershiplevels: basicOwnershiplevels,
    burden: burden,
    compendiumJournals: compendiumJournals,
    conditions: conditions,
    countdownAppMode: countdownAppMode,
    countdownBaseTypes: countdownBaseTypes,
    countdownLoopingTypes: countdownLoopingTypes,
    countdownProgressionTypes: countdownProgressionTypes,
    damageTypes: damageTypes,
    deathMoves: deathMoves,
    defaultRestOptions: defaultRestOptions,
    defeatedConditionChoices: defeatedConditionChoices,
    defeatedConditions: defeatedConditions,
    diceSetNumbers: diceSetNumbers,
    diceTypes: diceTypes,
    fearDisplay: fearDisplay,
    getDiceSoNicePreset: getDiceSoNicePreset,
    getDiceSoNicePresets: getDiceSoNicePresets,
    healingTypes: healingTypes,
    itemAbilityCosts: itemAbilityCosts,
    multiplierTypes: multiplierTypes,
    otherTargetTypes: otherTargetTypes,
    range: range,
    rangeInclusion: rangeInclusion,
    refreshTypes: refreshTypes,
    rollTypes: rollTypes,
    ruleChoice: ruleChoice,
    sceneRangeMeasurementSetting: sceneRangeMeasurementSetting,
    simpleOwnershiplevels: simpleOwnershiplevels,
    targetTypes: targetTypes,
    templateRanges: templateRanges,
    templateTypes: templateTypes,
    tiers: tiers
});

const domains = {
    arcana: {
        id: 'arcana',
        label: 'DAGGERHEART.GENERAL.Domain.arcana.label',
        src: 'systems/daggerheart/assets/icons/domains/arcana.svg',
        description: 'DAGGERHEART.GENERAL.Domain.arcana.description'
    },
    blade: {
        id: 'blade',
        label: 'DAGGERHEART.GENERAL.Domain.blade.label',
        src: 'systems/daggerheart/assets/icons/domains/blade.svg',
        description: 'DAGGERHEART.GENERAL.Domain.blade.description'
    },
    bone: {
        id: 'bone',
        label: 'DAGGERHEART.GENERAL.Domain.bone.label',
        src: 'systems/daggerheart/assets/icons/domains/bone.svg',
        description: 'DAGGERHEART.GENERAL.Domain.bone.description'
    },
    codex: {
        id: 'codex',
        label: 'DAGGERHEART.GENERAL.Domain.codex.label',
        src: 'systems/daggerheart/assets/icons/domains/codex.svg',
        description: 'DAGGERHEART.GENERAL.Domain.codex.description'
    },
    grace: {
        id: 'grace',
        label: 'DAGGERHEART.GENERAL.Domain.grace.label',
        src: 'systems/daggerheart/assets/icons/domains/grace.svg',
        description: 'DAGGERHEART.GENERAL.Domain.grace.description'
    },
    midnight: {
        id: 'midnight',
        label: 'DAGGERHEART.GENERAL.Domain.midnight.label',
        src: 'systems/daggerheart/assets/icons/domains/midnight.svg',
        description: 'DAGGERHEART.GENERAL.Domain.midnight.description'
    },
    sage: {
        id: 'sage',
        label: 'DAGGERHEART.GENERAL.Domain.sage.label',
        src: 'systems/daggerheart/assets/icons/domains/sage.svg',
        description: 'DAGGERHEART.GENERAL.Domain.sage.description'
    },
    splendor: {
        id: 'splendor',
        label: 'DAGGERHEART.GENERAL.Domain.splendor.label',
        src: 'systems/daggerheart/assets/icons/domains/splendor.svg',
        description: 'DAGGERHEART.GENERAL.Domain.splendor.description'
    },
    valor: {
        id: 'valor',
        label: 'DAGGERHEART.GENERAL.Domain.valor.label',
        src: 'systems/daggerheart/assets/icons/domains/valor.svg',
        description: 'DAGGERHEART.GENERAL.Domain.valor.description'
    }
};

const allDomains = () => ({
    ...domains,
    ...game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).domains
});

const orderedDomains = () => {
    const all = {
        ...domains,
        ...game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).domains
    };
    return Object.values(all).sort((a, b) => game.i18n.localize(a.label).localeCompare(game.i18n.localize(b.label)));
};

const subclassMap = {
    syndicate: {
        id: 'syndicate',
        label: 'Syndicate'
    },
    nightwalker: {
        id: 'nightwalker',
        label: 'Nightwalker'
    }
};

const classMap = {
    rogue: {
        label: 'Rogue',
        subclasses: [subclassMap.syndicate.id, subclassMap.nightwalker.id]
    },
    seraph: {
        label: 'Seraph',
        subclasses: []
    }
};

const cardTypes = {
    ability: {
        id: 'ability',
        label: 'DAGGERHEART.CONFIG.DomainCardTypes.ability',
        img: ''
    },
    spell: {
        id: 'spell',
        label: 'DAGGERHEART.CONFIG.DomainCardTypes.spell',
        img: ''
    },
    grimoire: {
        id: 'grimoire',
        label: 'DAGGERHEART.CONFIG.DomainCardTypes.grimoire',
        img: ''
    }
};

var DOMAIN = /*#__PURE__*/Object.freeze({
    __proto__: null,
    allDomains: allDomains,
    cardTypes: cardTypes,
    classMap: classMap,
    domains: domains,
    orderedDomains: orderedDomains,
    subclassMap: subclassMap
});

const BaseBPPerEncounter = nrCharacters => 3 * nrCharacters + 2;

const AdversaryBPPerEncounter = (adversaries, characters) => {
    const adversaryTypes = CONFIG.DH.ACTOR.allAdversaryTypes();
    return adversaries
        .reduce((acc, adversary) => {
            const existingEntry = acc.find(
                x => x.adversary.name === adversary.name && x.adversary.type === adversary.type
            );
            if (existingEntry) {
                existingEntry.nr += 1;
            } else {
                acc.push({ adversary, nr: 1 });
            }
            return acc;
        }, [])
        .reduce((acc, entry) => {
            const adversary = entry.adversary;
            const type = adversaryTypes[adversary.type];
            const bpCost = type.bpCost ?? 0;
            if (type.partyAmountPerBP) {
                acc += characters.length === 0 ? 0 : Math.ceil(entry.nr / characters.length);
            } else {
                acc += bpCost;
            }

            return acc;
        }, 0);
};

const adversaryTypeCostBrackets = {
    1: [
        {
            sort: 1,
            types: ['minion'],
            description: 'DAGGERHEART.CONFIG.AdversaryTypeCost.minion'
        },
        {
            sort: 2,
            types: ['social', 'support'],
            description: 'DAGGERHEART.CONFIG.AdversaryTypeCost.support'
        }
    ],
    2: [
        {
            sort: 1,
            types: ['horde', 'ranged', 'skulk', 'standard'],
            description: 'DAGGERHEART.CONFIG.AdversaryTypeCost.standard'
        }
    ],
    3: [
        {
            sort: 1,
            types: ['leader'],
            description: 'DAGGERHEART.CONFIG.AdversaryTypeCost.leader'
        }
    ],
    4: [
        {
            sort: 1,
            types: ['bruiser'],
            description: 'DAGGERHEART.CONFIG.AdversaryTypeCost.bruiser'
        }
    ],
    5: [
        {
            sort: 1,
            types: ['solo'],
            description: 'DAGGERHEART.CONFIG.AdversaryTypeCost.solo'
        }
    ]
};

const BPModifiers = {
    [-2]: {
        manySolos: {
            sort: 1,
            description: 'DAGGERHEART.CONFIG.BPModifiers.manySolos.description',
            automatic: true,
            conditional: (_combat, adversaries) => {
                return adversaries.filter(x => x.system.type === 'solo').length > 1;
            }
        },
        increaseDamage: {
            sort: 2,
            description: 'DAGGERHEART.CONFIG.BPModifiers.increaseDamage.description',
            effects: [
                {
                    name: 'DAGGERHEART.CONFIG.BPModifiers.increaseDamage.effect.name',
                    description: 'DAGGERHEART.CONFIG.BPModifiers.increaseDamage.effect.description',
                    img: 'icons/magic/control/buff-flight-wings-red.webp',
                    changes: [
                        {
                            key: 'system.bonuses.damage.physical.dice',
                            mode: 2,
                            value: '1d4'
                        },
                        {
                            key: 'system.bonuses.damage.magical.dice',
                            mode: 2,
                            value: '1d4'
                        }
                    ]
                }
            ]
        }
    },
    [-1]: {
        lessDifficult: {
            sort: 2,
            description: 'DAGGERHEART.CONFIG.BPModifiers.lessDifficult.description'
        }
    },
    1: {
        lowerTier: {
            sort: 1,
            description: 'DAGGERHEART.CONFIG.BPModifiers.lowerTier.description',
            automatic: true,
            conditional: (_combat, adversaries, characters) => {
                const characterMaxTier = characters.reduce((maxTier, character) => {
                    return character.system.tier > maxTier ? character.system.tier : maxTier;
                }, 1);
                return adversaries.some(adversary => adversary.system.tier < characterMaxTier);
            }
        },
        noToughies: {
            sort: 2,
            description: 'DAGGERHEART.CONFIG.BPModifiers.noToughies.description',
            automatic: true,
            conditional: (_combat, adversaries) => {
                const toughyTypes = ['bruiser', 'horde', 'leader', 'solo'];
                return (
                    adversaries.length > 0 &&
                    !adversaries.some(adversary => toughyTypes.includes(adversary.system.type))
                );
            }
        }
    },
    2: {
        moreDangerous: {
            sort: 2,
            description: 'DAGGERHEART.CONFIG.BPModifiers.moreDangerous.description'
        }
    }
};

var ENCOUNTER = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AdversaryBPPerEncounter: AdversaryBPPerEncounter,
    BPModifiers: BPModifiers,
    BaseBPPerEncounter: BaseBPPerEncounter,
    adversaryTypeCostBrackets: adversaryTypeCostBrackets
});

const abilities = {
    agility: {
        id: 'agility',
        label: 'DAGGERHEART.CONFIG.Traits.agility.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.agility.verb.sprint',
            'DAGGERHEART.CONFIG.Traits.agility.verb.leap',
            'DAGGERHEART.CONFIG.Traits.agility.verb.maneuver'
        ]
    },
    strength: {
        id: 'strength',
        label: 'DAGGERHEART.CONFIG.Traits.strength.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.strength.verb.lift',
            'DAGGERHEART.CONFIG.Traits.strength.verb.smash',
            'DAGGERHEART.CONFIG.Traits.strength.verb.grapple'
        ]
    },
    finesse: {
        id: 'finesse',
        label: 'DAGGERHEART.CONFIG.Traits.finesse.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.finesse.verb.control',
            'DAGGERHEART.CONFIG.Traits.finesse.verb.hide',
            'DAGGERHEART.CONFIG.Traits.finesse.verb.tinker'
        ]
    },
    instinct: {
        id: 'instinct',
        label: 'DAGGERHEART.CONFIG.Traits.instinct.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.instinct.verb.perceive',
            'DAGGERHEART.CONFIG.Traits.instinct.verb.sense',
            'DAGGERHEART.CONFIG.Traits.instinct.verb.navigate'
        ]
    },
    presence: {
        id: 'presence',
        label: 'DAGGERHEART.CONFIG.Traits.presence.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.presence.verb.charm',
            'DAGGERHEART.CONFIG.Traits.presence.verb.perform',
            'DAGGERHEART.CONFIG.Traits.presence.verb.deceive'
        ]
    },
    knowledge: {
        id: 'knowledge',
        label: 'DAGGERHEART.CONFIG.Traits.knowledge.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.knowledge.verb.recall',
            'DAGGERHEART.CONFIG.Traits.knowledge.verb.analyze',
            'DAGGERHEART.CONFIG.Traits.knowledge.verb.comprehend'
        ]
    }
};

const scrollingTextResource = {
    hitPoints: {
        label: 'DAGGERHEART.GENERAL.HitPoints.plural',
        reversed: true
    },
    stress: {
        label: 'DAGGERHEART.GENERAL.stress',
        reversed: true
    },
    hope: {
        label: 'DAGGERHEART.GENERAL.hope'
    },
    armor: {
        label: 'DAGGERHEART.GENERAL.armor',
        reversed: true
    }
};

const featureProperties = {
    agility: {
        name: 'DAGGERHEART.CONFIG.Traits.agility.name',
        path: actor => actor.system.traits.agility.data.value
    },
    strength: {
        name: 'DAGGERHEART.CONFIG.Traits.strength.name',
        path: actor => actor.system.traits.strength.data.value
    },
    finesse: {
        name: 'DAGGERHEART.CONFIG.Traits.finesse.name',
        path: actor => actor.system.traits.finesse.data.value
    },
    instinct: {
        name: 'DAGGERHEART.CONFIG.Traits.instinct.name',
        path: actor => actor.system.traits.instinct.data.value
    },
    presence: {
        name: 'DAGGERHEART.CONFIG.Traits.presence.name',
        path: actor => actor.system.traits.presence.data.value
    },
    knowledge: {
        name: 'DAGGERHEART.CONFIG.Traits.knowledge.name',
        path: actor => actor.system.traits.knowledge.data.value
    },
    spellcastingTrait: {
        name: 'DAGGERHEART.FeatureProperty.SpellcastingTrait',
        path: actor => actor.system.traits[actor.system.class.subclass.system.spellcastingTrait].data.value
    }
};

const adversaryTypes = {
    bruiser: {
        id: 'bruiser',
        label: 'DAGGERHEART.CONFIG.AdversaryType.bruiser.label',
        description: 'DAGGERHEART.ACTORS.Adversary.bruiser.description',
        bpCost: 4
    },
    horde: {
        id: 'horde',
        label: 'DAGGERHEART.CONFIG.AdversaryType.horde.label',
        description: 'DAGGERHEART.ACTORS.Adversary.horde.description',
        bpCost: 2
    },
    leader: {
        id: 'leader',
        label: 'DAGGERHEART.CONFIG.AdversaryType.leader.label',
        description: 'DAGGERHEART.ACTORS.Adversary.leader.description',
        bpCost: 3,
        bpDescription: 'DAGGERHEART.CONFIG.AdversaryType.leader.'
    },
    minion: {
        id: 'minion',
        label: 'DAGGERHEART.CONFIG.AdversaryType.minion.label',
        description: 'DAGGERHEART.ACTORS.Adversary.minion.description',
        bpCost: 1,
        partyAmountPerBP: true
    },
    ranged: {
        id: 'ranged',
        label: 'DAGGERHEART.CONFIG.AdversaryType.ranged.label',
        description: 'DAGGERHEART.ACTORS.Adversary.ranged.description',
        bpCost: 2
    },
    skulk: {
        id: 'skulk',
        label: 'DAGGERHEART.CONFIG.AdversaryType.skulk.label',
        description: 'DAGGERHEART.ACTORS.Adversary.skulk.description',
        bpCost: 2
    },
    social: {
        id: 'social',
        label: 'DAGGERHEART.CONFIG.AdversaryType.social.label',
        description: 'DAGGERHEART.ACTORS.Adversary.social.description',
        bpCost: 1
    },
    solo: {
        id: 'solo',
        label: 'DAGGERHEART.CONFIG.AdversaryType.solo.label',
        description: 'DAGGERHEART.ACTORS.Adversary.solo.description',
        bpCost: 5
    },
    standard: {
        id: 'standard',
        label: 'DAGGERHEART.CONFIG.AdversaryType.standard.label',
        description: 'DAGGERHEART.ACTORS.Adversary.standard.description',
        bpCost: 2
    },
    support: {
        id: 'support',
        label: 'DAGGERHEART.CONFIG.AdversaryType.support.label',
        description: 'DAGGERHEART.ACTORS.Adversary.support.description',
        bpCost: 1
    }
};

const allAdversaryTypes = () => ({
    ...adversaryTypes,
    ...game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).adversaryTypes
});

const environmentTypes = {
    exploration: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.exploration.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.exploration.description'
    },
    social: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.social.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.social.description'
    },
    traversal: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.traversal.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.traversal.description'
    },
    event: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.event.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.event.description'
    }
};

const adversaryTraits = {
    relentless: {
        name: 'DAGGERHEART.CONFIG.AdversaryTrait.relentless.name',
        description: 'DAGGERHEART.CONFIG.AdversaryTrait.relentless.description',
        tip: 'DAGGERHEART.CONFIG.AdversaryTrait.relentless.tip'
    },
    slow: {
        name: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.name',
        description: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.description',
        tip: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.tip'
    },
    minion: {
        name: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.name',
        description: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.description',
        tip: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.tip'
    }
};

const levelChoices = {
    attributes: {
        name: 'attributes',
        title: '',
        choices: []
    },
    hitPointSlots: {
        name: 'hitPointSlots',
        title: '',
        choices: []
    },
    stressSlots: {
        name: 'stressSlots',
        title: '',
        choices: []
    },
    experiences: {
        name: 'experiences',
        title: '',
        choices: 'system.experiences',
        nrChoices: 2
    },
    proficiency: {
        name: 'proficiency',
        title: '',
        choices: []
    },
    armorOrEvasionSlot: {
        name: 'armorOrEvasionSlot',
        title: 'Permanently add one Armor Slot or take +1 to your Evasion',
        choices: [
            { name: 'Armor Marks +1', path: 'armor' },
            { name: 'Evasion +1', path: 'evasion' }
        ],
        nrChoices: 1
    },
    majorDamageThreshold2: {
        name: 'majorDamageThreshold2',
        title: '',
        choices: []
    },
    severeDamageThreshold2: {
        name: 'severeDamageThreshold2',
        title: '',
        choices: []
    },
    // minorDamageThreshold2: {
    //     name: 'minorDamageThreshold2',
    //     title: '',
    //     choices: [],
    // },
    severeDamageThreshold3: {
        name: 'severeDamageThreshold3',
        title: '',
        choices: []
    },
    // major2OrSevere4DamageThreshold: {
    //     name: 'major2OrSevere4DamageThreshold',
    //     title: 'Increase your Major Damage Threshold by +2 or Severe Damage Threshold by +4',
    //     choices: [{ name: 'Major Damage Threshold +2', path: 'major' }, { name: 'Severe Damage Threshold +4', path: 'severe' }],
    //     nrChoices: 1,
    // },
    // minor1OrMajor1DamageThreshold: {
    //     name: 'minor1OrMajor1DamageThreshold',
    //     title: 'Increase your Minor or Major Damage Threshold by +1',
    //     choices: [{ name: 'Minor Damage Threshold +1', path: 'minor' }, { name: 'Major Damage Threshold +1', path: 'major' }],
    //     nrChoices: 1,
    // },
    severeDamageThreshold4: {
        name: 'severeDamageThreshold4',
        title: '',
        choices: []
    },
    // majorDamageThreshold1: {
    //     name: 'majorDamageThreshold2',
    //     title: '',
    //     choices: [],
    // },
    subclass: {
        name: 'subclass',
        title: 'Select subclass to upgrade',
        choices: []
    },
    multiclass: {
        name: 'multiclass',
        title: '',
        choices: [{}]
    }
};

const levelupData = {
    tier1: {
        id: '2_4',
        tier: 1,
        levels: [2, 3, 4],
        label: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.Label',
        info: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.InfoLabel',
        pretext: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.Pretext',
        posttext: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.Posttext',
        choices: {
            [levelChoices.attributes.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.attributes',
                maxChoices: 3
            },
            [levelChoices.hitPointSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.hitPointSlots',
                maxChoices: 1
            },
            [levelChoices.stressSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.stressSlots',
                maxChoices: 1
            },
            [levelChoices.experiences.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.experiences',
                maxChoices: 1
            },
            [levelChoices.proficiency.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.proficiency',
                maxChoices: 1
            },
            [levelChoices.armorOrEvasionSlot.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.armorOrEvasionSlot',
                maxChoices: 1
            },
            [levelChoices.majorDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.majorDamageThreshold2',
                maxChoices: 1
            },
            [levelChoices.severeDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.severeDamageThreshold2',
                maxChoices: 1
            }
        }
    },
    tier2: {
        id: '5_7',
        tier: 2,
        levels: [5, 6, 7],
        label: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.Label',
        info: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.InfoLabel',
        pretext: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.Pretext',
        posttext: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.Posttext',
        choices: {
            [levelChoices.attributes.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.attributes',
                maxChoices: 3
            },
            [levelChoices.hitPointSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.hitPointSlots',
                maxChoices: 2
            },
            [levelChoices.stressSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.stressSlots',
                maxChoices: 2
            },
            [levelChoices.experiences.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.experiences',
                maxChoices: 1
            },
            [levelChoices.proficiency.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.proficiency',
                maxChoices: 2
            },
            [levelChoices.armorOrEvasionSlot.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.armorOrEvasionSlot',
                maxChoices: 2
            },
            [levelChoices.majorDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.majorDamageThreshold2',
                maxChoices: 1
            },
            [levelChoices.severeDamageThreshold3.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.severeDamageThreshold3',
                maxChoices: 1
            },
            [levelChoices.subclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.subclass',
                maxChoices: 1
            },
            [levelChoices.multiclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.multiclass',
                maxChoices: 1,
                cost: 2
            }
        }
    },
    tier3: {
        id: '8_10',
        tier: 3,
        levels: [8, 9, 10],
        label: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.Label',
        info: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.InfoLabel',
        pretext: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.Pretext',
        posttext: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.Posttext',
        choices: {
            [levelChoices.attributes.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.attributes',
                maxChoices: 3
            },
            [levelChoices.hitPointSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.hitPointSlots',
                maxChoices: 2
            },
            [levelChoices.stressSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.stressSlots',
                maxChoices: 2
            },
            [levelChoices.experiences.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.experiences',
                maxChoices: 1
            },
            [levelChoices.proficiency.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.proficiency',
                maxChoices: 2
            },
            [levelChoices.armorOrEvasionSlot.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.armorOrEvasionSlot',
                maxChoices: 2
            },
            [levelChoices.majorDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.majorDamageThreshold2',
                maxChoices: 1
            },
            [levelChoices.severeDamageThreshold4.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.severeDamageThreshold4',
                maxChoices: 1
            },
            [levelChoices.subclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.subclass',
                maxChoices: 1
            },
            [levelChoices.multiclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.multiclass',
                maxChoices: 1,
                cost: 2
            }
        }
    }
};

const subclassFeatureLabels = {
    1: 'DAGGERHEART.ITEMS.DomainCard.foundationTitle',
    2: 'DAGGERHEART.ITEMS.DomainCard.specializationTitle',
    3: 'DAGGERHEART.ITEMS.DomainCard.masteryTitle'
};

var ACTOR = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abilities: abilities,
    adversaryTraits: adversaryTraits,
    adversaryTypes: adversaryTypes,
    allAdversaryTypes: allAdversaryTypes,
    environmentTypes: environmentTypes,
    featureProperties: featureProperties,
    levelChoices: levelChoices,
    levelupData: levelupData,
    scrollingTextResource: scrollingTextResource,
    subclassFeatureLabels: subclassFeatureLabels
});

const armorFeatures = {
    burning: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.burning.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.burning.description',
        actions: [
            {
                type: 'damage',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.burning.actions.burn.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.burning.actions.burn.description',
                img: 'icons/magic/fire/flame-burning-embers-yellow.webp',
                range: 'melee',
                target: {
                    type: 'hostile'
                },
                damage: {
                    parts: [
                        {
                            applyTo: 'stress',
                            value: {
                                custom: {
                                    enabled: true,
                                    formula: '1'
                                }
                            }
                        }
                    ]
                }
            }
        ]
    },
    channeling: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.effects.channeling.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.effects.channeling.description',
                img: 'icons/magic/symbols/rune-sigil-horned-blue.webp',
                changes: [
                    {
                        key: 'system.bonuses.roll.spellcast',
                        mode: 2,
                        value: '1'
                    }
                ]
            }
        ]
    },
    difficult: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.effects.difficult.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.effects.difficult.description',
                img: 'icons/magic/control/buff-flight-wings-red.webp',
                changes: [
                    {
                        key: 'system.traits.agility.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.strength.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.finesse.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.instinct.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.presence.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.knowledge.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    flexible: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.effects.flexible.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.effects.flexible.description',
                img: 'icons/magic/movement/abstract-ribbons-red-orange.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '1'
                    }
                ]
            }
        ]
    },
    fortified: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.effects.fortified.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.effects.fortified.description',
                img: 'icons/magic/defensive/shield-barrier-glowing-blue.webp',
                changes: [
                    {
                        key: 'system.rules.damageReduction.increasePerArmorMark',
                        mode: 5,
                        value: '2'
                    }
                ]
            }
        ]
    },
    gilded: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.effects.gilded.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.effects.gilded.description',
                img: 'icons/magic/control/control-influence-crown-gold.webp',
                changes: [
                    {
                        key: 'system.traits.presence.value',
                        mode: 2,
                        value: '1'
                    }
                ]
            }
        ]
    },
    heavy: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.effects.heavy.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.effects.heavy.description',
                img: 'icons/commodities/metal/ingot-worn-iron.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    hopeful: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.actions.hope.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.actions.hope.description',
                img: 'icons/magic/holy/barrier-shield-winged-blue.webp'
            }
        ]
    },
    impenetrable: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.actions.impenetrable.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.actions.impenetrable.description',
                img: 'icons/magic/defensive/shield-barrier-flaming-pentagon-purple-orange.webp',
                uses: {
                    max: 1,
                    recovery: 'shortRest',
                    value: 0
                },
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    magical: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.magical.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.magical.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.magical.effects.magical.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.magical.effects.magical.description',
                img: 'icons/magic/defensive/barrier-shield-dome-blue-purple.webp',
                changes: [
                    {
                        key: 'system.rules.damageReduction.magical',
                        mode: 5,
                        value: 1
                    }
                ]
            }
        ]
    },
    painful: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.painful.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.painful.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.painful.actions.pain.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.painful.actions.pain.description',
                img: 'icons/skills/wounds/injury-face-impact-orange.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    physical: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.physical.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.physical.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.physical.effects.physical.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.physical.effects.physical.description',
                img: 'icons/commodities/stone/ore-pile-tan.webp',
                changes: [
                    {
                        key: 'system.rules.damageReduction.physical',
                        mode: 5,
                        value: 1
                    }
                ]
            }
        ]
    },
    quiet: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.actions.quiet.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.actions.quiet.description',
                img: 'icons/magic/perception/silhouette-stealth-shadow.webp'
            }
        ]
    },
    reinforced: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.effects.reinforced.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.effects.reinforced.description',
                img: 'icons/magic/defensive/shield-barrier-glowing-triangle-green.webp',
                changes: [
                    {
                        key: 'system.bunuses.damageThresholds.major',
                        mode: 2,
                        value: '2'
                    },
                    {
                        key: 'system.bunuses.damageThresholds.severe',
                        mode: 2,
                        value: '2'
                    }
                ]
            }
        ]
    },
    resilient: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.description',
        actions: [
            {
                type: 'attack',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.actions.resilient.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.actions.resilient.description',
                img: 'icons/magic/life/heart-cross-purple-orange.webp',
                roll: {
                    type: 'diceSet',
                    diceRolling: {
                        compare: 'equal',
                        dice: 'd6',
                        multiplier: 'flat',
                        flatMultiplier: 1,
                        treshold: 6
                    }
                }
            }
        ]
    },
    sharp: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.effects.sharp.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.effects.sharp.description',
                img: 'icons/magic/defensive/shield-barrier-glowing-triangle-green.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.dice',
                        mode: 2,
                        value: '1d4'
                    },
                    {
                        key: 'system.bonuses.damage.secondaryWeapon.dice',
                        mode: 2,
                        value: '1d4'
                    }
                ]
            }
        ]
    },
    shifting: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.actions.shift.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.actions.shift.description',
                img: 'icons/magic/defensive/illusion-evasion-echo-purple.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    timeslowing: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.description',
        actions: [
            {
                type: 'attack',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.actions.slowTime.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.actions.slowTime.description',
                img: 'icons/magic/time/hourglass-brown-orange.webp',
                cost: [
                    {
                        key: 'armorSlot',
                        value: 1
                    }
                ],
                roll: {
                    type: 'diceSet',
                    diceRolling: {
                        dice: 'd4',
                        multiplier: 'flat',
                        flatMultiplier: 1
                    }
                }
            }
        ]
    },
    truthseeking: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.actions.truthseeking.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.actions.truthseeking.description',
                img: 'icons/magic/perception/orb-crystal-ball-scrying-blue.webp'
            }
        ]
    },
    veryheavy: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.effects.veryHeavy.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.effects.veryHeavy.description',
                img: 'icons/commodities/metal/ingot-stamped-steel.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-2'
                    },
                    {
                        key: 'system.traits.agility.value',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    warded: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.warded.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.warded.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.warded.effects.warded.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.warded.effects.warded.description',
                img: 'icons/magic/defensive/barrier-shield-dome-pink.webp',
                changes: [
                    {
                        key: 'system.resistance.magical.reduction',
                        mode: 2,
                        value: '@system.armorScore'
                    }
                ]
            }
        ]
    }
};

const allArmorFeatures = () => {
    const homebrewFeatures = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).itemFeatures
        .armorFeatures;
    return {
        ...armorFeatures,
        ...Object.keys(homebrewFeatures).reduce((acc, key) => {
            const feature = homebrewFeatures[key];
            const actions = feature.actions.map(action => ({
                ...action,
                effects: action.effects.map(effect => feature.effects.find(x => x.id === effect._id)),
                type: action.type
            }));
            const actionEffects = actions.flatMap(a => a.effects);

            const effects = feature.effects.filter(effect => !actionEffects.some(x => x.id === effect.id));

            acc[key] = { ...feature, label: feature.name, effects, actions };
            return acc;
        }, {})
    };
};

const orderedArmorFeatures = () => {
    const homebrewFeatures = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).itemFeatures
        .armorFeatures;
    const allFeatures = { ...armorFeatures, ...homebrewFeatures };
    const all = Object.keys(allFeatures).map(key => {
        const feature = allFeatures[key];
        return {
            ...feature,
            id: key,
            label: feature.label ?? feature.name
        };
    });
    return Object.values(all).sort((a, b) => game.i18n.localize(a.label).localeCompare(game.i18n.localize(b.label)));
};

const weaponFeatures = {
    barrier: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.effects.barrier.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.effects.barrier.description',
                img: 'icons/skills/melee/shield-block-bash-blue.webp',
                changes: [
                    {
                        key: 'system.armorScore',
                        mode: 2,
                        value: 'ITEM.@system.tier + 1'
                    },
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    bonded: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.effects.damage.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.effects.damage.description',
                img: 'icons/magic/symbols/chevron-elipse-circle-blue.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: '@system.levelData.level.current'
                    }
                ]
            }
        ]
    },
    bouncing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.actions.bounce.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.actions.bounce.description',
                img: 'icons/skills/movement/ball-spinning-blue.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1,
                        scalable: true,
                        step: 1
                    }
                ]
            }
        ]
    },
    brave: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.brave.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.brave.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.brave.effects.brave.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.brave.effects.brave.description',
                img: 'icons/magic/life/heart-cross-strong-flame-purple-orange.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.damageThresholds.severe',
                        mode: 2,
                        value: 'ITEM.@system.tier'
                    }
                ]
            }
        ]
    },
    brutal: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.actions.addDamage.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.actions.addDamage.description',
                img: 'icons/skills/melee/strike-dagger-blood-red.webp'
            }
        ]
    },
    burning: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.burning.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.burning.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.burning.actions.burn.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.burning.actions.burn.description',
                img: 'icons/magic/fire/blast-jet-stream-embers-orange.webp'
            }
        ]
    },
    charged: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.charged.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.charged.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.charged.actions.markStress.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.charged.actions.markStress.description',
                img: 'icons/magic/lightning/claws-unarmed-strike-teal.webp',
                target: {
                    type: 'self'
                },
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ],
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.charged.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.charged.description',
                        img: 'icons/magic/lightning/claws-unarmed-strike-teal.webp',
                        changes: [
                            {
                                key: 'system.proficiency',
                                mode: 2,
                                value: '1'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    concussive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.actions.attack.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.actions.attack.description',
                img: 'icons/skills/melee/shield-block-bash-yellow.webp',
                target: {
                    type: 'any'
                },
                cost: [
                    {
                        key: 'hope',
                        value: 1
                    }
                ]
            }
        ]
    },
    cumbersome: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.effects.cumbersome.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.effects.cumbersome.description',
                img: 'icons/commodities/metal/mail-plate-steel.webp',
                changes: [
                    {
                        key: 'system.traits.finesse.value',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    deadly: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.actions.extraDamage.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.actions.extraDamage.description',
                img: 'icons/skills/melee/strike-sword-dagger-runes-red.webp'
            }
        ]
    },
    deflecting: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.actions.deflect.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.actions.deflect.description',
                img: 'icons/skills/melee/hand-grip-sword-strike-orange.webp',
                target: {
                    type: 'self'
                },
                cost: [
                    {
                        type: 'armor',
                        value: 1
                    }
                ],
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.effects.deflecting.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.effects.deflecting.description',
                        img: 'icons/skills/melee/hand-grip-sword-strike-orange.webp',
                        changes: [
                            {
                                key: 'system.evasion',
                                mode: 2,
                                value: '@system.armorScore'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    destructive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.description',
        actions: [
            {
                type: 'damage',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.actions.attack.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.actions.attack.descriptive',
                img: 'icons/skills/melee/strike-flail-spiked-pink.webp',
                range: 'veryClose',
                target: {
                    type: 'hostile'
                },
                damage: {
                    parts: [
                        {
                            applyTo: 'stress',
                            value: {
                                custom: {
                                    enabled: true,
                                    formula: '1'
                                }
                            }
                        }
                    ]
                }
            }
        ],
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.effects.agility',
                img: 'icons/skills/melee/strike-flail-spiked-pink.webp',
                changes: [
                    {
                        key: 'system.traits.agility.value',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    devastating: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.actions.devastate.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.actions.devastate.description',
                img: 'icons/skills/melee/strike-flail-destructive-yellow.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    doubleDuty: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.effects.doubleDuty.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.effects.doubleDuty.description',
                img: 'icons/skills/melee/sword-shield-stylized-white.webp',
                changes: [
                    {
                        key: 'system.armorScore',
                        mode: 2,
                        value: '1'
                    },
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: '1'
                    }
                ],
                system: {
                    rangeDependence: {
                        enabled: true,
                        range: 'melee',
                        target: 'hostile',
                        type: 'withinRange'
                    }
                }
            }
        ]
    },
    doubledUp: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.actions.doubleUp.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.actions.doubleUp.description',
                img: 'icons/skills/melee/strike-slashes-orange.webp'
            }
        ]
    },
    dueling: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.actions.duel.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.actions.duel.description',
                img: 'icons/skills/melee/weapons-crossed-swords-pink.webp'
            }
        ]
    },
    eruptive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.description',
        actions: [
            {
                type: 'effect', // Should prompt a dc 14 reaction save on adversaries
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.actions.erupt.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.actions.erupt.description',
                img: 'icons/skills/melee/strike-hammer-destructive-blue.webp'
            }
        ]
    },
    grappling: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.actions.grapple.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.actions.grapple.description',
                img: 'icons/magic/control/debuff-chains-ropes-net-white.webp',
                cost: [
                    {
                        key: 'hope',
                        value: 1
                    }
                ]
            }
        ]
    },
    greedy: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.description',
                img: 'icons/commodities/currency/coins-crown-stack-gold.webp',
                target: {
                    type: 'self'
                },
                // Should cost handful of gold,
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.actions.greed.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.actions.greed.description',
                        img: 'icons/commodities/currency/coins-crown-stack-gold.webp',
                        changes: [
                            {
                                key: 'system.proficiency',
                                mode: 2,
                                value: '1'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    healing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.healing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.healing.description',
        actions: [
            {
                type: 'healing',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.healing.actions.heal.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.healing.actions.heal.description',
                img: 'icons/magic/life/cross-beam-green.webp',
                target: {
                    type: 'self'
                },
                damage: {
                    parts: [
                        {
                            applyTo: 'hitPoints',
                            value: {
                                custom: {
                                    enabled: true,
                                    formula: 1
                                }
                            }
                        }
                    ]
                }
            }
        ]
    },
    heavy: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.effects.heavy.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.effects.heavy.description',
                img: 'icons/commodities/metal/ingot-worn-iron.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    hooked: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.actions.hook.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.actions.hook.description',
                img: 'icons/skills/melee/strike-chain-whip-blue.webp'
            }
        ]
    },
    hot: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.hot.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.hot.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.hot.actions.hot.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.hot.actions.hot.description',
                img: 'icons/magic/fire/dagger-rune-enchant-flame-red.webp'
            }
        ]
    },
    invigorating: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.actions.invigorate.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.actions.invigorate.description',
                img: 'icons/magic/life/heart-cross-green.webp'
            }
        ]
    },
    lifestealing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.actions.lifesteal.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.actions.lifesteal.description',
                img: 'icons/magic/unholy/hand-claw-fire-blue.webp'
            }
        ]
    },
    lockedOn: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.actions.lockOn.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.actions.lockOn.description',
                img: 'icons/skills/targeting/crosshair-arrowhead-blue.webp'
            }
        ]
    },
    long: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.long.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.long.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.long.actions.long.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.long.actions.long.description',
                img: 'icons/skills/melee/strike-weapon-polearm-ice-blue.webp'
            }
        ]
    },
    lucky: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.actions.luck.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.actions.luck.description',
                img: 'icons/magic/control/buff-luck-fortune-green.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    massive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.massive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.massive.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.massive.effects.massive.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.massive.effects.massive.description',
                img: 'icons/skills/melee/strike-flail-destructive-yellow.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    painful: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.painful.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.painful.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.painful.actions.pain.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.painful.actions.pain.description',
                img: 'icons/skills/wounds/injury-face-impact-orange.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    paired: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.paired.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.paired.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.paired.effects.paired.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.paired.effects.paired.description',
                img: 'icons/skills/melee/weapons-crossed-swords-yellow-teal.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: 'ITEM.@system.tier + 1'
                    }
                ],
                system: {
                    rangeDependence: {
                        enabled: true,
                        range: 'melee',
                        target: 'hostile',
                        type: 'withinRange'
                    }
                }
            }
        ]
    },
    parry: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.parry.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.parry.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.parry.actions.parry.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.parry.actions.parry.description',
                img: 'icons/skills/melee/shield-block-fire-orange.webp'
            }
        ]
    },
    persuasive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.actions.persuade.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.actions.persuade.description',
                img: 'icons/magic/control/hypnosis-mesmerism-eye.webp',
                target: {
                    type: 'self'
                },
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ],
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.effects.persuasive.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.effects.persuasive.description',
                        img: 'icons/magic/control/hypnosis-mesmerism-eye.webp',
                        changes: [
                            {
                                key: 'system.traits.presence.value',
                                mode: 2,
                                value: '2'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    pompous: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.actions.pompous.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.actions.pompous.description',
                img: 'icons/magic/control/control-influence-crown-gold.webp'
            }
        ]
    },
    powerful: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.effects.powerful.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.effects.powerful.description',
                img: 'icons/magic/control/buff-flight-wings-runes-red-yellow.webp',
                changes: []
            }
        ]
    },
    protective: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.protective.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.protective.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.protective.effects.protective.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.protective.effects.protective.description',
                img: 'icons/skills/melee/shield-block-gray-orange.webp',
                changes: [
                    {
                        key: 'system.armorScore',
                        mode: 2,
                        value: 'ITEM.@system.tier'
                    }
                ]
            }
        ]
    },
    quick: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.quick.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.quick.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.quick.actions.quick.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.quick.actions.quick.description',
                img: 'icons/skills/movement/arrow-upward-yellow.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    reliable: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.effects.reliable.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.effects.reliable.description',
                img: 'icons/skills/melee/strike-sword-slashing-red.webp',
                changes: [
                    {
                        key: 'system.bonuses.roll.primaryWeapon.bonus',
                        mode: 2,
                        value: 1
                    }
                ]
            }
        ]
    },
    reloading: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.actions.reload.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.actions.reload.description',
                img: 'icons/weapons/ammunition/shot-round-blue.webp'
            }
        ]
    },
    retractable: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.actions.retract.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.actions.retract.description',
                img: 'icons/skills/melee/blade-tip-smoke-green.webp'
            }
        ]
    },
    returning: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.returning.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.returning.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.returning.actions.return.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.returning.actions.return.description',
                img: 'icons/magic/movement/trail-streak-pink.webp'
            }
        ]
    },
    scary: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.scary.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.scary.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.scary.actions.scare.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.scary.actions.scare.description',
                img: 'icons/magic/death/skull-energy-light-purple.webp'
            }
        ]
    },
    selfCorrecting: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.effects.selfCorrecting.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.effects.selfCorrecting.description',
                img: 'icons/weapons/ammunition/arrow-broadhead-glowing-orange.webp',
                changes: []
            }
        ]
    },
    serrated: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.effects.serrated.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.effects.serrated.description',
                img: 'icons/weapons/ammunition/arrow-broadhead-glowing-orange.webp',
                changes: []
            }
        ]
    },
    sharpwing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.effects.sharpwing.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.effects.sharpwing.description',
                img: 'icons/weapons/swords/sword-winged-pink.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: '@system.traits.agility.value'
                    }
                ]
            }
        ]
    },
    sheltering: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.actions.shelter.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.actions.shelter.description',
                img: 'icons/skills/melee/shield-block-gray-yellow.webp'
            }
        ]
    },
    startling: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.startling.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.startling.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.startling.actions.startle.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.startling.actions.startle.description',
                img: 'icons/magic/control/fear-fright-mask-orange.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    timebending: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.actions.bendTime.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.actions.bendTime.description',
                img: 'icons/magic/time/clock-spinning-gold-pink.webp'
            }
        ]
    }
};

const allWeaponFeatures = () => {
    const homebrewFeatures = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).itemFeatures
        .weaponFeatures;

    return {
        ...weaponFeatures,
        ...Object.keys(homebrewFeatures).reduce((acc, key) => {
            const feature = homebrewFeatures[key];

            const actions = feature.actions.map(action => ({
                ...action,
                effects: action.effects.map(effect => feature.effects.find(x => x.id === effect._id)),
                type: action.type
            }));
            const actionEffects = actions.flatMap(a => a.effects);
            const effects = feature.effects.filter(effect => !actionEffects.some(x => x.id === effect.id));

            acc[key] = { ...feature, label: feature.name, effects, actions };
            return acc;
        }, {})
    };
};

const orderedWeaponFeatures = () => {
    const homebrewFeatures = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).itemFeatures
        .weaponFeatures;
    const allFeatures = { ...weaponFeatures, ...homebrewFeatures };
    const all = Object.keys(allFeatures).map(key => {
        const feature = allFeatures[key];
        return {
            ...feature,
            id: key,
            label: feature.label ?? feature.name
        };
    });
    return Object.values(all).sort((a, b) => game.i18n.localize(a.label).localeCompare(game.i18n.localize(b.label)));
};

const featureTypes = {
    ancestry: {
        id: 'ancestry',
        label: 'TYPES.Item.ancestry'
    },
    community: {
        id: 'community',
        label: 'TYPES.Item.community'
    },
    companion: {
        id: 'companion',
        label: 'TYPES.Actor.companion'
    },
    class: {
        id: 'class',
        label: 'TYPES.Item.class'
    },
    subclass: {
        id: 'subclass',
        label: 'TYPES.Item.subclass'
    },
    domainCard: {
        id: 'domainCard',
        label: 'TYPES.Item.domainCard'
    },
    armor: {
        id: 'armor',
        label: 'TYPES.Item.armor'
    },
    weapon: {
        id: 'weapon',
        label: 'TYPES.Item.weapon'
    },
    consumable: {
        id: 'consumable',
        label: 'TYPES.Item.consumable'
    },
    loot: {
        id: 'loot',
        label: 'TYPES.Item.loot'
    },
    beastform: {
        if: 'beastform',
        label: 'TYPES.Item.beastform'
    }
};

const featureSubTypes = {
    primary: 'primary',
    secondary: 'secondary',
    hope: 'hope',
    class: 'class',
    foundation: 'foundation',
    specialization: 'specialization',
    mastery: 'mastery'
};

const actionTypes$1 = {
    passive: {
        id: 'passive',
        label: 'DAGGERHEART.CONFIG.ActionType.passive'
    },
    action: {
        id: 'action',
        label: 'DAGGERHEART.CONFIG.ActionType.action'
    },
    reaction: {
        id: 'reaction',
        label: 'DAGGERHEART.CONFIG.ActionType.reaction'
    }
};

const itemResourceTypes = {
    simple: {
        id: 'simple',
        label: 'DAGGERHEART.CONFIG.ItemResourceType.simple'
    },
    diceValue: {
        id: 'diceValue',
        label: 'DAGGERHEART.CONFIG.ItemResourceType.diceValue'
    },
    die: {
        id: 'die',
        label: 'DAGGERHEART.CONFIG.ItemResourceType.die'
    }
};

const itemResourceProgression = {
    increasing: {
        id: 'increasing',
        label: 'DAGGERHEART.CONFIG.ItemResourceProgression.increasing'
    },
    decreasing: {
        id: 'decreasing',
        label: 'DAGGERHEART.CONFIG.ItemResourceProgression.decreasing'
    }
};

const beastformTypes = {
    normal: {
        id: 'normal',
        label: 'DAGGERHEART.CONFIG.BeastformType.normal'
    },
    evolved: {
        id: 'evolved',
        label: 'DAGGERHEART.CONFIG.BeastformType.evolved'
    },
    hybrid: {
        id: 'hybrid',
        label: 'DAGGERHEART.CONFIG.BeastformType.hybrid'
    }
};

const originItemType = {
    itemCollection: 'itemCollection',
    restMove: 'restMove'
};

var ITEM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actionTypes: actionTypes$1,
    allArmorFeatures: allArmorFeatures,
    allWeaponFeatures: allWeaponFeatures,
    armorFeatures: armorFeatures,
    beastformTypes: beastformTypes,
    featureSubTypes: featureSubTypes,
    featureTypes: featureTypes,
    itemResourceProgression: itemResourceProgression,
    itemResourceTypes: itemResourceTypes,
    orderedArmorFeatures: orderedArmorFeatures,
    orderedWeaponFeatures: orderedWeaponFeatures,
    originItemType: originItemType,
    weaponFeatures: weaponFeatures
});

const menu = {
    Automation: {
        Name: 'GameSettingsAutomation',
        Icon: 'fa-solid fa-robot'
    },
    Homebrew: {
        Name: 'GameSettingsHomebrew',
        Icon: 'fa-solid fa-flask-vial'
    },
    Range: {
        Name: 'GameSettingsRange',
        Icon: 'fa-solid fa-ruler'
    },
    VariantRules: {
        Name: 'GameSettingsVariantrules',
        Icon: 'fa-solid fa-scale-balanced'
    }
};

const gameSettings = {
    Automation: 'Automation',
    Homebrew: 'Homebrew',
    appearance: 'Appearance',
    variantRules: 'VariantRules',
    Resources: {
        Fear: 'ResourcesFear'
    },
    LevelTiers: 'LevelTiers',
    Countdowns: 'Countdowns',
    LastMigrationVersion: 'LastMigrationVersion',
    TagTeamRoll: 'TagTeamRoll'
};

const actionAutomationChoices = {
    never: {
        id: 'never',
        label: 'Never'
    },
    showDialog: {
        id: 'showDialog',
        label: 'Show Dialog only'
    },
    // npcOnly: {
    // id: "npcOnly",
    // label: "Always for non-characters"
    // },
    always: {
        id: 'always',
        label: 'Always'
    }
};

var SETTINGS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actionAutomationChoices: actionAutomationChoices,
    gameSettings: gameSettings,
    menu: menu
});

const valueTypes = {
    numberString: {
        id: 'numberString'
    },
    select: {
        id: 'select'
    }
};

const parseTypes = {
    string: {
        id: 'string'
    },
    number: {
        id: 'number'
    }
};

const applyLocations = {
    attackRoll: {
        id: 'attackRoll',
        name: 'DAGGERHEART.EFFECTS.ApplyLocations.attackRoll.name'
    },
    damageRoll: {
        id: 'damageRoll',
        name: 'DAGGERHEART.EFFECTS.ApplyLocations.damageRoll.name'
    }
};

const effectTypes = {
    health: {
        id: 'health',
        name: 'DAGGERHEART.EFFECTS.Types.HitPoints.name',
        values: [],
        valueType: valueTypes.numberString.id,
        parseType: parseTypes.number.id
    },
    stress: {
        id: 'stress',
        name: 'DAGGERHEART.EFFECTS.Types.Stress.name',
        valueType: valueTypes.numberString.id,
        parseType: parseTypes.number.id
    },
    reach: {
        id: 'reach',
        name: 'DAGGERHEART.EFFECTS.Types.Reach.name',
        valueType: valueTypes.select.id,
        parseType: parseTypes.string.id,
        options: Object.keys(range).map(x => ({ name: range[x].name, value: x }))
    },
    damage: {
        id: 'damage',
        name: 'DAGGERHEART.EFFECTS.Types.Damage.name',
        valueType: valueTypes.numberString.id,
        parseType: parseTypes.string.id,
        appliesOn: applyLocations.damageRoll.id,
        applyLocationChoices: {
            [applyLocations.damageRoll.id]: applyLocations.damageRoll.name,
            [applyLocations.attackRoll.id]: applyLocations.attackRoll.name
        }
    }
};

var EFFECTS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    applyLocations: applyLocations,
    effectTypes: effectTypes,
    parseTypes: parseTypes,
    valueTypes: valueTypes
});

const actionTypes = {
    attack: {
        id: 'attack',
        name: 'DAGGERHEART.ACTIONS.TYPES.attack.name',
        icon: 'fa-khanda',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.attack.tooltip'
    },
    countdown: {
        id: 'countdown',
        name: 'DAGGERHEART.ACTIONS.TYPES.countdown.name',
        icon: 'fa-hourglass-half',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.countdown.tooltip'
    },
    healing: {
        id: 'healing',
        name: 'DAGGERHEART.ACTIONS.TYPES.healing.name',
        icon: 'fa-kit-medical',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.healing.tooltip'
    },
    damage: {
        id: 'damage',
        name: 'DAGGERHEART.ACTIONS.TYPES.damage.name',
        icon: 'fa-heart-crack',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.damage.tooltip'
    },
    beastform: {
        id: 'beastform',
        name: 'DAGGERHEART.ACTIONS.TYPES.beastform.name',
        icon: 'fa-paw',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.beastform.tooltip'
    },
    summon: {
        id: 'summon',
        name: 'DAGGERHEART.ACTIONS.TYPES.summon.name',
        icon: 'fa-ghost',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.summon.tooltip'
    },
    effect: {
        id: 'effect',
        name: 'DAGGERHEART.ACTIONS.TYPES.effect.name',
        icon: 'fa-person-rays',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.effect.tooltip'
    },
    macro: {
        id: 'macro',
        name: 'DAGGERHEART.ACTIONS.TYPES.macro.name',
        icon: 'fa-scroll',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.macro.tooltip'
    }
};

const damageOnSave = {
    none: {
        id: 'none',
        label: 'None',
        mod: 0
    },
    half: {
        id: 'half',
        label: 'Half Damage',
        mod: 0.5
    },
    full: {
        id: 'full',
        label: 'Full damage',
        mod: 1
    }
};

const diceCompare = {
    below: {
        id: 'below',
        label: 'Below',
        operator: '<'
    },
    belowEqual: {
        id: 'belowEqual',
        label: 'Below or Equal',
        operator: '<='
    },
    equal: {
        id: 'equal',
        label: 'Equal',
        operator: '='
    },
    aboveEqual: {
        id: 'aboveEqual',
        label: 'Above or Equal',
        operator: '>='
    },
    above: {
        id: 'above',
        label: 'Above',
        operator: '>'
    }
};

const advantageState = {
    disadvantage: {
        label: 'DAGGERHEART.GENERAL.Disadvantage.full',
        value: -1
    },
    neutral: {
        label: 'DAGGERHEART.GENERAL.Neutral.full',
        value: 0
    },
    advantage: {
        label: 'DAGGERHEART.GENERAL.Advantage.full',
        value: 1
    }
};

var ACTIONS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actionTypes: actionTypes,
    advantageState: advantageState,
    damageOnSave: damageOnSave,
    diceCompare: diceCompare
});

const displayDomainCardsAsCard = 'displayDomainCardsAsCard';
const narrativeCountdown = {
    simple: 'countdown-narrative-simple',
    position: 'countdown-narrative-position'
};
const encounterCountdown = {
    simple: 'countdown-encounter-simple',
    position: 'countdown-encounter-position'
};

const compendiumBrowserDefault = {
    position: 'compendium-browser-default-position'
};

const compendiumBrowserNoFolder = {
    position: 'compendium-browser-no-folder-position'
};

const compendiumBrowserLite = {
    position: 'compendium-browser-lite-position'
};

const itemAttachmentSource = 'attachmentSource';

const userFlags = {
    welcomeMessage: 'welcome-message',
    countdownMode: 'countdown-mode'
};

const combatToggle = 'combat-toggle-origin';

var FLAGS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    combatToggle: combatToggle,
    compendiumBrowserDefault: compendiumBrowserDefault,
    compendiumBrowserLite: compendiumBrowserLite,
    compendiumBrowserNoFolder: compendiumBrowserNoFolder,
    displayDomainCardsAsCard: displayDomainCardsAsCard,
    encounterCountdown: encounterCountdown,
    itemAttachmentSource: itemAttachmentSource,
    narrativeCountdown: narrativeCountdown,
    userFlags: userFlags
});

const hooksConfig = {
    effectDisplayToggle: 'DHEffectDisplayToggle'
};

const typeConfig = {
    adversaries: {
        columns: [
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular'
            },
            {
                key: 'system.type',
                label: 'DAGGERHEART.GENERAL.type'
            }
        ],
        filters: [
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular',
                field: 'system.api.models.actors.DhAdversary.schema.fields.tier'
            },
            {
                key: 'system.type',
                label: 'DAGGERHEART.GENERAL.type',
                field: 'system.api.models.actors.DhAdversary.schema.fields.type'
            },
            {
                key: 'system.difficulty',
                name: 'difficulty.min',
                label: 'DAGGERHEART.UI.ItemBrowser.difficultyMin',
                field: 'system.api.models.actors.DhAdversary.schema.fields.difficulty',
                operator: 'gte'
            },
            {
                key: 'system.difficulty',
                name: 'difficulty.max',
                label: 'DAGGERHEART.UI.ItemBrowser.difficultyMax',
                field: 'system.api.models.actors.DhAdversary.schema.fields.difficulty',
                operator: 'lte'
            },
            {
                key: 'system.resources.hitPoints.max',
                name: 'hp.min',
                label: 'DAGGERHEART.UI.ItemBrowser.hitPointsMin',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.hitPoints.fields.max',
                operator: 'gte'
            },
            {
                key: 'system.resources.hitPoints.max',
                name: 'hp.max',
                label: 'DAGGERHEART.UI.ItemBrowser.hitPointsMax',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.hitPoints.fields.max',
                operator: 'lte'
            },
            {
                key: 'system.resources.stress.max',
                name: 'stress.min',
                label: 'DAGGERHEART.UI.ItemBrowser.stressMin',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.stress.fields.max',
                operator: 'gte'
            },
            {
                key: 'system.resources.stress.max',
                name: 'stress.max',
                label: 'DAGGERHEART.UI.ItemBrowser.stressMax',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.stress.fields.max',
                operator: 'lte'
            }
        ]
    },
    items: {
        columns: [
            {
                key: 'type',
                label: 'DAGGERHEART.GENERAL.type'
            },
            {
                key: 'system.secondary',
                label: 'DAGGERHEART.UI.ItemBrowser.subtype',
                format: isSecondary => (isSecondary ? 'secondary' : isSecondary === false ? 'primary' : '-')
            },
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular'
            }
        ],
        filters: [
            {
                key: 'type',
                label: 'DAGGERHEART.GENERAL.type',
                choices: () =>
                    CONFIG.Item.documentClass.TYPES.filter(t =>
                        ['armor', 'weapon', 'consumable', 'loot'].includes(t)
                    ).map(t => ({ value: t, label: t }))
            },
            {
                key: 'system.secondary',
                label: 'DAGGERHEART.UI.ItemBrowser.subtype',
                choices: [
                    { value: false, label: 'DAGGERHEART.ITEMS.Weapon.primaryWeapon' },
                    { value: true, label: 'DAGGERHEART.ITEMS.Weapon.secondaryWeapon' }
                ]
            },
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular',
                choices: [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' },
                    { value: '4', label: '4' }
                ]
            },
            {
                key: 'system.burden',
                label: 'DAGGERHEART.GENERAL.burden',
                field: 'system.api.models.items.DHWeapon.schema.fields.burden'
            },
            {
                key: 'system.attack.roll.trait',
                label: 'DAGGERHEART.GENERAL.Trait.single',
                field: 'system.api.models.actions.actionsTypes.attack.schema.fields.roll.fields.trait'
            },
            {
                key: 'system.attack.range',
                label: 'DAGGERHEART.GENERAL.range',
                field: 'system.api.models.actions.actionsTypes.attack.schema.fields.range'
            },
            {
                key: 'system.baseScore',
                name: 'armor.min',
                label: 'DAGGERHEART.UI.ItemBrowser.armorScoreMin',
                field: 'system.api.models.items.DHArmor.schema.fields.baseScore',
                operator: 'gte'
            },
            {
                key: 'system.baseScore',
                name: 'armor.max',
                label: 'DAGGERHEART.UI.ItemBrowser.armorScoreMax',
                field: 'system.api.models.items.DHArmor.schema.fields.baseScore',
                operator: 'lte'
            },
            {
                key: 'system.itemFeatures',
                label: 'DAGGERHEART.GENERAL.features',
                choices: () =>
                    [
                        ...Object.entries(CONFIG.DH.ITEM.weaponFeatures),
                        ...Object.entries(CONFIG.DH.ITEM.armorFeatures)
                    ].map(([k, v]) => ({ value: k, label: v.label })),
                operator: 'contains3'
            }
        ]
    },
    weapons: {
        columns: [
            {
                key: 'system.secondary',
                label: 'DAGGERHEART.UI.ItemBrowser.subtype',
                format: isSecondary => (isSecondary ? 'secondary' : isSecondary === false ? 'primary' : '-')
            },
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular'
            }
        ],
        filters: [
            {
                key: 'system.secondary',
                label: 'DAGGERHEART.UI.ItemBrowser.subtype',
                choices: [
                    { value: false, label: 'DAGGERHEART.ITEMS.Weapon.primaryWeapon' },
                    { value: true, label: 'DAGGERHEART.ITEMS.Weapon.secondaryWeapon' }
                ]
            },
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular',
                choices: [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' },
                    { value: '4', label: '4' }
                ]
            },
            {
                key: 'system.burden',
                label: 'DAGGERHEART.GENERAL.burden',
                field: 'system.api.models.items.DHWeapon.schema.fields.burden'
            },
            {
                key: 'system.attack.roll.trait',
                label: 'DAGGERHEART.GENERAL.Trait.single',
                field: 'system.api.models.actions.actionsTypes.attack.schema.fields.roll.fields.trait'
            },
            {
                key: 'system.attack.range',
                label: 'DAGGERHEART.GENERAL.range',
                field: 'system.api.models.actions.actionsTypes.attack.schema.fields.range'
            },
            {
                key: 'system.itemFeatures',
                label: 'DAGGERHEART.GENERAL.features',
                choices: () =>
                    Object.entries(CONFIG.DH.ITEM.weaponFeatures).map(([k, v]) => ({ value: k, label: v.label })),
                operator: 'contains3'
            }
        ]
    },
    armors: {
        columns: [
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular'
            }
        ],
        filters: [
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular',
                choices: [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' },
                    { value: '4', label: '4' }
                ]
            },
            {
                key: 'system.baseScore',
                name: 'armor.min',
                label: 'DAGGERHEART.UI.ItemBrowser.armorScoreMin',
                field: 'system.api.models.items.DHArmor.schema.fields.baseScore',
                operator: 'gte'
            },
            {
                key: 'system.baseScore',
                name: 'armor.max',
                label: 'DAGGERHEART.UI.ItemBrowser.armorScoreMax',
                field: 'system.api.models.items.DHArmor.schema.fields.baseScore',
                operator: 'lte'
            },
            {
                key: 'system.itemFeatures',
                label: 'DAGGERHEART.GENERAL.features',
                choices: () =>
                    Object.entries(CONFIG.DH.ITEM.armorFeatures).map(([k, v]) => ({ value: k, label: v.label })),
                operator: 'contains3'
            }
        ]
    },
    features: {
        columns: [],
        filters: []
    },
    cards: {
        columns: [
            {
                key: 'system.type',
                label: 'DAGGERHEART.GENERAL.type'
            },
            {
                key: 'system.domain',
                label: 'DAGGERHEART.GENERAL.Domain.single'
            },
            {
                key: 'system.level',
                label: 'DAGGERHEART.GENERAL.level'
            }
        ],
        filters: [
            {
                key: 'system.type',
                label: 'DAGGERHEART.GENERAL.type',
                field: 'system.api.models.items.DHDomainCard.schema.fields.type'
            },
            {
                key: 'system.domain',
                label: 'DAGGERHEART.GENERAL.Domain.single',
                field: 'system.api.models.items.DHDomainCard.schema.fields.domain',
                operator: 'contains2'
            },
            {
                key: 'system.level',
                name: 'level.min',
                label: 'DAGGERHEART.UI.ItemBrowser.levelMin',
                field: 'system.api.models.items.DHDomainCard.schema.fields.level',
                operator: 'gte'
            },
            {
                key: 'system.level',
                name: 'level.max',
                label: 'DAGGERHEART.UI.ItemBrowser.levelMax',
                field: 'system.api.models.items.DHDomainCard.schema.fields.level',
                operator: 'lte'
            },
            {
                key: 'system.recallCost',
                name: 'recall.min',
                label: 'DAGGERHEART.UI.ItemBrowser.recallCostMin',
                field: 'system.api.models.items.DHDomainCard.schema.fields.recallCost',
                operator: 'gte'
            },
            {
                key: 'system.recallCost',
                name: 'recall.max',
                label: 'DAGGERHEART.UI.ItemBrowser.recallCostMax',
                field: 'system.api.models.items.DHDomainCard.schema.fields.recallCost',
                operator: 'lte'
            }
        ]
    },
    classes: {
        columns: [
            {
                key: 'system.evasion',
                label: 'DAGGERHEART.GENERAL.evasion'
            },
            {
                key: 'system.hitPoints',
                label: 'DAGGERHEART.GENERAL.HitPoints.plural'
            },
            {
                key: 'system.domains',
                label: 'DAGGERHEART.GENERAL.Domain.plural'
            }
        ],
        filters: [
            {
                key: 'system.evasion',
                name: 'evasion.min',
                label: 'DAGGERHEART.UI.ItemBrowser.evasionMin',
                field: 'system.api.models.items.DHClass.schema.fields.evasion',
                operator: 'gte'
            },
            {
                key: 'system.evasion',
                name: 'evasion.max',
                label: 'DAGGERHEART.UI.ItemBrowser.evasionMax',
                field: 'system.api.models.items.DHClass.schema.fields.evasion',
                operator: 'lte'
            },
            {
                key: 'system.hitPoints',
                name: 'hp.min',
                label: 'DAGGERHEART.UI.ItemBrowser.hitPointsMin',
                field: 'system.api.models.items.DHClass.schema.fields.hitPoints',
                operator: 'gte'
            },
            {
                key: 'system.hitPoints',
                name: 'hp.max',
                label: 'DAGGERHEART.UI.ItemBrowser.hitPointsMax',
                field: 'system.api.models.items.DHClass.schema.fields.hitPoints',
                operator: 'lte'
            },
            {
                key: 'system.domains',
                label: 'DAGGERHEART.GENERAL.Domain.plural',
                choices: () => Object.values(CONFIG.DH.DOMAIN.allDomains()).map(d => ({ value: d.id, label: d.label })),
                operator: 'contains2'
            }
        ]
    },
    subclasses: {
        columns: [
            {
                key: 'system.linkedClass',
                label: 'Class',
                format: linkedClass => linkedClass?.name ?? 'DAGGERHEART.UI.ItemBrowser.missing'
            },
            {
                key: 'system.spellcastingTrait',
                label: 'DAGGERHEART.ITEMS.Subclass.spellcastingTrait'
            }
        ],
        filters: [
            {
                key: 'system.linkedClass.uuid',
                label: 'Class',
                choices: items => {
                    const list = items
                        .filter(item => item.system.linkedClass)
                        .map(item => ({
                            value: item.system.linkedClass.uuid,
                            label: item.system.linkedClass.name
                        }));
                    return list.reduce((a, c) => {
                        if (!a.find(i => i.value === c.value)) a.push(c);
                        return a;
                    }, []);
                }
            }
        ]
    },
    beastforms: {
        columns: [
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular'
            },
            {
                key: 'system.mainTrait',
                label: 'DAGGERHEART.GENERAL.Trait.single'
            }
        ],
        filters: [
            {
                key: 'system.tier',
                label: 'DAGGERHEART.GENERAL.Tiers.singular',
                field: 'system.api.models.items.DHBeastform.schema.fields.tier'
            },
            {
                key: 'system.mainTrait',
                label: 'DAGGERHEART.GENERAL.Trait.single',
                field: 'system.api.models.items.DHBeastform.schema.fields.mainTrait'
            }
        ]
    }
};

const compendiumConfig = {
    characters: {
        id: 'characters',
        keys: ['characters'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.characters',
        type: ['character']
        // listType: 'characters'
    },
    adversaries: {
        id: 'adversaries',
        keys: ['adversaries'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.adversaries',
        type: ['adversary'],
        listType: 'adversaries'
    },
    ancestries: {
        id: 'ancestries',
        keys: ['ancestries'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.ancestries',
        type: ['ancestry']
        /* folders: {
            features: {
                id: 'features',
                keys: ['ancestries'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.features',
                type: ['feature']
            }
        } */
    },
    equipments: {
        id: 'equipments',
        keys: ['armors', 'weapons', 'consumables', 'loot'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.equipment',
        type: ['armor', 'weapon', 'consumable', 'loot'],
        listType: 'items',
        folders: {
            weapons: {
                id: 'weapons',
                keys: ['weapons'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.weapons',
                type: ['weapon'],
                listType: 'weapons'
            },
            armors: {
                id: 'armors',
                keys: ['armors'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.armors',
                type: ['armor'],
                listType: 'armors'
            },
            consumables: {
                id: 'consumables',
                keys: ['consumables'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.consumables',
                type: ['consumable']
            },
            loots: {
                id: 'loots',
                keys: ['loots'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.loots',
                type: ['loot']
            }
        }
    },
    classes: {
        id: 'classes',
        keys: ['classes'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.classes',
        type: ['class'],
        /* folders: {
            features: {
                id: 'features',
                keys: ['classes'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.features',
                type: ['feature']
            },
            items: {
                id: 'items',
                keys: ['classes'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.items',
                type: ['armor', 'weapon', 'consumable', 'loot'],
                listType: 'items'
            }
        }, */
        listType: 'classes'
    },
    subclasses: {
        id: 'subclasses',
        keys: ['subclasses'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.subclasses',
        type: ['subclass'],
        listType: 'subclasses'
    },
    domains: {
        id: 'domains',
        keys: ['domains'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.domainCards',
        type: ['domainCard'],
        listType: 'cards'
    },
    communities: {
        id: 'communities',
        keys: ['communities'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.communities',
        type: ['community']
        /* folders: {
            features: {
                id: 'features',
                keys: ['communities'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.features',
                type: ['feature']
            }
        } */
    },
    environments: {
        id: 'environments',
        keys: ['environments'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.environments',
        type: ['environment']
    },
    beastforms: {
        id: 'beastforms',
        keys: ['beastforms'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.beastforms',
        type: ['beastform'],
        listType: 'beastforms'
        /* folders: {
            features: {
                id: 'features',
                keys: ['beastforms'],
                label: 'DAGGERHEART.UI.ItemBrowser.folders.features',
                type: ['feature']
            }
        } */
    },
    features: {
        id: 'features',
        keys: ['features'],
        label: 'DAGGERHEART.UI.ItemBrowser.folders.features',
        type: ['feature']
    }
};

var ITEMBROWSER = /*#__PURE__*/Object.freeze({
    __proto__: null,
    compendiumConfig: compendiumConfig,
    typeConfig: typeConfig
});

const SYSTEM_ID = 'daggerheart';

const SYSTEM = {
    id: SYSTEM_ID,
    ENCOUNTER,
    GENERAL,
    DOMAIN,
    ACTOR,
    ITEM,
    SETTINGS,
    EFFECTS,
    ACTIONS,
    FLAGS,
    HOOKS: hooksConfig,
    ITEMBROWSER
};

/*
Tagify v4.35.1 - tags input component
By: Yair Even-Or <vsync.design@gmail.com>
https://github.com/yairEO/tagify

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

This Software may not be rebranded and sold as a library under any other name
other than "Tagify" (by owner) or as part of another library.
*/

var t="&#8203;";function e(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function i(t){return function(t){if(Array.isArray(t))return e(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,i){if(!t)return;if("string"==typeof t)return e(t,i);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(n);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return e(t,i)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var n={isEnabled:function(){var t;return null===(t=window.TAGIFY_DEBUG)||void 0===t||t},log:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var s;this.isEnabled()&&(s=console).log.apply(s,["[Tagify]:"].concat(i(e)));},warn:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var s;this.isEnabled()&&(s=console).warn.apply(s,["[Tagify]:"].concat(i(e)));}},s=function(t,e,i,n){return t=""+t,e=""+e,n&&(t=t.trim(),e=e.trim()),i?t==e:t.toLowerCase()==e.toLowerCase()},a=function(t,e){return t&&Array.isArray(t)&&t.map((function(t){return o(t,e)}))};function o(t,e){var i,n={};for(i in t)e.indexOf(i)<0&&(n[i]=t[i]);return n}function r(t){return (new DOMParser).parseFromString(t.trim(),"text/html").body.firstElementChild}function l(t,e){for(e=e||"previous";t=t[e+"Sibling"];)if(3==t.nodeType)return t}function d(t){return "string"==typeof t?t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/`|'/g,"&#039;"):t}function c(t){var e=Object.prototype.toString.call(t).split(" ")[1].slice(0,-1);return t===Object(t)&&"Array"!=e&&"Function"!=e&&"RegExp"!=e&&"HTMLUnknownElement"!=e}function u(t,e,i){var n,s;function a(t,e){for(var i in e)if(e.hasOwnProperty(i)){if(c(e[i])){c(t[i])?a(t[i],e[i]):t[i]=Object.assign({},e[i]);continue}if(Array.isArray(e[i])){t[i]=Object.assign([],e[i]);continue}t[i]=e[i];}}return n=t,(null!=(s=Object)&&"undefined"!=typeof Symbol&&s[Symbol.hasInstance]?s[Symbol.hasInstance](n):n instanceof s)||(t={}),a(t,e),i&&a(t,i),t}function g(){var t=[],e={},i=true,n=false,s=void 0;try{for(var a,o=arguments[Symbol.iterator]();!(i=(a=o.next()).done);i=!0){var r=a.value,l=!0,d=!1,u=void 0;try{for(var g,h=r[Symbol.iterator]();!(l=(g=h.next()).done);l=!0){var p=g.value;c(p)?e[p.value]||(t.push(p),e[p.value]=1):t.includes(p)||t.push(p);}}catch(t){d=!0,u=t;}finally{try{l||null==h.return||h.return();}finally{if(d)throw u}}}}catch(t){n=true,s=t;}finally{try{i||null==o.return||o.return();}finally{if(n)throw s}}return t}function h(t){return String.prototype.normalize?"string"==typeof t?t.normalize("NFD").replace(/[\u0300-\u036f]/g,""):void 0:t}var p=function(){return /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent)};function f(){return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(function(t){return (t^crypto.getRandomValues(new Uint8Array(1))[0]&15>>t/4).toString(16)}))}function m(t){var e,i=b.call(this,t),n=null==t||null===(e=t.classList)||void 0===e?void 0:e.contains(this.settings.classNames.tag);return i&&n}function v(t){return b.call(this,t)&&(null==t?void 0:t.closest(this.settings.classNames.tagSelector))}function b(t){var e;return (null==t||null===(e=t.closest)||void 0===e?void 0:e.call(t,this.settings.classNames.namespaceSelector))===this.DOM.scope}function w(t,e){var i=window.getSelection();return e=e||i.getRangeAt(0),"string"==typeof t&&(t=document.createTextNode(t)),e&&(e.deleteContents(),e.insertNode(t)),t}function y(t,e,i){return t?(e&&(t.__tagifyTagData=i?e:u({},t.__tagifyTagData||{},e)),t.__tagifyTagData):(n.warn("tag element doesn't exist",{tagElm:t,data:e}),e)}function T(t){if(t&&t.parentNode){var e=t,i=window.getSelection(),n=i.getRangeAt(0);i.rangeCount&&(n.setStartAfter(e),n.collapse(true),i.removeAllRanges(),i.addRange(n));}}function O(t,e){t.forEach((function(t){if(y(t.previousSibling)||!t.previousSibling){var i=document.createTextNode("");t.before(i),e&&T(i);}}));}var D={delimiters:",",pattern:null,tagTextProp:"value",maxTags:1/0,callbacks:{},addTagOnBlur:true,addTagOn:["blur","tab","enter"],onChangeAfterBlur:true,duplicates:false,whitelist:[],blacklist:[],enforceWhitelist:false,userInput:true,focusable:true,focusInputOnRemove:true,keepInvalidTags:false,createInvalidTags:true,mixTagsAllowedAfter:/,|\.|\:|\s/,mixTagsInterpolator:["[[","]]"],backspace:true,skipInvalid:false,pasteAsTags:true,editTags:{clicks:2,keepInvalid:true},transformTag:function(){},trim:true,a11y:{focusableTags:false},mixMode:{insertAfterTag:""},autoComplete:{enabled:true,rightKey:false,tabKey:false},classNames:{namespace:"tagify",mixMode:"tagify--mix",selectMode:"tagify--select",input:"tagify__input",focus:"tagify--focus",tagNoAnimation:"tagify--noAnim",tagInvalid:"tagify--invalid",tagNotAllowed:"tagify--notAllowed",scopeLoading:"tagify--loading",hasMaxTags:"tagify--hasMaxTags",hasNoTags:"tagify--noTags",empty:"tagify--empty",inputInvalid:"tagify__input--invalid",dropdown:"tagify__dropdown",dropdownWrapper:"tagify__dropdown__wrapper",dropdownHeader:"tagify__dropdown__header",dropdownFooter:"tagify__dropdown__footer",dropdownItem:"tagify__dropdown__item",dropdownItemActive:"tagify__dropdown__item--active",dropdownItemHidden:"tagify__dropdown__item--hidden",dropdownItemSelected:"tagify__dropdown__item--selected",dropdownInital:"tagify__dropdown--initial",tag:"tagify__tag",tagText:"tagify__tag-text",tagX:"tagify__tag__removeBtn",tagLoading:"tagify__tag--loading",tagEditing:"tagify__tag--editable",tagFlash:"tagify__tag--flash",tagHide:"tagify__tag--hide"},dropdown:{classname:"",enabled:2,maxItems:10,searchKeys:["value","searchBy"],fuzzySearch:true,caseSensitive:false,accentedSearch:true,includeSelectedTags:false,escapeHTML:true,highlightFirst:true,closeOnSelect:true,clearOnSelect:true,position:"all",appendTarget:null},hooks:{beforeRemoveTag:function(){return Promise.resolve()},beforePaste:function(){return Promise.resolve()},suggestionClick:function(){return Promise.resolve()},beforeKeyDown:function(){return Promise.resolve()}}};function x(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function S(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){x(t,e,i[e]);}));}return t}function I(t,e){return e=null!=e?e:{},Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):function(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i.push.apply(i,n);}return i}(Object(e)).forEach((function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i));})),t}function M(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function E(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function N(t){return function(t){if(Array.isArray(t))return M(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return M(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return M(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function A(){for(var t in this.dropdown={},this._dropdown)this.dropdown[t]="function"==typeof this._dropdown[t]?this._dropdown[t].bind(this):this._dropdown[t];this.dropdown.refs(),this.DOM.dropdown.__tagify=this;}var _,C,k=(_=function(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){E(t,e,i[e]);}));}return t}({},{events:{binding:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=this.dropdown.events.callbacks,i=this.listeners.dropdown=this.listeners.dropdown||{position:this.dropdown.position.bind(this,null),onKeyDown:e.onKeyDown.bind(this),onMouseOver:e.onMouseOver.bind(this),onMouseLeave:e.onMouseLeave.bind(this),onClick:e.onClick.bind(this),onScroll:e.onScroll.bind(this)},n=t?"addEventListener":"removeEventListener";"manual"!=this.settings.dropdown.position&&(document[n]("scroll",i.position,true),window[n]("resize",i.position),window[n]("keydown",i.onKeyDown)),this.DOM.dropdown[n]("mouseover",i.onMouseOver),this.DOM.dropdown[n]("mouseleave",i.onMouseLeave),this.DOM.dropdown[n]("mousedown",i.onClick),this.DOM.dropdown.content[n]("scroll",i.onScroll);},callbacks:{onKeyDown:function(t){var e=this;if(this.state.hasFocus&&!this.state.composing){var i=this.settings,s=i.dropdown.includeSelectedTags,a=this.DOM.dropdown.querySelector(i.classNames.dropdownItemActiveSelector),o=this.dropdown.getSuggestionDataByNode(a),r="mix"==i.mode,l="select"==i.mode;i.hooks.beforeKeyDown(t,{tagify:this}).then((function(d){switch(t.key){case "ArrowDown":case "ArrowUp":case "Down":case "Up":t.preventDefault();var c=e.dropdown.getAllSuggestionsRefs(),u="ArrowUp"==t.key||"Up"==t.key;a&&(a=e.dropdown.getNextOrPrevOption(a,!u)),a&&a.matches(i.classNames.dropdownItemSelector)||(a=c[u?c.length-1:0]),e.dropdown.highlightOption(a,true);break;case "PageUp":case "PageDown":var g;t.preventDefault();var h=e.dropdown.getAllSuggestionsRefs(),p=Math.floor(e.DOM.dropdown.content.clientHeight/(null===(g=h[0])||void 0===g?void 0:g.offsetHeight))||1,f="PageUp"===t.key;if(a){var m=h.indexOf(a),v=f?Math.max(0,m-p):Math.min(h.length-1,m+p);a=h[v];}else a=h[0];e.dropdown.highlightOption(a,true);break;case "Home":case "End":t.preventDefault();var b=e.dropdown.getAllSuggestionsRefs();a=b["Home"===t.key?0:b.length-1],e.dropdown.highlightOption(a,true);break;case "Escape":case "Esc":e.dropdown.hide();break;case "ArrowRight":if(e.state.actions.ArrowLeft||i.autoComplete.rightKey)return;case "Tab":var w=!i.autoComplete.rightKey||!i.autoComplete.tabKey;if(!r&&!l&&a&&w&&!e.state.editing&&o){t.preventDefault();var y=e.dropdown.getMappedValue(o);return e.state.autoCompleteData=o,e.input.autocomplete.set.call(e,y),false}return  true;case "Enter":t.preventDefault(),e.state.actions.selectOption=true,setTimeout((function(){return e.state.actions.selectOption=false}),100),i.hooks.suggestionClick(t,{tagify:e,tagData:o,suggestionElm:a}).then((function(){if(a){var i=s?a:e.dropdown.getNextOrPrevOption(a,!u);e.dropdown.selectOption(a,t,(function(){if(i){var t=i.getAttribute("value");i=e.dropdown.getSuggestionNodeByValue(t),e.dropdown.highlightOption(i);}}));}else e.dropdown.hide(),r||e.addTags(e.state.inputText.trim(),true);})).catch((function(t){return n.warn(t)}));break;case "Backspace":if(r||e.state.editing.scope)return;var T=e.input.raw.call(e);""!=T&&8203!=T.charCodeAt(0)||(true===i.backspace?e.removeTags():"edit"==i.backspace&&setTimeout(e.editTag.bind(e),0));}}));}},onMouseOver:function(t){var e=t.target.closest(this.settings.classNames.dropdownItemSelector);this.dropdown.highlightOption(e);},onMouseLeave:function(t){this.dropdown.highlightOption();},onClick:function(t){var e=this;if(0==t.button&&t.target!=this.DOM.dropdown&&t.target!=this.DOM.dropdown.content){var i=t.target.closest(this.settings.classNames.dropdownItemSelector),s=this.dropdown.getSuggestionDataByNode(i);this.state.actions.selectOption=true,setTimeout((function(){return e.state.actions.selectOption=false}),100),this.settings.hooks.suggestionClick(t,{tagify:this,tagData:s,suggestionElm:i}).then((function(){i?e.dropdown.selectOption(i,t):e.dropdown.hide();})).catch((function(t){return n.warn(t)}));}},onScroll:function(t){var e=t.target,i=e.scrollTop/(e.scrollHeight-e.parentNode.clientHeight)*100;this.trigger("dropdown:scroll",{percentage:Math.round(i)});}}},refilter:function(t){t=t||this.state.dropdown.query||"",this.suggestedListItems=this.dropdown.filterListItems(t),this.dropdown.fill(),this.suggestedListItems.length||this.dropdown.hide(),this.trigger("dropdown:updated",this.DOM.dropdown);},getSuggestionDataByNode:function(t){for(var e,i=t&&t.getAttribute("value"),n=this.suggestedListItems.length;n--;){if(c(e=this.suggestedListItems[n])&&e.value==i)return e;if(e==i)return {value:e}}},getSuggestionNodeByValue:function(t){return this.dropdown.getAllSuggestionsRefs().find((function(e){return e.getAttribute("value")===t}))},getNextOrPrevOption:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.dropdown.getAllSuggestionsRefs(),n=i.findIndex((function(e){return e===t}));return e?i[n+1]:i[n-1]},highlightOption:function(t,e){var i,n=this.settings.classNames.dropdownItemActive;if(this.state.ddItemElm&&(this.state.ddItemElm.classList.remove(n),this.state.ddItemElm.removeAttribute("aria-selected")),!t)return this.state.ddItemData=null,this.state.ddItemElm=null,void this.input.autocomplete.suggest.call(this);i=this.dropdown.getSuggestionDataByNode(t),this.state.ddItemData=i,this.state.ddItemElm=t,t.classList.add(n),t.setAttribute("aria-selected",true),e&&(t.parentNode.scrollTop=t.clientHeight+t.offsetTop-t.parentNode.clientHeight),this.settings.autoComplete&&(this.input.autocomplete.suggest.call(this,i),this.dropdown.position());},selectOption:function(t,e,i){var n=this,s=this.settings,a=s.dropdown.includeSelectedTags,o=s.dropdown,r=o.clearOnSelect,l=o.closeOnSelect;if(!t)return this.addTags(this.state.inputText,true),void(l&&this.dropdown.hide());e=e||{};var d=t.getAttribute("value"),c="noMatch"==d,g="mix"==s.mode,h=this.suggestedListItems.find((function(t){var e;return (null!==(e=t.value)&&void 0!==e?e:t)==d}));if(this.trigger("dropdown:select",{data:h,elm:t,event:e}),h||c){if(this.state.editing){var p=this.normalizeTags([h])[0];h=s.transformTag.call(this,p)||p,this.onEditTagDone(null,u({__isValid:true},h));}else this[g?"addMixTags":"addTags"]([h||this.input.raw.call(this)],r);(g||this.DOM.input.parentNode)&&(setTimeout((function(){n.DOM.input.focus(),n.toggleFocusClass(true);})),l&&setTimeout(this.dropdown.hide.bind(this)),a?i&&i():(t.addEventListener("transitionend",(function(){n.dropdown.fillHeaderFooter(),setTimeout((function(){t.remove(),n.dropdown.refilter(),i&&i();}),100);}),{once:true}),t.classList.add(this.settings.classNames.dropdownItemHidden)));}else l&&setTimeout(this.dropdown.hide.bind(this));},selectAll:function(t){this.suggestedListItems.length=0,this.dropdown.hide(),this.dropdown.filterListItems("");var e=this.dropdown.filterListItems("");return t||(e=this.state.dropdown.suggestions),this.addTags(e,true),this},filterListItems:function(t,e){var i,n,s,a,o,r,l=function(){var t,l,d=void 0,u=void 0;t=m[T],n=(null!=(l=Object)&&"undefined"!=typeof Symbol&&l[Symbol.hasInstance]?l[Symbol.hasInstance](t):t instanceof l)?m[T]:{value:m[T]};var v,b=!Object.keys(n).some((function(t){return y.includes(t)}))?["value"]:y;g.fuzzySearch&&!e.exact?(a=b.reduce((function(t,e){return t+" "+(n[e]||"")}),"").toLowerCase().trim(),g.accentedSearch&&(a=h(a),r=h(r)),d=0==a.indexOf(r),u=a===r,v=a,s=r.toLowerCase().split(" ").every((function(t){return v.includes(t.toLowerCase())}))):(d=true,s=b.some((function(t){var i=""+(n[t]||"");return g.accentedSearch&&(i=h(i),r=h(r)),g.caseSensitive||(i=i.toLowerCase()),u=i===r,e.exact?i===r:0==i.indexOf(r)}))),o=!g.includeSelectedTags&&i.isTagDuplicate(c(n)?n.value:n),s&&!o&&(u&&d?f.push(n):"startsWith"==g.sortby&&d?p.unshift(n):p.push(n));},d=this,u=this.settings,g=u.dropdown,p=(e=e||{},[]),f=[],m=u.whitelist,v=g.maxItems>=0?g.maxItems:1/0,b=g.includeSelectedTags,w="function"==typeof g.sortby,y=g.searchKeys,T=0;if(!(t="select"==u.mode&&this.value.length&&this.value[0][u.tagTextProp]==t?"":t)||!y.length){p=b?m:m.filter((function(t){return !d.isTagDuplicate(c(t)?t.value:t)}));var O=w?g.sortby(p,r):p.slice(0,v);return this.state.dropdown.suggestions=O,O}for(r=g.caseSensitive?""+t:(""+t).toLowerCase();T<m.length;T++)i=this,l();this.state.dropdown.suggestions=f.concat(p);O=w?g.sortby(f.concat(p),r):f.concat(p).slice(0,v);return this.state.dropdown.suggestions=O,O},getMappedValue:function(t){var e=this.settings.dropdown.mapValueTo;return e?"function"==typeof e?e(t):t[e]||t.value:t.value},createListHTML:function(t){var e=this;return u([],t).map((function(t,i){"string"!=typeof t&&"number"!=typeof t||(t={value:t});var n=e.dropdown.getMappedValue(t);return n="string"==typeof n&&e.settings.dropdown.escapeHTML?d(n):n,e.settings.templates.dropdownItem.apply(e,[I(S({},t),{mappedValue:n}),e])})).join("")}}),C=null!=(C={refs:function(){this.DOM.dropdown=this.parseTemplate("dropdown",[this.settings]),this.DOM.dropdown.content=this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");},getHeaderRef:function(){return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']")},getFooterRef:function(){return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']")},getAllSuggestionsRefs:function(){return N(this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector))},show:function(t){var e,i,n,a=this,o=this.settings,r="mix"==o.mode&&!o.enforceWhitelist,l=!o.whitelist||!o.whitelist.length,d="manual"==o.dropdown.position;if(t=void 0===t?this.state.inputText:t,!(l&&!r&&!o.templates.dropdownItemNoMatch||false===o.dropdown.enabled||this.state.isLoading||this.settings.readonly)){if(clearTimeout(this.dropdownHide__bindEventsTimeout),this.suggestedListItems=this.dropdown.filterListItems(t),t&&!this.suggestedListItems.length&&(this.trigger("dropdown:noMatch",t),o.templates.dropdownItemNoMatch&&(n=o.templates.dropdownItemNoMatch.call(this,{value:t}))),!n){if(this.suggestedListItems.length)t&&r&&!this.state.editing.scope&&!s(this.suggestedListItems[0].value,t)&&this.suggestedListItems.unshift({value:t});else {if(!t||!r||this.state.editing.scope)return this.input.autocomplete.suggest.call(this),void this.dropdown.hide();this.suggestedListItems=[{value:t}];}i=""+(c(e=this.suggestedListItems[0])?e.value:e),o.autoComplete&&i&&0==i.indexOf(t)&&this.input.autocomplete.suggest.call(this,e);}this.dropdown.fill(n),o.dropdown.highlightFirst&&this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(o.classNames.dropdownItemSelector)),this.state.dropdown.visible||setTimeout(this.dropdown.events.binding.bind(this)),this.state.dropdown.visible=t||true,this.state.dropdown.query=t,this.setStateSelection(),d||setTimeout((function(){a.dropdown.position(),a.dropdown.render();})),setTimeout((function(){a.trigger("dropdown:show",a.DOM.dropdown);}));}},hide:function(t){var e=this,i=this.DOM,n=i.scope,s=i.dropdown,a="manual"==this.settings.dropdown.position&&!t;if(s&&document.body.contains(s)&&!a)return window.removeEventListener("resize",this.dropdown.position),this.dropdown.events.binding.call(this,false),n.setAttribute("aria-expanded",false),s.parentNode.removeChild(s),setTimeout((function(){e.state.dropdown.visible=false;}),100),this.state.dropdown.query=this.state.ddItemData=this.state.ddItemElm=this.state.selection=null,this.state.tag&&this.state.tag.value.length&&(this.state.flaggedTags[this.state.tag.baseOffset]=this.state.tag),this.trigger("dropdown:hide",s),this},toggle:function(t){this.dropdown[this.state.dropdown.visible&&!t?"hide":"show"]();},getAppendTarget:function(){var t=this.settings.dropdown;return "function"==typeof t.appendTarget?t.appendTarget():t.appendTarget},render:function(){var t,e,i,n=this,s=(t=this.DOM.dropdown,(i=t.cloneNode(true)).style.cssText="position:fixed; top:-9999px; opacity:0",document.body.appendChild(i),e=i.clientHeight,i.parentNode.removeChild(i),e),a=this.settings,o=this.dropdown.getAppendTarget();return  false===a.dropdown.enabled||(this.DOM.scope.setAttribute("aria-expanded",true),document.body.contains(this.DOM.dropdown)||(this.DOM.dropdown.classList.add(a.classNames.dropdownInital),this.dropdown.position(s),o.appendChild(this.DOM.dropdown),setTimeout((function(){return n.DOM.dropdown.classList.remove(a.classNames.dropdownInital)})))),this},fill:function(t){t="string"==typeof t?t:this.dropdown.createListHTML(t||this.suggestedListItems);var e,i=this.settings.templates.dropdownContent.call(this,t);this.DOM.dropdown.content.innerHTML=(e=i)?e.replace(/\>[\r\n ]+\</g,"><").split(/>\s+</).join("><").trim():"";},fillHeaderFooter:function(){var t=this.dropdown.filterListItems(this.state.dropdown.query),e=this.parseTemplate("dropdownHeader",[t]),i=this.parseTemplate("dropdownFooter",[t]),n=this.dropdown.getHeaderRef(),s=this.dropdown.getFooterRef();e&&(null==n||n.parentNode.replaceChild(e,n)),i&&(null==s||s.parentNode.replaceChild(i,s));},position:function(t){var e=this.settings.dropdown,i=this.dropdown.getAppendTarget();if("manual"!=e.position&&i){var n,s,a,o,r,l,d,c,u,g,h=this.DOM.dropdown,p=e.RTL,f=i===document.body,m=i===this.DOM.scope,v=f?window.pageYOffset:i.scrollTop,b=document.fullscreenElement||document.webkitFullscreenElement||document.documentElement,w=b.clientHeight,y=Math.max(b.clientWidth||0,window.innerWidth||0),T=y>480?e.position:"all",O=this.DOM["input"==T?"input":"scope"];if(t=t||h.clientHeight,this.state.dropdown.visible){if("text"==T?(a=(n=function(){var t=document.getSelection();if(t.rangeCount){var e,i,n=t.getRangeAt(0),s=n.startContainer,a=n.startOffset;if(a>0)return (i=document.createRange()).setStart(s,a-1),i.setEnd(s,a),{left:(e=i.getBoundingClientRect()).right,top:e.top,bottom:e.bottom};if(s.getBoundingClientRect)return s.getBoundingClientRect()}return {left:-9999,top:-9999}}()).bottom,s=n.top,o=n.left,r="auto"):(l=function(t){var e=0,i=0;for(t=t.parentNode;t&&t!=b;)e+=t.offsetTop||0,i+=t.offsetLeft||0,t=t.parentNode;return {top:e,left:i}}(i),n=O.getBoundingClientRect(),s=m?-1:n.top-l.top,a=(m?n.height:n.bottom-l.top)-1,o=m?-1:n.left-l.left,r=n.width+"px"),!f){var D=function(){for(var t=0,i=e.appendTarget.parentNode;i;)t+=i.scrollTop||0,i=i.parentNode;return t}();s+=D,a+=D;}var x;s=Math.floor(s),a=Math.ceil(a),c=y-o<120,u=((d=null!==(x=e.placeAbove)&&void 0!==x?x:w-n.bottom<t)?s:a)+v,g=o+(p&&n.width||0)+window.pageXOffset,g="text"==T&&c?"right: 0;":"left: ".concat(g,"px;"),h.style.cssText="".concat(g," top: ").concat(u,"px; min-width: ").concat(r,"; max-width: ").concat(r),h.setAttribute("placement",d?"top":"bottom"),h.setAttribute("position",T);}}}})?C:{},Object.getOwnPropertyDescriptors?Object.defineProperties(_,Object.getOwnPropertyDescriptors(C)):function(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i.push.apply(i,n);}return i}(Object(C)).forEach((function(t){Object.defineProperty(_,t,Object.getOwnPropertyDescriptor(C,t));})),_),L="@yaireo/tagify/",P={empty:"empty",exceed:"number of tags exceeded",pattern:"pattern mismatch",duplicate:"already exists",notAllowed:"not allowed"},j={wrapper:function(e,i){return '<tags class="'.concat(i.classNames.namespace," ").concat(i.mode?"".concat(i.classNames[i.mode+"Mode"]):""," ").concat(e.className,'"\n                    ').concat(i.readonly?"readonly":"","\n                    ").concat(i.disabled?"disabled":"","\n                    ").concat(i.required?"required":"","\n                    ").concat("select"===i.mode?"spellcheck='false'":"",'\n                    tabIndex="-1">\n                    ').concat(this.settings.templates.input.call(this),"\n                ").concat(t,"\n        </tags>")},input:function(){var e=this.settings,i=e.placeholder||t;return "<span ".concat(!e.readonly&&e.userInput?"contenteditable":"",' data-can-editable tabIndex="0" data-placeholder="').concat(i,'" aria-placeholder="').concat(e.placeholder||"",'"\n                    class="').concat(e.classNames.input,'"\n                    role="textbox"\n                    autocapitalize="false"\n                    autocorrect="off"\n                    aria-autocomplete="both"\n                    aria-multiline="').concat("mix"==e.mode,'"></span>')},tag:function(t,e){var i=e.settings;return '<tag title="'.concat(t.title||t.value,"\"\n                    contenteditable='false'\n                    tabIndex=\"").concat(i.a11y.focusableTags?0:-1,'"\n                    class="').concat(i.classNames.tag," ").concat(t.class||"",'"\n                    ').concat(this.getAttributes(t),">\n            <x title='' tabIndex=\"").concat(i.a11y.focusableTags?0:-1,'" class="').concat(i.classNames.tagX,"\" role='button' aria-label='remove tag'></x>\n            <div>\n                <span ").concat("select"===i.mode&&i.userInput?"contenteditable='true'":"",' autocapitalize="false" autocorrect="off" spellcheck=\'false\' class="').concat(i.classNames.tagText,'">').concat(t[i.tagTextProp]||t.value,"</span>\n            </div>\n        </tag>")},dropdown:function(t){var e=t.dropdown,i="manual"==e.position;return '<div class="'.concat(i?"":t.classNames.dropdown," ").concat(e.classname,'" role="listbox" aria-labelledby="dropdown" dir="').concat(e.RTL?"rtl":"","\">\n                    <div data-selector='tagify-suggestions-wrapper' class=\"").concat(t.classNames.dropdownWrapper,'"></div>\n                </div>')},dropdownContent:function(t){var e=this.settings.templates,i=this.state.dropdown.suggestions;return "\n            ".concat(e.dropdownHeader.call(this,i),"\n            ").concat(t,"\n            ").concat(e.dropdownFooter.call(this,i),"\n        ")},dropdownItem:function(t){return "<div ".concat(this.getAttributes(t),"\n                    class='").concat(this.settings.classNames.dropdownItem," ").concat(this.isTagDuplicate(t.value)?this.settings.classNames.dropdownItemSelected:""," ").concat(t.class||"",'\'\n                    tabindex="0"\n                    role="option">').concat(t.mappedValue||t.value,"</div>")},dropdownHeader:function(t){return "<header data-selector='tagify-suggestions-header' class=\"".concat(this.settings.classNames.dropdownHeader,'"></header>')},dropdownFooter:function(t){var e=t.length-this.settings.dropdown.maxItems;return e>0?"<footer data-selector='tagify-suggestions-footer' class=\"".concat(this.settings.classNames.dropdownFooter,'">\n                ').concat(e," more items. Refine your search.\n            </footer>"):""},dropdownItemNoMatch:null};function V(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function R(t,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](t):t instanceof e}function F(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var i=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=i){var n,s,a=[],o=true,r=false;try{for(i=i.call(t);!(o=(n=i.next()).done)&&(a.push(n.value),!e||a.length!==e);o=!0);}catch(t){r=true,s=t;}finally{try{o||null==i.return||i.return();}finally{if(r)throw s}}return a}}(t,e)||function(t,e){if(!t)return;if("string"==typeof t)return V(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return V(t,e)}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function H(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function B(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function W(t,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](t):t instanceof e}function q(t,e){return e=null!=e?e:{},Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):function(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i.push.apply(i,n);}return i}(Object(e)).forEach((function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i));})),t}function U(t){return function(t){if(Array.isArray(t))return H(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return H(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return H(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var K={customBinding:function(){var t=this;this.customEventsList.forEach((function(e){t.on(e,t.settings.callbacks[e]);}));},binding:function(){var t,e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],i=this.settings,n=this.events.callbacks,s=e?"addEventListener":"removeEventListener";if(!(this.state.mainEvents&&e||i.disabled||i.readonly)){for(var a in this.state.mainEvents=e,e&&!this.listeners.main&&(this.events.bindGlobal.call(this),this.settings.isJQueryPlugin&&jQuery(this.DOM.originalInput).on("tagify.removeAllTags",this.removeAllTags.bind(this))),t=this.listeners.main=this.listeners.main||{keydown:["input",n.onKeydown.bind(this)],click:["scope",n.onClickScope.bind(this)],dblclick:"select"!=i.mode&&["scope",n.onDoubleClickScope.bind(this)],paste:["input",n.onPaste.bind(this)],drop:["input",n.onDrop.bind(this)],compositionstart:["input",n.onCompositionStart.bind(this)],compositionend:["input",n.onCompositionEnd.bind(this)]})t[a]&&this.DOM[t[a][0]][s](a,t[a][1]);var o=this.listeners.main.inputMutationObserver||new MutationObserver(n.onInputDOMChange.bind(this));o.disconnect(),"mix"==i.mode&&o.observe(this.DOM.input,{childList:true}),this.events.bindOriginaInputListener.call(this);}},bindOriginaInputListener:function(t){var e=(t||0)+500;this.listeners.main&&(clearInterval(this.listeners.main.originalInputValueObserverInterval),this.listeners.main.originalInputValueObserverInterval=setInterval(this.events.callbacks.observeOriginalInputValue.bind(this),e));},bindGlobal:function(t){var e,i=this.events.callbacks,n=t?"removeEventListener":"addEventListener";if(this.listeners&&(t||!this.listeners.global)){this.listeners.global=this.listeners.global||[{type:this.isIE?"keydown":"input",target:this.DOM.input,cb:i[this.isIE?"onInputIE":"onInput"].bind(this)},{type:"keydown",target:window,cb:i.onWindowKeyDown.bind(this)},{type:"focusin",target:this.DOM.scope,cb:i.onFocusBlur.bind(this)},{type:"focusout",target:this.DOM.scope,cb:i.onFocusBlur.bind(this)},{type:"click",target:document,cb:i.onClickAnywhere.bind(this),useCapture:true}];var s=true,a=false,o=void 0;try{for(var r,l=this.listeners.global[Symbol.iterator]();!(s=(r=l.next()).done);s=!0)(e=r.value).target[n](e.type,e.cb,!!e.useCapture);}catch(t){a=true,o=t;}finally{try{s||null==l.return||l.return();}finally{if(a)throw o}}}},unbindGlobal:function(){this.events.bindGlobal.call(this,true);},callbacks:{onFocusBlur:function(t){var e,i,n=this.settings,s=v.call(this,t.relatedTarget),a=m.call(this,t.target),o=t.target.classList.contains(n.classNames.tagX),r="focusin"==t.type,l="focusout"==t.type;o&&"mix"!=n.mode&&n.focusInputOnRemove&&this.DOM.input.focus(),s&&r&&!a&&!o&&this.toggleFocusClass(this.state.hasFocus=+new Date);var d=t.target?this.trim(this.DOM.input.textContent):"",c=null===(i=this.value)||void 0===i||null===(e=i[0])||void 0===e?void 0:e[n.tagTextProp],u=n.dropdown.enabled>=0,g={relatedTarget:t.relatedTarget},h=this.state.actions.selectOption&&(u||!n.dropdown.closeOnSelect),p=this.state.actions.addNew&&u;if(l){if(t.relatedTarget===this.DOM.scope)return this.dropdown.hide(),void this.DOM.input.focus();this.postUpdate(),n.onChangeAfterBlur&&this.triggerChangeEvent();}if(!(h||p||o))if(this.state.hasFocus=!(!r&&!s)&&+new Date,this.toggleFocusClass(this.state.hasFocus),"mix"!=n.mode){if(r){if(!n.focusable)return;var f=0===n.dropdown.enabled&&!this.state.dropdown.visible,b=this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector);return this.trigger("focus",g),void(f&&!a&&(this.dropdown.show(this.value.length?"":void 0),"select"===n.mode&&this.setRangeAtStartEnd(false,b)))}if(l){if(this.trigger("blur",g),this.loading(false),"select"==n.mode){if(this.value.length){var w=this.getTagElms()[0];d=this.trim(w.textContent);}c===d&&(d="");}d&&!this.state.actions.selectOption&&n.addTagOnBlur&&n.addTagOn.includes("blur")&&this.addTags(d,true);}s||(this.DOM.input.removeAttribute("style"),this.dropdown.hide());}else r?this.trigger("focus",g):l&&(this.trigger("blur",g),this.loading(false),this.dropdown.hide(),this.state.dropdown.visible=void 0,this.setStateSelection());},onCompositionStart:function(t){this.state.composing=true;},onCompositionEnd:function(t){this.state.composing=false;},onWindowKeyDown:function(t){var e,i=this.settings,n=document.activeElement,s=v.call(this,n)&&this.DOM.scope.contains(n),a=n===this.DOM.input,o=s&&n.hasAttribute("readonly"),r=this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector),l=this.state.dropdown.visible;if(("Tab"===t.key&&l||this.state.hasFocus||s&&!o)&&!a){e=n.nextElementSibling;var d=t.target.classList.contains(i.classNames.tagX);switch(t.key){case "Backspace":i.readonly||this.state.editing||(this.removeTags(n),(e||this.DOM.input).focus());break;case "Enter":if(d)return void this.removeTags(t.target.parentNode);i.a11y.focusableTags&&m.call(this,n)&&setTimeout(this.editTag.bind(this),0,n);break;case "ArrowDown":this.state.dropdown.visible||"mix"==i.mode||this.dropdown.show();break;case "Tab":null==r||r.focus();}}},onKeydown:function(t){var e=this,i=this.settings;if(!this.state.composing&&i.userInput){"select"==i.mode&&i.enforceWhitelist&&this.value.length&&"Tab"!=t.key&&t.preventDefault();var n=this.trim(t.target.textContent);this.trigger("keydown",{event:t}),i.hooks.beforeKeyDown(t,{tagify:this}).then((function(s){if("mix"==i.mode){switch(t.key){case "Left":case "ArrowLeft":e.state.actions.ArrowLeft=true;break;case "Delete":case "Backspace":if(e.state.editing)return;var a=document.getSelection(),o="Delete"==t.key&&a.anchorOffset==(a.anchorNode.length||0),r=a.anchorNode.previousSibling,d=1==a.anchorNode.nodeType||!a.anchorOffset&&r&&1==r.nodeType&&a.anchorNode.previousSibling;!function(t){var e=document.createElement("div");t.replace(/\&#?[0-9a-z]+;/gi,(function(t){return e.innerHTML=t,e.innerText}));}(e.DOM.input.innerHTML);var c,u,g,h=e.getTagElms(),f=1===a.anchorNode.length&&a.anchorNode.nodeValue==String.fromCharCode(8203);if("edit"==i.backspace&&d)return c=1==a.anchorNode.nodeType?null:a.anchorNode.previousElementSibling,setTimeout(e.editTag.bind(e),0,c),void t.preventDefault();if(p()&&W(d,Element))return g=l(d),d.hasAttribute("readonly")||d.remove(),e.DOM.input.focus(),void setTimeout((function(){T(g),e.DOM.input.click();}));if("BR"==a.anchorNode.nodeName)return;if((o||d)&&1==a.anchorNode.nodeType?u=0==a.anchorOffset?o?h[0]:null:h[Math.min(h.length,a.anchorOffset)-1]:o?u=a.anchorNode.nextElementSibling:W(d,Element)&&(u=d),3==a.anchorNode.nodeType&&!a.anchorNode.nodeValue&&a.anchorNode.previousElementSibling&&t.preventDefault(),(d||o)&&!i.backspace)return void t.preventDefault();if("Range"!=a.type&&!a.anchorOffset&&a.anchorNode==e.DOM.input&&"Delete"!=t.key)return void t.preventDefault();if("Range"!=a.type&&u&&u.hasAttribute("readonly"))return void T(l(u));"Delete"==t.key&&f&&y(a.anchorNode.nextSibling)&&e.removeTags(a.anchorNode.nextSibling);}return  true}var m="manual"==i.dropdown.position;switch(t.key){case "Backspace":"select"==i.mode&&i.enforceWhitelist&&e.value.length?e.removeTags():e.state.dropdown.visible&&"manual"!=i.dropdown.position||""!=t.target.textContent&&8203!=n.charCodeAt(0)||(true===i.backspace?e.removeTags():"edit"==i.backspace&&setTimeout(e.editTag.bind(e),0));break;case "Esc":case "Escape":if(e.state.dropdown.visible)return;t.target.blur();break;case "Down":case "ArrowDown":e.state.dropdown.visible||e.dropdown.show();break;case "ArrowRight":var v=e.state.inputSuggestion||e.state.ddItemData;if(v&&i.autoComplete.rightKey)return void e.addTags([v],true);break;case "Tab":return  true;case "Enter":if(e.state.dropdown.visible&&!m)return;t.preventDefault();var b=e.state.autoCompleteData||n;setTimeout((function(){e.state.dropdown.visible&&!m||e.state.actions.selectOption||!i.addTagOn.includes(t.key.toLowerCase())||(e.addTags([b],true),e.state.autoCompleteData=null);}));}})).catch((function(t){return t}));}},onInput:function(t){this.postUpdate();var e=this.settings;if("mix"==e.mode)return this.events.callbacks.onMixTagsInput.call(this,t);var i=this.input.normalize.call(this,void 0,{trim:false}),n=i.length>=e.dropdown.enabled,s={value:i,inputElm:this.DOM.input},a=this.validateTag({value:i});"select"==e.mode&&this.toggleScopeValidation(a),s.isValid=a,this.state.inputText!=i&&(this.input.set.call(this,i,false),-1!=i.search(e.delimiters)?this.addTags(i)&&this.input.set.call(this):e.dropdown.enabled>=0&&this.dropdown[n?"show":"hide"](i),this.trigger("input",s));},onMixTagsInput:function(t){var e,i,n,s,a,o,r,l,d=this,c=this.settings,g=this.value.length,h=this.getTagElms(),f=document.createDocumentFragment(),m=window.getSelection().getRangeAt(0),v=[].map.call(h,(function(t){return y(t).value}));if("deleteContentBackward"==t.inputType&&p()&&this.events.callbacks.onKeydown.call(this,{target:t.target,key:"Backspace"}),O(this.getTagElms()),this.value.slice().forEach((function(t){t.readonly&&!v.includes(t.value)&&f.appendChild(d.createTagElem(t));})),f.childNodes.length&&(m.insertNode(f),this.setRangeAtStartEnd(false,f.lastChild)),h.length!=g)return this.value=[].map.call(this.getTagElms(),(function(t){return y(t)})),void this.update({withoutChangeEvent:true});if(this.hasMaxTags())return  true;if(window.getSelection&&(o=window.getSelection()).rangeCount>0&&3==o.anchorNode.nodeType){if((m=o.getRangeAt(0).cloneRange()).collapse(true),m.setStart(o.focusNode,0),n=(e=m.toString().slice(0,m.endOffset)).split(c.pattern).length-1,(i=e.match(c.pattern))&&(s=e.slice(e.lastIndexOf(i[i.length-1]))),s){if(this.state.actions.ArrowLeft=false,this.state.tag={prefix:s.match(c.pattern)[0],value:s.replace(c.pattern,"")},this.state.tag.baseOffset=o.baseOffset-this.state.tag.value.length,l=this.state.tag.value.match(c.delimiters))return this.state.tag.value=this.state.tag.value.replace(c.delimiters,""),this.state.tag.delimiters=l[0],this.addTags(this.state.tag.value,c.dropdown.clearOnSelect),void this.dropdown.hide();a=this.state.tag.value.length>=c.dropdown.enabled;try{r=(r=this.state.flaggedTags[this.state.tag.baseOffset]).prefix==this.state.tag.prefix&&r.value[0]==this.state.tag.value[0],this.state.flaggedTags[this.state.tag.baseOffset]&&!this.state.tag.value&&delete this.state.flaggedTags[this.state.tag.baseOffset];}catch(t){}(r||n<this.state.mixMode.matchedPatternCount)&&(a=false);}else this.state.flaggedTags={};this.state.mixMode.matchedPatternCount=n;}setTimeout((function(){d.update({withoutChangeEvent:true}),d.trigger("input",u({},d.state.tag,{textContent:d.DOM.input.textContent})),d.state.tag&&d.dropdown[a?"show":"hide"](d.state.tag.value);}),10);},onInputIE:function(t){var e=this;setTimeout((function(){e.events.callbacks.onInput.call(e,t);}));},observeOriginalInputValue:function(){this.DOM.originalInput.parentNode||this.destroy(),this.DOM.originalInput.value!=this.DOM.originalInput.tagifyValue&&this.loadOriginalValues();},onClickAnywhere:function(t){if(t.target!=this.DOM.scope&&!this.DOM.scope.contains(t.target)){this.toggleFocusClass(false),this.state.hasFocus=false;var e=t.target.closest(this.settings.classNames.dropdownSelector);(null==e?void 0:e.__tagify)!=this&&this.dropdown.hide();}},onClickScope:function(t){var e=this.settings,i=t.target.closest("."+e.classNames.tag);t.target,this.DOM.scope;var n=+new Date-this.state.hasFocus;if(!t.target.classList.contains(e.classNames.tagX))return i&&!this.state.editing?(this.trigger("click",{tag:i,index:this.getNodeIndex(i),data:y(i),event:t}),void(1!==e.editTags&&1!==e.editTags.clicks&&"select"!=e.mode||this.events.callbacks.onDoubleClickScope.call(this,t))):void(t.target==this.DOM.input&&("mix"==e.mode&&this.fixFirefoxLastTagNoCaret(),n>500||!e.focusable)?this.state.dropdown.visible?this.dropdown.hide():0===e.dropdown.enabled&&"mix"!=e.mode&&this.dropdown.show(this.value.length?"":void 0):"select"!=e.mode||0!==e.dropdown.enabled||this.state.dropdown.visible||(this.events.callbacks.onDoubleClickScope.call(this,q(function(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){B(t,e,i[e]);}));}return t}({},t),{target:this.getTagElms()[0]})),!e.userInput&&this.dropdown.show()));this.removeTags(t.target.parentNode);},onPaste:function(t){var e=this;t.preventDefault();var i,n,s,a=this.settings;if(!a.userInput)return  false;a.readonly||(n=t.clipboardData||window.clipboardData,s=n.getData("Text"),a.hooks.beforePaste(t,{tagify:this,pastedText:s,clipboardData:n}).then((function(a){ void 0===a&&(a=s),a&&(e.injectAtCaret(a,window.getSelection().getRangeAt(0)),"mix"==e.settings.mode?e.events.callbacks.onMixTagsInput.call(e,t):e.settings.pasteAsTags?i=e.addTags(e.state.inputText+a,true):(e.state.inputText=a,e.dropdown.show(a))),e.trigger("paste",{event:t,pastedText:s,clipboardData:n,tagsElems:i});})).catch((function(t){return t})));},onDrop:function(t){t.preventDefault();},onEditTagInput:function(t,e){var i,n=t.closest("."+this.settings.classNames.tag),s=this.getNodeIndex(n),a=y(n),o=this.input.normalize.call(this,t),r=(B(i={},this.settings.tagTextProp,o),B(i,"__tagId",a.__tagId),i),l=this.validateTag(r);this.editTagChangeDetected(u(a,r))||true!==t.originalIsValid||(l=true),n.classList.toggle(this.settings.classNames.tagInvalid,true!==l),a.__isValid=l,n.title=true===l?a.title||a.value:l,o.length>=this.settings.dropdown.enabled&&(this.state.editing&&(this.state.editing.value=o),this.dropdown.show(o)),this.trigger("edit:input",{tag:n,index:s,data:u({},this.value[s],{newValue:o}),event:e});},onEditTagPaste:function(t,e){var i=(e.clipboardData||window.clipboardData).getData("Text");e.preventDefault();var n=w(i);this.setRangeAtStartEnd(false,n);},onEditTagClick:function(t,e){this.events.callbacks.onClickScope.call(this,e);},onEditTagFocus:function(t){this.state.editing={scope:t,input:t.querySelector("[contenteditable]")};},onEditTagBlur:function(t,e){var i=m.call(this,e.relatedTarget);if("select"==this.settings.mode&&i&&e.relatedTarget.contains(e.target))this.dropdown.hide();else if(this.state.editing&&(this.state.hasFocus||this.toggleFocusClass(),this.DOM.scope.contains(document.activeElement)||this.trigger("blur",{}),this.DOM.scope.contains(t))){var n,s,a,o=this.settings,r=t.closest("."+o.classNames.tag),l=y(r),d=this.input.normalize.call(this,t),c=(B(n={},o.tagTextProp,d),B(n,"__tagId",l.__tagId),n),g=l.__originalData,h=this.editTagChangeDetected(u(l,c)),p=this.validateTag(c);if(d)if(h){var f;if(s=this.hasMaxTags(),a=u({},g,(B(f={},o.tagTextProp,this.trim(d)),B(f,"__isValid",p),f)),o.transformTag.call(this,a,g),true!==(p=(!s||true===g.__isValid)&&this.validateTag(a))){if(this.trigger("invalid",{data:a,tag:r,message:p}),o.editTags.keepInvalid)return;o.keepInvalidTags?a.__isValid=p:a=g;}else o.keepInvalidTags&&(delete a.title,delete a["aria-invalid"],delete a.class);this.onEditTagDone(r,a);}else this.onEditTagDone(r,g);else this.onEditTagDone(r);}},onEditTagkeydown:function(t,e){if(!this.state.composing)switch(this.trigger("edit:keydown",{event:t}),t.key){case "Esc":case "Escape":this.state.editing=false,!!e.__tagifyTagData.__originalData.value?e.parentNode.replaceChild(e.__tagifyTagData.__originalHTML,e):e.remove();break;case "Enter":case "Tab":t.preventDefault();setTimeout((function(){return t.target.blur()}),0);}},onDoubleClickScope:function(t){var e=t.target.closest("."+this.settings.classNames.tag);if(e){var i,n,s=y(e),a=this.settings;false!==(null==s?void 0:s.editable)&&(i=e.classList.contains(this.settings.classNames.tagEditing),n=e.hasAttribute("readonly"),a.readonly||i||n||!this.settings.editTags||!a.userInput||(this.events.callbacks.onEditTagFocus.call(this,e),this.editTag(e)),this.toggleFocusClass(true),"select"!=a.mode&&this.trigger("dblclick",{tag:e,index:this.getNodeIndex(e),data:y(e)}));}},onInputDOMChange:function(t){var e=this;t.forEach((function(t){t.addedNodes.forEach((function(t){if("<div><br></div>"==t.outerHTML)t.replaceWith(document.createElement("br"));else if(1==t.nodeType&&t.querySelector(e.settings.classNames.tagSelector)){var i,n=document.createTextNode("");3==t.childNodes[0].nodeType&&"BR"!=t.previousSibling.nodeName&&(n=document.createTextNode("\n")),(i=t).replaceWith.apply(i,U([n].concat(U(U(t.childNodes).slice(0,-1))))),T(n);}else if(m.call(e,t)){var s;if(3!=(null===(s=t.previousSibling)||void 0===s?void 0:s.nodeType)||t.previousSibling.textContent||t.previousSibling.remove(),t.previousSibling&&"BR"==t.previousSibling.nodeName){t.previousSibling.replaceWith("\n");for(var a=t.nextSibling,o="";a;)o+=a.textContent,a=a.nextSibling;o.trim()&&T(t.previousSibling);}else t.previousSibling&&!y(t.previousSibling)||t.before("");}})),t.removedNodes.forEach((function(t){t&&"BR"==t.nodeName&&m.call(e,i)&&(e.removeTags(i),e.fixFirefoxLastTagNoCaret());}));}));var i=this.DOM.input.lastChild;i&&""==i.nodeValue&&i.remove(),i&&"BR"==i.nodeName||this.DOM.input.appendChild(document.createElement("br"));}}};function z(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function X(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function J(t,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](t):t instanceof e}function G(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){X(t,e,i[e]);}));}return t}function $$1(t){return function(t){if(Array.isArray(t))return z(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return z(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return z(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Q(t,e){if(!t){n.warn("input element not found",t);var i=new Proxy(this,{get:function(){return function(){return i}}});return i}if(t.__tagify)return n.warn("input element is already Tagified - Same instance is returned.",t),t.__tagify;var s;u(this,function(t){var e=document.createTextNode(""),i={};function s(t,i,n){n&&i.split(/\s+/g).forEach((function(i){return e[t+"EventListener"].call(e,i,n)}));}return {removeAllCustomListeners:function(){Object.entries(i).forEach((function(t){var e=F(t,2),i=e[0];e[1].forEach((function(t){return s("remove",i,t)}));})),i={};},off:function(t,e){return t&&(e?s("remove",t,e):t.split(/\s+/g).forEach((function(t){var e;null===(e=i[t])||void 0===e||e.forEach((function(e){return s("remove",t,e)})),delete i[t];}))),this},on:function(t,e){return e&&"function"==typeof e&&(t.split(/\s+/g).forEach((function(t){Array.isArray(i[t])?i[t].push(e):i[t]=[e];})),s("add",t,e)),this},trigger:function(i,s,a){var o;if(a=a||{cloneData:true},i)if(t.settings.isJQueryPlugin)"remove"==i&&(i="removeTag"),jQuery(t.DOM.originalInput).triggerHandler(i,[s]);else {try{var r="object"==typeof s?s:{value:s};if((r=a.cloneData?u({},r):r).tagify=this,s.event&&(r.event=this.cloneEvent(s.event)),R(s,Object))for(var l in s)R(s[l],HTMLElement)&&(r[l]=s[l]);o=new CustomEvent(i,{detail:r});}catch(t){n.warn(t);}e.dispatchEvent(o);}}}}(this)),this.isFirefox=/firefox|fxios/i.test(navigator.userAgent)&&!/seamonkey/i.test(navigator.userAgent),this.isIE=window.document.documentMode,e=e||{},this.getPersistedData=(s=e.id,function(t){var e;if(s){var i,n="/"+t;if(1===(null===(e=localStorage)||void 0===e?void 0:e.getItem(L+s+"/v")))try{i=JSON.parse(localStorage[L+s+n]);}catch(t){}return i}}),this.setPersistedData=function(t){var e;return t?(null===(e=localStorage)||void 0===e||e.setItem(L+t+"/v",1),function(e,i){var n,s="/"+i,a=JSON.stringify(e);e&&i&&(null===(n=localStorage)||void 0===n||n.setItem(L+t+s,a),dispatchEvent(new Event("storage")));}):function(){}}(e.id),this.clearPersistedData=function(t){return function(e){var i=L+"/"+t+"/";if(e)localStorage.removeItem(i+e);else for(var n in localStorage)n.includes(i)&&localStorage.removeItem(n);}}(e.id),this.applySettings(t,e),this.state={inputText:"",editing:false,composing:false,actions:{},mixMode:{},dropdown:{},flaggedTags:{}},this.value=[],this.listeners={},this.DOM={},this.build(t),A.call(this),this.getCSSVars(),this.loadOriginalValues(),this.events.customBinding.call(this),this.events.binding.call(this),t.autofocus&&this.DOM.input.focus(),t.__tagify=this;}Q.prototype={_dropdown:k,placeCaretAfterNode:T,getSetTagData:y,helpers:{sameStr:s,removeCollectionProp:a,omit:o,isObject:c,parseHTML:r,escapeHTML:d,extend:u,concatWithoutDups:g,getUID:f,isNodeTag:m},customEventsList:["change","add","remove","invalid","input","paste","click","keydown","focus","blur","edit:input","edit:beforeUpdate","edit:updated","edit:start","edit:keydown","dropdown:show","dropdown:hide","dropdown:select","dropdown:updated","dropdown:noMatch","dropdown:scroll"],dataProps:["__isValid","__removed","__originalData","__originalHTML","__tagId"],trim:function(t){return this.settings.trim&&t&&"string"==typeof t?t.trim():t},parseHTML:r,templates:j,parseTemplate:function(t,e){return r((t=this.settings.templates[t]||t).apply(this,e))},set whitelist(t){var e=t&&Array.isArray(t);this.settings.whitelist=e?t:[],this.setPersistedData(e?t:[],"whitelist");},get whitelist(){return this.settings.whitelist},set userInput(t){this.settings.userInput=!!t,this.setContentEditable(!!t);},get userInput(){return this.settings.userInput},generateClassSelectors:function(t){var e=function(e){var i=e;Object.defineProperty(t,i+"Selector",{get:function(){return "."+this[i].split(" ")[0]}});};for(var i in t)e(i);},applySettings:function(t,e){var i,n;D.templates=this.templates;var s=u({},D,"mix"==e.mode?{dropdown:{position:"text"}}:{}),a=this.settings=u({},s,e);if(a.disabled=t.hasAttribute("disabled"),a.readonly=a.readonly||t.hasAttribute("readonly"),a.placeholder=d(t.getAttribute("placeholder")||a.placeholder||""),a.required=t.hasAttribute("required"),this.generateClassSelectors(a.classNames),this.isIE&&(a.autoComplete=false),["whitelist","blacklist"].forEach((function(e){var i=t.getAttribute("data-"+e);i&&J(i=i.split(a.delimiters),Array)&&(a[e]=i);})),"autoComplete"in e&&!c(e.autoComplete)&&(a.autoComplete=D.autoComplete,a.autoComplete.enabled=e.autoComplete),"mix"==a.mode&&(a.pattern=a.pattern||/@/,a.autoComplete.rightKey=true,a.delimiters=e.delimiters||null,a.tagTextProp&&!a.dropdown.searchKeys.includes(a.tagTextProp)&&a.dropdown.searchKeys.push(a.tagTextProp)),t.pattern)try{a.pattern=new RegExp(t.pattern);}catch(t){}if(a.delimiters){a._delimiters=a.delimiters;try{a.delimiters=new RegExp(this.settings.delimiters,"g");}catch(t){}}(a.disabled||a.readonly)&&(a.userInput=false),this.TEXTS=G({},P,a.texts||{}),"select"==a.mode&&(a.dropdown.includeSelectedTags=true),("select"!=a.mode||(null===(i=e.dropdown)||void 0===i?void 0:i.enabled))&&a.userInput||(a.dropdown.enabled=0),a.disabled&&(a.dropdown.enabled=false),a.dropdown.appendTarget=(null===(n=e.dropdown)||void 0===n?void 0:n.appendTarget)||document.body,void 0===a.dropdown.includeSelectedTags&&(a.dropdown.includeSelectedTags=a.duplicates);var o=this.getPersistedData("whitelist");Array.isArray(o)&&(this.whitelist=Array.isArray(a.whitelist)?g(a.whitelist,o):o);},getAttributes:function(t){var e,i=this.getCustomAttributes(t),n="";for(e in i)n+=" "+e+(void 0!==t[e]?'="'.concat(i[e],'"'):"");return n},getCustomAttributes:function(t){if(!c(t))return "";var e,i={};for(e in t)"__"!=e.slice(0,2)&&"class"!=e&&t.hasOwnProperty(e)&&void 0!==t[e]&&(i[e]=d(t[e]));return i},setStateSelection:function(){var t=window.getSelection(),e={anchorOffset:t.anchorOffset,anchorNode:t.anchorNode,range:t.getRangeAt&&t.rangeCount&&t.getRangeAt(0)};return this.state.selection=e,e},getCSSVars:function(){var t,e,i,n=getComputedStyle(this.DOM.scope,null);this.CSSVars={tagHideTransition:(t=function(t){if(!t)return {};var e=(t=t.trim().split(" ")[0]).split(/\d+/g).filter((function(t){return t})).pop().trim();return {value:+t.split(e).filter((function(t){return t}))[0].trim(),unit:e}}((i="tag-hide-transition",n.getPropertyValue("--"+i))),e=t.value,"s"==t.unit?1e3*e:e)};},build:function(t){var e=this.DOM,i=t.closest("label");this.settings.mixMode.integrated?(e.originalInput=null,e.scope=t,e.input=t):(e.originalInput=t,e.originalInput_tabIndex=t.tabIndex,e.scope=this.parseTemplate("wrapper",[t,this.settings]),e.input=e.scope.querySelector(this.settings.classNames.inputSelector),t.parentNode.insertBefore(e.scope,t),t.tabIndex=-1),i&&i.setAttribute("for","");},destroy:function(){var t;this.events.unbindGlobal.call(this),null===(t=this.DOM.scope.parentNode)||void 0===t||t.removeChild(this.DOM.scope),this.DOM.originalInput.tabIndex=this.DOM.originalInput_tabIndex,delete this.DOM.originalInput.__tagify,this.dropdown.hide(true),this.removeAllCustomListeners(),clearTimeout(this.dropdownHide__bindEventsTimeout),clearInterval(this.listeners.main.originalInputValueObserverInterval);},loadOriginalValues:function(t){var e,i=this.settings;if(this.state.blockChangeEvent=true,void 0===t){var n=this.getPersistedData("value");t=n&&!this.DOM.originalInput.value?n:i.mixMode.integrated?this.DOM.input.textContent:this.DOM.originalInput.value;}if(this.removeAllTags(),t)if("mix"==i.mode)this.parseMixTags(t),(e=this.DOM.input.lastChild)&&"BR"==e.tagName||this.DOM.input.insertAdjacentHTML("beforeend","<br>");else {try{J(JSON.parse(t),Array)&&(t=JSON.parse(t));}catch(t){}this.addTags(t,true).forEach((function(t){return t&&t.classList.add(i.classNames.tagNoAnimation)}));}else this.postUpdate();this.state.lastOriginalValueReported=i.mixMode.integrated?"":this.DOM.originalInput.value;},cloneEvent:function(t){var e={};for(var i in t)"path"!=i&&(e[i]=t[i]);return e},loading:function(t){return this.state.isLoading=t,this.DOM.scope.classList[t?"add":"remove"](this.settings.classNames.scopeLoading),this},tagLoading:function(t,e){return t&&t.classList[e?"add":"remove"](this.settings.classNames.tagLoading),this},toggleClass:function(t,e){"string"==typeof t&&this.DOM.scope.classList.toggle(t,e);},toggleScopeValidation:function(t){var e=true===t||void 0===t;!this.settings.required&&t&&t===this.TEXTS.empty&&(e=true),this.toggleClass(this.settings.classNames.tagInvalid,!e),this.DOM.scope.title=e?"":t;},toggleFocusClass:function(t){this.toggleClass(this.settings.classNames.focus,!!t);},setPlaceholder:function(t){var e=this;["data","aria"].forEach((function(i){return e.DOM.input.setAttribute("".concat(i,"-placeholder"),t)}));},triggerChangeEvent:function(){if(!this.settings.mixMode.integrated){var t=this.DOM.originalInput,e=this.state.lastOriginalValueReported!==t.value,i=new CustomEvent("change",{bubbles:true});e&&(this.state.lastOriginalValueReported=t.value,i.simulated=true,t._valueTracker&&t._valueTracker.setValue(Math.random()),t.dispatchEvent(i),this.trigger("change",this.state.lastOriginalValueReported),t.value=this.state.lastOriginalValueReported);}},events:K,fixFirefoxLastTagNoCaret:function(){},setRangeAtStartEnd:function(t,e){if(e){t="number"==typeof t?t:!!t,e=e.lastChild||e;var i=document.getSelection();if(J(i.focusNode,Element)&&!this.DOM.input.contains(i.focusNode))return  true;try{i.rangeCount>=1&&["Start","End"].forEach((function(n){return i.getRangeAt(0)["set"+n](e,t||e.length)}));}catch(t){console.warn(t);}}},insertAfterTag:function(t,e){if(e=e||this.settings.mixMode.insertAfterTag,t&&t.parentNode&&e)return e="string"==typeof e?document.createTextNode(e):e,t.parentNode.insertBefore(e,t.nextSibling),e},editTagChangeDetected:function(t){var e=t.__originalData;for(var i in e)if(!this.dataProps.includes(i)&&t[i]!=e[i])return  true;return  false},getTagTextNode:function(t){return t.querySelector(this.settings.classNames.tagTextSelector)},setTagTextNode:function(t,e){this.getTagTextNode(t).innerHTML=d(e);},editTag:function(t,e){var i=this;t=t||this.getLastTag(),e=e||{};var s=this.settings,a=this.getTagTextNode(t),o=this.getNodeIndex(t),r=y(t),l=this.events.callbacks,d=true,c="select"==s.mode;if(!c&&this.dropdown.hide(),a){if(!J(r,Object)||!("editable"in r)||r.editable)return r=y(t,{__originalData:u({},r),__originalHTML:t.cloneNode(true)}),y(r.__originalHTML,r.__originalData),a.setAttribute("contenteditable",true),t.classList.add(s.classNames.tagEditing),this.events.callbacks.onEditTagFocus.call(this,t),a.addEventListener("click",l.onEditTagClick.bind(this,t)),a.addEventListener("blur",l.onEditTagBlur.bind(this,this.getTagTextNode(t))),a.addEventListener("input",l.onEditTagInput.bind(this,a)),a.addEventListener("paste",l.onEditTagPaste.bind(this,a)),a.addEventListener("keydown",(function(e){return l.onEditTagkeydown.call(i,e,t)})),a.addEventListener("compositionstart",l.onCompositionStart.bind(this)),a.addEventListener("compositionend",l.onCompositionEnd.bind(this)),e.skipValidation||(d=this.editTagToggleValidity(t)),a.originalIsValid=d,this.trigger("edit:start",{tag:t,index:o,data:r,isValid:d}),a.focus(),!c&&this.setRangeAtStartEnd(false,a),0===s.dropdown.enabled&&!c&&this.dropdown.show(),this.state.hasFocus=true,this}else n.warn("Cannot find element in Tag template: .",s.classNames.tagTextSelector);},editTagToggleValidity:function(t,e){var i;if(e=e||y(t))return (i=!("__isValid"in e)||true===e.__isValid)||this.removeTagsFromValue(t),this.update(),t.classList.toggle(this.settings.classNames.tagNotAllowed,!i),e.__isValid=i,e.__isValid;n.warn("tag has no data: ",t,e);},onEditTagDone:function(t,e){t=t||this.state.editing.scope,e=e||{};var i,n,s=this.settings,a={tag:t,index:this.getNodeIndex(t),previousData:y(t),data:e};this.trigger("edit:beforeUpdate",a,{cloneData:false}),this.state.editing=false,delete e.__originalData,delete e.__originalHTML,t&&t.parentNode&&((void 0!==(n=e[s.tagTextProp])?null===(i=(n+="").trim)||void 0===i?void 0:i.call(n):s.tagTextProp in e?void 0:e.value)?(t=this.replaceTag(t,e),this.editTagToggleValidity(t,e),s.a11y.focusableTags?t.focus():"select"!=s.mode&&T(t)):this.removeTags(t)),this.trigger("edit:updated",a),s.dropdown.closeOnSelect&&this.dropdown.hide(),this.settings.keepInvalidTags&&this.reCheckInvalidTags();},replaceTag:function(t,e){e&&""!==e.value&&void 0!==e.value||(e=t.__tagifyTagData),e.__isValid&&1!=e.__isValid&&u(e,this.getInvalidTagAttrs(e,e.__isValid));var i=this.createTagElem(e);return t.parentNode.replaceChild(i,t),this.updateValueByDOMTags(),i},updateValueByDOMTags:function(){var t=this;this.value.length=0;var e=this.settings.classNames,i=[e.tagNotAllowed.split(" ")[0],e.tagHide];[].forEach.call(this.getTagElms(),(function(e){$$1(e.classList).some((function(t){return i.includes(t)}))||t.value.push(y(e));})),this.update(),this.dropdown.refilter();},injectAtCaret:function(t,e){var i;if(e=e||(null===(i=this.state.selection)||void 0===i?void 0:i.range),"string"==typeof t&&(t=document.createTextNode(t)),!e&&t)return this.appendMixTags(t),this;var n=w(t,e);return this.setRangeAtStartEnd(false,n),this.updateValueByDOMTags(),this.update(),this},input:{set:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.settings,n=i.dropdown.closeOnSelect;this.state.inputText=t,e&&(this.DOM.input.innerHTML=d(""+t),t&&this.toggleClass(i.classNames.empty,!this.DOM.input.innerHTML)),!t&&n&&this.dropdown.hide.bind(this),this.input.autocomplete.suggest.call(this),this.input.validate.call(this);},raw:function(){return this.DOM.input.textContent},validate:function(){var t=!this.state.inputText||true===this.validateTag({value:this.state.inputText});return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid,!t),t},normalize:function(t,e){var i=t||this.DOM.input,n=[];i.childNodes.forEach((function(t){return 3==t.nodeType&&n.push(t.nodeValue)})),n=n.join("\n");try{n=n.replace(/(?:\r\n|\r|\n)/g,this.settings.delimiters.source.charAt(0));}catch(t){}return n=n.replace(/\s/g," "),(null==e?void 0:e.trim)?this.trim(n):n},autocomplete:{suggest:function(t){if(this.settings.autoComplete.enabled){"object"!=typeof(t=t||{value:""})&&(t={value:t});var e=this.dropdown.getMappedValue(t);if("number"!=typeof e){var i=this.state.inputText.toLowerCase(),n=e.substr(0,this.state.inputText.length).toLowerCase(),s=e.substring(this.state.inputText.length);e&&this.state.inputText&&n==i?(this.DOM.input.setAttribute("data-suggest",s),this.state.inputSuggestion=t):(this.DOM.input.removeAttribute("data-suggest"),delete this.state.inputSuggestion);}}},set:function(t){var e=this.DOM.input.getAttribute("data-suggest"),i=t||(e?this.state.inputText+e:null);return !!i&&("mix"==this.settings.mode?this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix+i)):(this.input.set.call(this,i),this.setRangeAtStartEnd(false,this.DOM.input)),this.input.autocomplete.suggest.call(this),this.dropdown.hide(),true)}}},getTagIdx:function(t){return this.value.findIndex((function(e){return e.__tagId==(t||{}).__tagId}))},getNodeIndex:function(t){var e=0;if(t)for(;t=t.previousElementSibling;)e++;return e},getTagElms:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];var n="."+$$1(this.settings.classNames.tag.split(" ")).concat($$1(e)).join(".");return [].slice.call(this.DOM.scope.querySelectorAll(n))},getLastTag:function(){var t=this.settings.classNames,e=this.DOM.scope.querySelectorAll("".concat(t.tagSelector,":not(.").concat(t.tagHide,"):not([readonly])"));return e[e.length-1]},isTagDuplicate:function(t,e,i){var n=0,a=true,o=false,r=void 0;try{for(var l,d=this.value[Symbol.iterator]();!(a=(l=d.next()).done);a=!0){var c=l.value;s(this.trim(""+t),c.value,e)&&i!=c.__tagId&&n++;}}catch(t){o=true,r=t;}finally{try{a||null==d.return||d.return();}finally{if(o)throw r}}return n},getTagIndexByValue:function(t){var e=this,i=[],n=this.settings.dropdown.caseSensitive;return this.getTagElms().forEach((function(a,o){a.__tagifyTagData&&s(e.trim(a.__tagifyTagData.value),t,n)&&i.push(o);})),i},getTagElmByValue:function(t){var e=this.getTagIndexByValue(t)[0];return this.getTagElms()[e]},flashTag:function(t){var e=this;t&&(t.classList.add(this.settings.classNames.tagFlash),setTimeout((function(){t.classList.remove(e.settings.classNames.tagFlash);}),100));},isTagBlacklisted:function(t){return t=this.trim(t.toLowerCase()),this.settings.blacklist.filter((function(e){return (""+e).toLowerCase()==t})).length},isTagWhitelisted:function(t){return !!this.getWhitelistItem(t)},getWhitelistItem:function(t,e,i){e=e||"value";var n,a=this.settings;return (i=i||a.whitelist).some((function(i){var o="object"==typeof i?i[e]||i.value:i;if(s(o,t,a.dropdown.caseSensitive,a.trim))return n="object"==typeof i?i:{value:i},true})),n||"value"!=e||"value"==a.tagTextProp||(n=this.getWhitelistItem(t,a.tagTextProp,i)),n},validateTag:function(t){var e=this.settings,i="value"in t?"value":e.tagTextProp,n=this.trim(t[i]+"");return (t[i]+"").trim()?"mix"!=e.mode&&e.pattern&&J(e.pattern,RegExp)&&!e.pattern.test(n)?this.TEXTS.pattern:!e.duplicates&&this.isTagDuplicate(n,e.dropdown.caseSensitive,t.__tagId)?this.TEXTS.duplicate:this.isTagBlacklisted(n)||e.enforceWhitelist&&!this.isTagWhitelisted(n)?this.TEXTS.notAllowed:!e.validate||e.validate(t):this.TEXTS.empty},getInvalidTagAttrs:function(t,e){return {"aria-invalid":true,class:"".concat(t.class||""," ").concat(this.settings.classNames.tagNotAllowed).trim(),title:e}},hasMaxTags:function(){return this.value.length>=this.settings.maxTags&&this.TEXTS.exceed},setReadonly:function(t,e){var i=this.settings;this.DOM.scope.contains(document.activeElement)&&document.activeElement.blur(),i[e||"readonly"]=t,this.DOM.scope[(t?"set":"remove")+"Attribute"](e||"readonly",true),this.settings.userInput=true,this.setContentEditable(!t);},setContentEditable:function(t){this.DOM.scope.querySelectorAll("[data-can-editable]").forEach((function(e){e.contentEditable=t,e.tabIndex=t?0:-1;}));},setDisabled:function(t){this.setReadonly(t,"disabled");},normalizeTags:function(t){var e=this,i=this.settings,n=i.whitelist,s=i.delimiters,a=i.mode,o=i.tagTextProp,r=[],l=!!n&&J(n[0],Object),d=Array.isArray(t),g=d&&t[0].value,h=function(t){return (t+"").split(s).reduce((function(t,i){var n,s=e.trim(i);return s&&t.push((X(n={},o,s),X(n,"value",s),n)),t}),[])};if("number"==typeof t&&(t=t.toString()),"string"==typeof t){if(!t.trim())return [];t=h(t);}else d&&(t=t.reduce((function(t,i){if(c(i)){var n=u({},i);o in n||(o="value"),n[o]=e.trim(n[o]),(n[o]||0===n[o])&&t.push(n);}else if(null!=i&&""!==i&&void 0!==i){var s;(s=t).push.apply(s,$$1(h(i)));}return t}),[]));return l&&!g&&(t.forEach((function(t){var i=r.map((function(t){return t.value})),n=e.dropdown.filterListItems.call(e,t[o],{exact:true});e.settings.duplicates||(n=n.filter((function(t){return !i.includes(t.value)})));var s=n.length>1?e.getWhitelistItem(t[o],o,n):n[0];s&&J(s,Object)?r.push(s):"mix"!=a&&(null==t.value&&(t.value=t[o]),r.push(t));})),r.length&&(t=r)),t},parseMixTags:function(t){var e=this,i=this.settings,n=i.mixTagsInterpolator,s=i.duplicates,a=i.transformTag,o=i.enforceWhitelist,r=i.maxTags,l=i.tagTextProp,d=[];t=t.split(n[0]).map((function(t,i){var c,u,g,h=t.split(n[1]),p=h[0],f=d.length==r;try{if(p==+p)throw Error;u=JSON.parse(p);}catch(t){u=e.normalizeTags(p)[0]||{value:p};}if(a.call(e,u),f||!(h.length>1)||o&&!e.isTagWhitelisted(u.value)||!s&&e.isTagDuplicate(u.value)){if(t)return i?n[0]+t:t}else u[c=u[l]?l:"value"]=e.trim(u[c]),g=e.createTagElem(u),d.push(u),g.classList.add(e.settings.classNames.tagNoAnimation),h[0]=g.outerHTML,e.value.push(u);return h.join("")})).join(""),this.DOM.input.innerHTML=t,this.DOM.input.appendChild(document.createTextNode("")),this.DOM.input.normalize();var c=this.getTagElms();return c.forEach((function(t,e){return y(t,d[e])})),this.update({withoutChangeEvent:true}),O(c,this.state.hasFocus),t},replaceTextWithNode:function(t,e){if(this.state.tag||e){e=e||this.state.tag.prefix+this.state.tag.value;var i,n,s=this.state.selection||window.getSelection(),a=s.anchorNode,o=this.state.tag.delimiters?this.state.tag.delimiters.length:0;return a.splitText(s.anchorOffset-o),-1==(i=a.nodeValue.lastIndexOf(e))?true:(n=a.splitText(i),t&&a.parentNode.replaceChild(t,n),true)}},prepareNewTagNode:function(t,e){e=e||{};var i=this.settings,n=[],s={},a=Object.assign({},t,{value:t.value+""});if(t=Object.assign({},a),i.transformTag.call(this,t),t.__isValid=this.hasMaxTags()||this.validateTag(t),true!==t.__isValid){if(e.skipInvalid)return;if(u(s,this.getInvalidTagAttrs(t,t.__isValid),{__preInvalidData:a}),t.__isValid==this.TEXTS.duplicate&&this.flashTag(this.getTagElmByValue(t.value)),!i.createInvalidTags)return void n.push(t.value)}return "readonly"in t&&(t.readonly?s["aria-readonly"]=true:delete t.readonly),{tagElm:this.createTagElem(t,s),tagData:t,aggregatedInvalidInput:n}},postProcessNewTagNode:function(t,e){var i=this,n=this.settings,s=e.__isValid;s&&true===s?this.value.push(e):(this.trigger("invalid",{data:e,index:this.value.length,tag:t,message:s}),n.keepInvalidTags||setTimeout((function(){return i.removeTags(t,true)}),1e3)),this.dropdown.position();},selectTag:function(t,e){var i=this;if(!this.settings.enforceWhitelist||this.isTagWhitelisted(e.value)){this.state.actions.selectOption&&setTimeout((function(){return i.setRangeAtStartEnd(false,i.DOM.input)}));var n=this.getLastTag();return n?this.replaceTag(n,e):this.appendTag(t),this.value[0]=e,this.update(),this.trigger("add",{tag:t,data:e}),[t]}},addEmptyTag:function(t){var e=u({value:""},t||{}),i=this.createTagElem(e);y(i,e),this.appendTag(i),this.editTag(i,{skipValidation:true}),this.toggleFocusClass(true);},addTags:function(t,e,i){var n=this,s=[],a=this.settings,o=[],r=document.createDocumentFragment(),l=[];if(!t||0==t.length)return s;switch(t=this.normalizeTags(t),a.mode){case "mix":return this.addMixTags(t);case "select":e=false,this.removeAllTags();}return this.DOM.input.removeAttribute("style"),t.forEach((function(t){var e=n.prepareNewTagNode(t,{skipInvalid:i||a.skipInvalid});if(e){var d=e.tagElm;if(t=e.tagData,o=e.aggregatedInvalidInput,s.push(d),"select"==a.mode)return n.selectTag(d,t);r.appendChild(d),n.postProcessNewTagNode(d,t),l.push({tagElm:d,tagData:t});}})),this.appendTag(r),l.forEach((function(t){var e=t.tagElm,i=t.tagData;return n.trigger("add",{tag:e,index:n.getTagIdx(i),data:i})})),this.update(),t.length&&e&&(this.input.set.call(this,a.createInvalidTags?"":o.join(a._delimiters)),this.setRangeAtStartEnd(false,this.DOM.input)),this.dropdown.refilter(),s},addMixTags:function(t){var e=this;if((t=this.normalizeTags(t))[0].prefix||this.state.tag)return this.prefixedTextToTag(t[0]);var i=document.createDocumentFragment();return t.forEach((function(t){var n=e.prepareNewTagNode(t);i.appendChild(n.tagElm),e.insertAfterTag(n.tagElm),e.postProcessNewTagNode(n.tagElm,n.tagData);})),this.appendMixTags(i),i.children},appendMixTags:function(t){var e=!!this.state.selection;e?this.injectAtCaret(t):(this.DOM.input.focus(),(e=this.setStateSelection()).range.setStart(this.DOM.input,e.range.endOffset),e.range.setEnd(this.DOM.input,e.range.endOffset),this.DOM.input.appendChild(t),this.updateValueByDOMTags(),this.update());},prefixedTextToTag:function(t){var e,i,n,s=this,a=this.settings,o=null===(e=this.state.tag)||void 0===e?void 0:e.delimiters;if(t.prefix=t.prefix||this.state.tag?this.state.tag.prefix:(a.pattern.source||a.pattern)[0],n=this.prepareNewTagNode(t),i=n.tagElm,this.replaceTextWithNode(i)||this.DOM.input.appendChild(i),setTimeout((function(){return i.classList.add(s.settings.classNames.tagNoAnimation)}),300),this.update(),!o){var r=this.insertAfterTag(i)||i;setTimeout(T,0,r);}return this.state.tag=null,this.postProcessNewTagNode(i,n.tagData),i},appendTag:function(t){var e=this.DOM,i=e.input;e.scope.insertBefore(t,i);},createTagElem:function(t,e){t.__tagId=f();var i,n=u({},t,G({value:d(t.value+"")},e));return function(t){for(var e,i=document.createNodeIterator(t,NodeFilter.SHOW_TEXT,null,false);e=i.nextNode();)e.textContent.trim()||e.parentNode.removeChild(e);}(i=this.parseTemplate("tag",[n,this])),y(i,t),i},reCheckInvalidTags:function(){var t=this,e=this.settings;this.getTagElms(e.classNames.tagNotAllowed).forEach((function(i,n){var s=y(i),a=t.hasMaxTags(),o=t.validateTag(s),r=true===o&&!a;if("select"==e.mode&&t.toggleScopeValidation(o),r)return s=s.__preInvalidData?s.__preInvalidData:{value:s.value},t.replaceTag(i,s);i.title=a||o;}));},removeTags:function(t,e,i){var n,s=this,a=this.settings;if(t=t&&J(t,HTMLElement)?[t]:J(t,Array)?t:t?[t]:[this.getLastTag()].filter((function(t){return t})),n=t.reduce((function(t,e){e&&"string"==typeof e&&(e=s.getTagElmByValue(e));var i=y(e);return e&&i&&!i.readonly&&t.push({node:e,idx:s.getTagIdx(i),data:y(e,{__removed:true})}),t}),[]),i="number"==typeof i?i:this.CSSVars.tagHideTransition,"select"==a.mode&&(i=0,this.input.set.call(this)),1==n.length&&"select"!=a.mode&&n[0].node.classList.contains(a.classNames.tagNotAllowed)&&(e=true),n.length)return a.hooks.beforeRemoveTag(n,{tagify:this}).then((function(){var t=function(t){t.node.parentNode&&(t.node.parentNode.removeChild(t.node),e?a.keepInvalidTags&&this.trigger("remove",{tag:t.node,index:t.idx}):(this.trigger("remove",{tag:t.node,index:t.idx,data:t.data}),this.dropdown.refilter(),this.dropdown.position(),this.DOM.input.normalize(),a.keepInvalidTags&&this.reCheckInvalidTags()));};i&&i>10&&1==n.length?function(e){e.node.style.width=parseFloat(window.getComputedStyle(e.node).width)+"px",document.body.clientTop,e.node.classList.add(a.classNames.tagHide),setTimeout(t.bind(this),i,e);}.call(s,n[0]):n.forEach(t.bind(s)),e||(s.removeTagsFromValue(n.map((function(t){return t.node}))),s.update(),"select"==a.mode&&a.userInput&&s.setContentEditable(true));})).catch((function(t){}))},removeTagsFromDOM:function(){this.getTagElms().forEach((function(t){return t.remove()}));},removeTagsFromValue:function(t){var e=this;(t=Array.isArray(t)?t:[t]).forEach((function(t){var i=y(t),n=e.getTagIdx(i);n>-1&&e.value.splice(n,1);}));},removeAllTags:function(t){var e=this;t=t||{},this.value=[],"mix"==this.settings.mode?this.DOM.input.innerHTML="":this.removeTagsFromDOM(),this.dropdown.refilter(),this.dropdown.position(),this.state.dropdown.visible&&setTimeout((function(){e.DOM.input.focus();})),"select"==this.settings.mode&&(this.input.set.call(this),this.settings.userInput&&this.setContentEditable(true)),this.update(t);},postUpdate:function(){this.state.blockChangeEvent=false;var t,e,i=this.settings,n=i.classNames,s="mix"==i.mode?i.mixMode.integrated?this.DOM.input.textContent:this.DOM.originalInput.value.trim():this.value.length+this.input.raw.call(this).length;(this.toggleClass(n.hasMaxTags,this.value.length>=i.maxTags),this.toggleClass(n.hasNoTags,!this.value.length),this.toggleClass(n.empty,!s),"select"==i.mode)&&this.toggleScopeValidation(null===(e=this.value)||void 0===e||null===(t=e[0])||void 0===t?void 0:t.__isValid);},setOriginalInputValue:function(t){var e=this.DOM.originalInput;this.settings.mixMode.integrated||(e.value=t,e.tagifyValue=e.value,this.setPersistedData(t,"value"));},update:function(t){clearTimeout(this.debouncedUpdateTimeout),this.debouncedUpdateTimeout=setTimeout(function(){var e=this.getInputValue();this.setOriginalInputValue(e),this.settings.onChangeAfterBlur&&(t||{}).withoutChangeEvent||this.state.blockChangeEvent||this.triggerChangeEvent();this.postUpdate();}.bind(this),100),this.events.bindOriginaInputListener.call(this,100);},getInputValue:function(){var t=this.getCleanValue();return "mix"==this.settings.mode?this.getMixedTagsAsString(t):t.length?this.settings.originalInputValueFormat?this.settings.originalInputValueFormat(t):JSON.stringify(t):""},getCleanValue:function(t){return a(t||this.value,this.dataProps)},getMixedTagsAsString:function(){var t="",e=this,i=this.settings,n=i.originalInputValueFormat||JSON.stringify,s=i.mixTagsInterpolator;return function i(a){a.childNodes.forEach((function(a){if(1==a.nodeType){var r=y(a);if("BR"==a.tagName&&(t+="\r\n"),r&&m.call(e,a)){if(r.__removed)return;t+=s[0]+n(o(r,e.dataProps))+s[1];}else a.getAttribute("style")||["B","I","U"].includes(a.tagName)?t+=a.textContent:"DIV"!=a.tagName&&"P"!=a.tagName||(t+="\r\n",i(a));}else t+=a.textContent;}));}(this.DOM.input),t}},Q.prototype.removeTag=Q.prototype.removeTags;

function rollCommandToJSON(text, raw) {
    if (!text) return {};

    const flavorMatch = raw?.match(/{(.*)}$/);
    const flavor = flavorMatch ? flavorMatch[1] : null;

    // Match key="quoted string"  OR  key=unquotedValue
    const PAIR_RE = /(\w+)=("(?:[^"\\]|\\.)*"|\S+)/g;
    const result = {};
    for (const [, key, raw] of text.matchAll(PAIR_RE)) {
        let value;
        if (raw.startsWith('"') && raw.endsWith('"')) {
            // Strip the surrounding quotes, un-escape any \" sequences
            value = raw.slice(1, -1).replace(/\\"/g, '"');
        } else if (/^(true|false)$/i.test(raw)) {
            // Boolean
            value = raw.toLowerCase() === 'true';
        } else if (!Number.isNaN(Number(raw))) {
            // Numeric
            value = Number(raw);
        } else {
            // Fallback to string
            value = raw;
        }
        result[key] = value;
    }
    return Object.keys(result).length > 0 ? { result, flavor } : null;
}

const getCommandTarget = (options = {}) => {
    const { allowNull = false } = options;
    let target = game.canvas.tokens.controlled.length > 0 ? game.canvas.tokens.controlled[0].actor : null;
    if (!game.user.isGM) {
        target = game.user.character;
        if (!target && !allowNull) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noAssignedPlayerCharacter'));
            return null;
        }
    }
    if (!target && !allowNull) {
        ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noSelectedToken'));
        return null;
    }
    if (target && target.type !== 'character') {
        if (!allowNull) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.onlyUseableByPC'));
        }
        return null;
    }

    return target;
};

const setDiceSoNiceForDualityRoll = async (rollResult, advantageState, hopeFaces, fearFaces, advantageFaces) => {
    if (!game.modules.get('dice-so-nice')?.active) return;
    const diceSoNicePresets = await getDiceSoNicePresets(hopeFaces, fearFaces, advantageFaces, advantageFaces);
    rollResult.dice[0].options = diceSoNicePresets.hope;
    rollResult.dice[1].options = diceSoNicePresets.fear;
    if (rollResult.dice[2] && advantageState) {
        rollResult.dice[2].options =
            advantageState === 1 ? diceSoNicePresets.advantage : diceSoNicePresets.disadvantage;
    }
};

const chunkify = (array, chunkSize, mappingFunc) => {
    var chunkifiedArray = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        const chunk = array.slice(i, i + chunkSize);
        if (mappingFunc) {
            chunkifiedArray.push(mappingFunc(chunk));
        } else {
            chunkifiedArray.push(chunk);
        }
    }

    return chunkifiedArray;
};

const tagifyElement = (element, baseOptions, onChange, tagifyOptions = {}) => {
    const { maxTags } = tagifyOptions;
    const options = Array.isArray(baseOptions)
        ? baseOptions
        : Object.keys(baseOptions).map(optionKey => ({
              ...baseOptions[optionKey],
              id: optionKey
          }));

    const tagifyElement = new Q(element, {
        tagTextProp: 'name',
        enforceWhitelist: true,
        whitelist: options.map(option => {
            return {
                value: option.id,
                name: game.i18n.localize(option.label),
                src: option.src,
                description: option.description
            };
        }),
        maxTags: typeof maxTags === 'function' ? maxTags() : maxTags,
        dropdown: {
            mapValueTo: 'name',
            searchKeys: ['value'],
            enabled: 0,
            maxItems: 100,
            closeOnSelect: true,
            highlightFirst: false
        },
        templates: {
            tag(tagData) {
                return `<tag
                            contenteditable='false'
                            spellcheck='false'
                            tabIndex="${this.settings.a11y.focusableTags ? 0 : -1}"
                            class="${this.settings.classNames.tag} ${tagData.class ? tagData.class : ''}"
                            data-tooltip="${tagData.description || tagData.name}"
                            ${this.getAttributes(tagData)}> 
                    <x class="${this.settings.classNames.tagX}" role='button' aria-label='remove tag'></x>
                    <div>
                        <span class="${this.settings.classNames.tagText}">${tagData[this.settings.tagTextProp] || tagData.value}</span>
                        ${tagData.src ? `<img src="${tagData.src}"></i>` : ''}
                    </div>
                </tag>`;
            }
        }
    });

    tagifyElement.on('add', event => {
        if (event.detail.data.__isValid === 'not allowed') return;

        const input = event.detail.tagify.DOM.originalInput;
        const currentList = input.value ? JSON.parse(input.value) : [];
        onChange([...currentList, event.detail.data], { option: event.detail.data.value, removed: false }, input);
    });
    tagifyElement.on('remove', event => {
        const input = event.detail.tagify.DOM.originalInput;
        const currentList = input.value ? JSON.parse(input.value) : [];
        onChange(
            currentList.filter(x => x.value !== event.detail.data.value),
            { option: event.detail.data.value, removed: true },
            event.detail.tagify.DOM.originalInput
        );
    });
};

const getDeleteKeys = (property, innerProperty, innerPropertyDefaultValue) => {
    return Object.keys(property).reduce((acc, key) => {
        if (innerProperty) {
            if (innerPropertyDefaultValue !== undefined) {
                acc[`${key}`] = {
                    [innerProperty]: innerPropertyDefaultValue
                };
            } else {
                acc[`${key}.-=${innerProperty}`] = null;
            }
        } else {
            acc[`-=${key}`] = null;
        }

        return acc;
    }, {});
};

// Fix on Foundry native formula replacement for DH
const nativeReplaceFormulaData = Roll.replaceFormulaData;
Roll.replaceFormulaData = function (formula, data = {}, { missing, warn = false } = {}) {
    const terms = Object.keys(CONFIG.DH.GENERAL.multiplierTypes).map(type => {
        return { term: type, default: 1 };
    });
    formula = terms.reduce((a, c) => a.replaceAll(`@${c.term}`, data[c.term] ?? c.default), formula);
    return nativeReplaceFormulaData(formula, data, { missing, warn });
};

foundry.utils.setProperty(foundry, 'dice.terms.Die.MODIFIERS.sc', 'selfCorrecting');

/**
 * Return the configured value as result if 1 is rolled
 * Example: 6d6sc6  Roll 6d6, each result of 1 will be changed into 6
 * @param {string} modifier     The matched modifier query
 */
foundry.dice.terms.Die.prototype.selfCorrecting = function (modifier) {
    const rgx = /(?:sc)([0-9]+)/i;
    const match = modifier.match(rgx);
    if (!match) return false;
    let [target] = match.slice(1);
    target = parseInt(target);
    for (const r of this.results) {
        if (r.result === 1) {
            r.result = target;
        }
    }
};

const getDamageKey = damage => {
    return ['none', 'minor', 'major', 'severe', 'any'][damage];
};

const getDamageLabel = damage => {
    return game.i18n.localize(`DAGGERHEART.GENERAL.Damage.${getDamageKey(damage)}`);
};

const damageKeyToNumber = key => {
    return {
        none: 0,
        minor: 1,
        major: 2,
        severe: 3,
        any: 4
    }[key];
};

const adjustDice = (dice, decrease) => {
    const diceKeys = Object.keys(diceTypes);
    const index = diceKeys.indexOf(dice);
    const newIndex = Math.min(index + 1, diceKeys.length - 1);
    return diceTypes[diceKeys[newIndex]];
};

const adjustRange = (rangeVal, decrease) => {
    const rangeKeys = Object.keys(range);
    const index = rangeKeys.indexOf(rangeVal);
    const newIndex = Math.min(index + 1, rangeKeys.length - 1);
    return range[rangeKeys[newIndex]];
};

/**
 *
 * @param {DhActor} actor - The actor for which all tokens will run a data update.
 * @param {string} update - The data update to be applied to all tokens.
 * @param {func} updateToken - Optional, specific data update for the non-prototype tokens as a function using the token data. Useful to handle wildcard images where each token has a different image but the prototype has a wildcard path.
 */
const updateActorTokens = async (actor, update, updateToken) => {
    await actor.prototypeToken.update({ ...update });

    /* Update the tokens in all scenes belonging to Actor */
    for (let token of actor.getDependentTokens()) {
        const tokenActor = token.baseActor ?? token.actor;
        if (token.id && tokenActor?.id === actor.id) {
            await token.update({
                ...(updateToken ? updateToken(token) : update),
                _id: token.id
            });
        }
    }
};

/**
 * Retrieves a Foundry document associated with the nearest ancestor element
 * that has a `data-item-uuid` attribute.
 * @param {HTMLElement} element - The DOM element to start the search from.
 * @returns {Promise<foundry.abstract.Document|null>} The resolved document, or null if not found or invalid.
 */
async function getDocFromElement(element) {
    const target = element.closest('[data-item-uuid]');
    return (await foundry.utils.fromUuid(target.dataset.itemUuid)) ?? null;
}

/**
 * Retrieves a Foundry document associated with the nearest ancestor element
 * that has a `data-item-uuid` attribute.
 * @param {HTMLElement} element - The DOM element to start the search from.
 * @returns {foundry.abstract.Document|null} The resolved document, or null if not found, invalid
 * or in embedded compendium collection.
 */
function getDocFromElementSync(element) {
    const target = element.closest('[data-item-uuid]');
    try {
        return foundry.utils.fromUuidSync(target.dataset.itemUuid) ?? null;
    } catch (_) {
        return null;
    }
}

/**
 * Adds the update diff on a linkedItem property to update.options for use
 * in _onUpdate via the updateLinkedItemApps function.
 * @param {Array} changedItems            The candidate changed list
 * @param {Array} currentItems            The current list
 * @param {object} options                Additional options which modify the update request
 */
function addLinkedItemsDiff(changedItems, currentItems, options) {
    if (changedItems) {
        const prevItems = new Set(currentItems);
        const newItems = new Set(changedItems);
        options.toLink = Array.from(
            newItems
                .difference(prevItems)
                .map(item => item?.item ?? item)
                .filter(x => (typeof x === 'object' ? x?.item : x))
        );

        options.toUnlink = Array.from(
            prevItems
                .difference(newItems)
                .map(item => item?.item?.uuid ?? item?.uuid ?? item)
                .filter(x => (typeof x === 'object' ? x?.item : x))
        );
    }
}

/**
 * Adds or removes the current Application from linked document apps
 * depending on an update diff in the linked item list.
 * @param {object} options                Additional options which modify the update requests
 * @param {object} sheet                  The application to add or remove from document apps
 */
function updateLinkedItemApps(options, sheet) {
    options.toLink?.forEach(featureUuid => {
        const doc = foundry.utils.fromUuidSync(featureUuid);
        doc.apps[sheet.id] = sheet;
    });
    options.toUnlink?.forEach(featureUuid => {
        const doc = foundry.utils.fromUuidSync(featureUuid);
        delete doc.apps[sheet.id];
    });
}

const itemAbleRollParse = (value, actor, item) => {
    if (!value) return value;

    const isItemTarget = value.toLowerCase().includes('item.@');
    const slicedValue = isItemTarget ? value.replaceAll(/item\.@/gi, '@') : value;
    const model = isItemTarget ? item : actor;

    try {
        return Roll.replaceFormulaData(slicedValue, isItemTarget || !model?.getRollData ? model : model.getRollData());
    } catch (_) {
        return '';
    }
};

const setsEqual = (a, b) => a.size === b.size && [...a].every(value => b.has(value));

function getScrollTextData(resources, resource, key) {
    const { reversed, label } = CONFIG.DH.ACTOR.scrollingTextResource[key];
    const { BOTTOM, TOP } = CONST.TEXT_ANCHOR_POINTS;
    const increased = resources[key].value < resource.value;
    const value = -1 * (resources[key].value - resource.value);

    const text = `${game.i18n.localize(label)} ${value.signedString()}`;

    const stroke = increased ? (reversed ? 0xffffff : 0x000000) : reversed ? 0x000000 : 0xffffff;
    const fill = increased ? (reversed ? 0x0032b1 : 0xffe760) : reversed ? 0xffe760 : 0x0032b1;
    const direction = increased ? (reversed ? BOTTOM : TOP) : reversed ? TOP : BOTTOM;

    return { text, stroke, fill, direction };
}

function createScrollText(actor, data) {
    if (actor) {
        actor.getActiveTokens().forEach(token => {
            const { text, ...options } = data;
            canvas.interface.createScrollingText(token.getCenterPoint(), data.text, {
                duration: 2000,
                distance: token.h,
                jitter: 0,
                ...options
            });
        });
    }
}

async function createEmbeddedItemWithEffects(actor, baseData, update) {
    const data = baseData.uuid.startsWith('Compendium') ? await foundry.utils.fromUuid(baseData.uuid) : baseData;
    const [doc] = await actor.createEmbeddedDocuments('Item', [
        {
            ...(update ?? data),
            ...baseData,
            id: data.id,
            uuid: data.uuid,
            effects: data.effects?.map(effect => effect.toObject())
        }
    ]);

    return doc;
}

async function createEmbeddedItemsWithEffects(actor, baseData) {
    const effectData = [];
    for (let d of baseData) {
        const data = d.uuid.startsWith('Compendium') ? await foundry.utils.fromUuid(d.uuid) : d;
        effectData.push({
            ...data,
            id: data.id,
            uuid: data.uuid,
            effects: data.effects?.map(effect => effect.toObject())
        });
    }

    await actor.createEmbeddedDocuments('Item', effectData);
}

const slugify = name => {
    return name.toLowerCase().replaceAll(' ', '-').replaceAll('.', '');
};

function shuffleArray(array) {
    let currentIndex = array.length;
    while (currentIndex != 0) {
        let randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;

        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }

    return array;
}

function itemIsIdentical(a, b) {
    const compendiumSource = a._stats.compendiumSource === b._stats.compendiumSource;
    const name = a.name === b.name;
    const description = a.system.description === b.system.description;

    return compendiumSource && name & description;
}

async function waitForDiceSoNice(message) {
    if (message && game.modules.get('dice-so-nice')?.active) {
        await game.dice3d.waitFor3DAnimationByMessageID(message.id);
    }
}

function refreshIsAllowed(allowedTypes, typeToCheck) {
    switch (typeToCheck) {
        case CONFIG.DH.GENERAL.refreshTypes.scene.id:
        case CONFIG.DH.GENERAL.refreshTypes.session.id:
        case CONFIG.DH.GENERAL.refreshTypes.longRest.id:
            return allowedTypes.includes(typeToCheck);
        case CONFIG.DH.GENERAL.refreshTypes.shortRest.id:
            return allowedTypes.some(
                x =>
                    x === CONFIG.DH.GENERAL.refreshTypes.shortRest.id ||
                    x === CONFIG.DH.GENERAL.refreshTypes.longRest.id
            );
        default:
            return false;
    }
}

async function getCritDamageBonus(formula) {
    const critRoll = new Roll(formula);
    return critRoll.dice.reduce((acc, dice) => acc + dice.faces, 0);
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$w, ApplicationV2: ApplicationV2$u } = foundry.applications.api;

class DhCharacterCreation extends HandlebarsApplicationMixin$w(ApplicationV2$u) {
    constructor(character) {
        super({});

        this.character = character;

        this.setup = {
            traits: this.character.system.traits,
            ancestryName: {
                primary: '',
                secondary: ''
            },
            mixedAncestry: false,
            primaryAncestry: this.character.system.ancestry ?? {},
            secondaryAncestry: {},
            community: this.character.system.community ?? {},
            class: this.character.system.class?.value ?? {},
            subclass: this.character.system.class?.subclass ?? {},
            experiences: {
                [foundry.utils.randomID()]: { name: '', value: 2, core: true },
                [foundry.utils.randomID()]: { name: '', value: 2, core: true }
            },
            domainCards: {
                [foundry.utils.randomID()]: {},
                [foundry.utils.randomID()]: {}
            },
            visibility: 1
        };

        this.equipment = {
            armor: {},
            primaryWeapon: {},
            secondaryWeapon: {},
            inventory: {
                take: {},
                choiceA: {},
                choiceB: {}
            }
        };

        this._dragDrop = this._createDragDropHandlers();
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.CharacterCreation.title', { actor: this.character.name });
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dialog', 'dh-style', 'character-creation'],
        position: { width: 700, height: 'auto' },
        actions: {
            viewCompendium: this.viewCompendium,
            viewItem: this.viewItem,
            useSuggestedTraits: this.useSuggestedTraits,
            equipmentChoice: this.equipmentChoice,
            setupGoNext: this.setupGoNext,
            finish: this.finish
        },
        form: {
            handler: this.updateForm,
            submitOnChange: true,
            closeOnSubmit: false
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.ancestry-card' },
            { dragSelector: null, dropSelector: '.community-card' },
            { dragSelector: null, dropSelector: '.class-card' },
            { dragSelector: null, dropSelector: '.subclass-card' },
            { dragSelector: null, dropSelector: '.domain-card' },
            { dragSelector: null, dropSelector: '.armor-card' },
            { dragSelector: null, dropSelector: '.primary-weapon-card' },
            { dragSelector: null, dropSelector: '.secondary-weapon-card' },
            { dragSelector: '.suggestion-inner-container', dropSelector: '.selections-container' }
        ]
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/characterCreation/tabs.hbs' },
        class: { template: 'systems/daggerheart/templates/characterCreation/tabs/class.hbs' },
        ancestry: { template: 'systems/daggerheart/templates/characterCreation/tabs/ancestry.hbs' },
        community: { template: 'systems/daggerheart/templates/characterCreation/tabs/community.hbs' },
        traits: { template: 'systems/daggerheart/templates/characterCreation/tabs/traits.hbs' },
        experience: { template: 'systems/daggerheart/templates/characterCreation/tabs/experience.hbs' },
        domainCards: { template: 'systems/daggerheart/templates/characterCreation/tabs/domainCards.hbs' },
        equipment: { template: 'systems/daggerheart/templates/characterCreation/equipment.hbs' },
        // story: { template: 'systems/daggerheart/templates/characterCreation/story.hbs' },
        footer: { template: 'systems/daggerheart/templates/characterCreation/footer.hbs' }
    };

    static TABS = {
        class: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'class',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.class'
        },
        ancestry: {
            active: true,
            cssClass: '',
            group: 'setup',
            id: 'ancestry',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.ancestry'
        },
        community: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'community',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.community'
        },
        traits: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'traits',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.traits'
        },
        experience: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'experience',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.experience'
        },
        domainCards: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'domainCards',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.domainCards'
        },
        equipment: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'equipment',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.equipment'
        }
    };

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group]
                ? this.tabGroups[v.group] === v.id
                : this.tabGroups.primary !== 'equipment'
                  ? v.active
                  : false;
            v.cssClass = v.active ? 'active' : '';

            switch (v.id) {
                case 'ancestry':
                    v.disabled = this.setup.visibility < 2;
                    break;
                case 'community':
                    v.disabled = this.setup.visibility < 3;
                    break;
                case 'traits':
                    v.disabled = this.setup.visibility < 4;
                    break;
                case 'experience':
                    v.disabled = this.setup.visibility < 5;
                    break;
                case 'domainCards':
                    v.disabled = this.setup.visibility < 6;
                    break;
                case 'equipment':
                    v.disabled = this.setup.visibility < 7;
                    break;
            }
        }

        return tabs;
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        this._dragDrop.forEach(d => d.bind(htmlElement));

        htmlElement.querySelectorAll('.mixed-ancestry-slider').forEach(element => {
            element.addEventListener('input', this.mixedAncestryToggle.bind(this));
            element.addEventListener('click', this.mixedAncestryToggle.bind(this));
        });
    }

    async _prepareContext(_options) {
        this.tabGroups.setup = this.tabGroups.setup ?? 'class';
        const context = await super._prepareContext(_options);

        context.tabs = this._getTabs(this.constructor.TABS);
        const availableTraitModifiers = game.settings
            .get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew)
            .traitArray.map(trait => ({ key: trait, name: trait }));
        for (let trait of Object.values(this.setup.traits).filter(x => x.value !== null)) {
            const index = availableTraitModifiers.findIndex(x => x.key === trait.value);
            if (index !== -1) {
                availableTraitModifiers.splice(index, 1);
            }
        }

        context.suggestedTraits = this.setup.class.system
            ? Object.keys(this.setup.class.system.characterGuide.suggestedTraits).map(traitKey => {
                  const trait = this.setup.class.system.characterGuide.suggestedTraits[traitKey];
                  return `${game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${traitKey}.short`)} ${trait > 0 ? `+${trait}` : trait}`;
              })
            : [];
        context.traits = {
            values: Object.keys(this.setup.traits).map(traitKey => {
                const trait = this.setup.traits[traitKey];
                const options = [...availableTraitModifiers];
                if (trait.value !== null && !options.some(x => x.key === trait.value))
                    options.push({ key: trait.value, name: trait.value });

                return {
                    ...trait,
                    key: traitKey,
                    name: game.i18n.localize(abilities[traitKey].label),
                    options: options
                };
            })
        };
        context.traits.nrTotal = Object.keys(context.traits.values).length;
        context.traits.nrSelected = this.getNrSelectedTrait();

        context.experience = {
            values: this.setup.experiences,
            nrTotal: Object.keys(this.setup.experiences).length,
            nrSelected: Object.values(this.setup.experiences).reduce((acc, exp) => acc + (exp.name ? 1 : 0), 0)
        };

        context.mixedAncestry = Number(this.setup.mixedAncestry);

        const { primary, secondary, overwrite } = this.setup.ancestryName;
        context.ancestryName = overwrite ?? (primary && secondary ? `${primary}/${secondary}` : primary);
        context.primaryAncestry = { ...this.setup.primaryAncestry, compendium: 'ancestries' };
        context.secondaryAncestry = { ...this.setup.secondaryAncestry, compendium: 'ancestries' };
        context.community = { ...this.setup.community, compendium: 'communities' };
        context.class = { ...this.setup.class, compendium: 'classes' };
        context.subclass = { ...this.setup.subclass, compendium: 'subclasses' };

        const allDomainData = CONFIG.DH.DOMAIN.allDomains();
        context.classDomains = context.class.uuid
            ? context.class.system.domains.map(key => game.i18n.localize(allDomainData[key].label))
            : [];
        context.domainCards = Object.keys(this.setup.domainCards).reduce((acc, x) => {
            acc[x] = { ...this.setup.domainCards[x], compendium: 'domains' };
            return acc;
        }, {});

        context.visibility = this.setup.visibility;

        return context;
    }

    async _preparePartContext(partId, context) {
        switch (partId) {
            case 'footer':
                context.isLastTab = this.tabGroups.setup === 'equipment';
                switch (this.tabGroups.setup) {
                    case null:
                    case 'class':
                        context.nextDisabled = this.setup.visibility === 1;
                        break;
                    case 'ancestry':
                        context.nextDisabled = this.setup.visibility === 2;
                        break;
                    case 'community':
                        context.nextDisabled = this.setup.visibility === 3;
                        break;
                    case 'traits':
                        context.nextDisabled = this.setup.visibility === 4;
                        break;
                    case 'experience':
                        context.nextDisabled = this.setup.visibility === 5;
                        break;
                    case 'domainCards':
                        context.nextDisabled = this.setup.visibility === 6;
                        break;
                }

                break;
            case 'equipment':
                const suggestions = await this.getEquipmentSuggestions(
                    this.equipment.inventory.choiceA,
                    this.equipment.inventory.choiceB
                );
                context.armor = {
                    ...this.equipment.armor,
                    suggestion: {
                        ...suggestions.armor,
                        uuid: suggestions.armor?.uuid,
                        taken: suggestions.armor?.uuid === this.equipment.armor?.uuid
                    },
                    compendium: 'armor'
                };
                context.primaryWeapon = {
                    ...this.equipment.primaryWeapon,
                    suggestion: {
                        ...suggestions.primaryWeapon,
                        uuid: suggestions.primaryWeapon?.uuid,
                        taken: suggestions.primaryWeapon?.uuid === this.equipment.primaryWeapon?.uuid
                    },
                    compendium: 'weapon'
                };
                context.secondaryWeapon = {
                    ...this.equipment.secondaryWeapon,
                    suggestion: {
                        ...suggestions.secondaryWeapon,
                        uuid: suggestions.secondaryWeapon?.uuid,
                        taken: suggestions.secondaryWeapon?.uuid === this.equipment.secondaryWeapon?.uuid
                    },
                    disabled: this.equipment.primaryWeapon?.system?.burden === burden.twoHanded.value,
                    compendium: 'weapon'
                };
                context.inventory = {
                    take: suggestions.inventory.take,
                    choiceA: { suggestions: suggestions.inventory.choiceA, compendium: 'consumables' },
                    choiceB: { suggestions: suggestions.inventory.choiceB, compendium: 'general-items' }
                };
                context.noInventoryChoices =
                    suggestions.inventory.take.length === 0 &&
                    suggestions.inventory.choiceA?.length === 0 &&
                    suggestions.inventory.choiceB?.length === 0;

                break;
        }

        return context;
    }

    static async updateForm(event, _, formData) {
        this.setup = foundry.utils.mergeObject(this.setup, formData.object);

        this.setup.visibility = this.getUpdateVisibility();
        this.render();
    }

    mixedAncestryToggle(event) {
        event.preventDefault();
        event.stopPropagation();
        this.setup.mixedAncestry = !this.setup.mixedAncestry;
        if (!this.setup.mixedAncestry) this.setup.secondaryAncestry = {};

        this.render();
    }

    getUpdateVisibility() {
        switch (this.setup.visibility) {
            case 7:
                return 7;
            case 6:
                return Object.values(this.setup.domainCards).every(x => x.uuid) ? 7 : 6;
            case 5:
                return Object.values(this.setup.experiences).every(x => x.name) ? 6 : 5;
            case 4:
                return this.getNrSelectedTrait() === 6 ? 5 : 4;
            case 3:
                return this.setup.community.uuid ? 4 : 3;
            case 2:
                return this.setup.primaryAncestry.uuid ? 3 : 2;
            case 1:
                return this.setup.class.uuid && this.setup.subclass.uuid ? 2 : 1;
        }
    }

    getNrSelectedTrait() {
        const traitCompareArray = [
            ...game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).traitArray
        ];
        return Object.values(this.setup.traits).reduce((acc, x) => {
            const index = traitCompareArray.indexOf(x.value);
            traitCompareArray.splice(index, 1);
            acc += index !== -1;
            return acc;
        }, 0);
    }

    async getEquipmentSuggestions(choiceA, choiceB) {
        if (!this.setup.class.uuid) return { inventory: { take: [] } };

        const { inventory, characterGuide } = this.setup.class.system;
        return {
            armor: characterGuide.suggestedArmor ?? null,
            primaryWeapon: characterGuide.suggestedPrimaryWeapon ?? null,
            secondaryWeapon: characterGuide.suggestedSecondaryWeapon
                ? { ...characterGuide.suggestedSecondaryWeapon, uuid: characterGuide.suggestedSecondaryWeapon.uuid }
                : null,
            inventory: {
                take: inventory.take?.filter(x => x) ?? [],
                choiceA:
                    inventory.choiceA
                        ?.filter(x => x)
                        .map(x => ({ ...x, uuid: x.uuid, selected: x.uuid === choiceA?.uuid })) ?? [],
                choiceB:
                    inventory.choiceB
                        ?.filter(x => x)
                        .map(x => ({ ...x, uuid: x.uuid, selected: x.uuid === choiceB?.uuid })) ?? []
            }
        };
    }

    _createDragDropHandlers() {
        return this.options.dragDrop.map(d => {
            d.callbacks = {
                dragstart: this._onDragStart.bind(this),
                drop: this._onDrop.bind(this)
            };
            return new foundry.applications.ux.DragDrop.implementation(d);
        });
    }

    static async viewCompendium(event, target) {
        const type = target.dataset.compendium ?? target.dataset.type,
            equipment = ['armor', 'weapon'];

        const presets = {
            folder: equipment.includes(type) ? `equipments.folders.${type}s` : type,
            render: {
                noFolder: true
            }
        };

        if (type === 'domains')
            presets.filter = {
                'level.max': { key: 'level.max', value: 1 },
                'system.domain': { key: 'system.domain', value: this.setup.class?.system.domains ?? null }
            };

        if (type === 'subclasses')
            presets.filter = {
                'system.linkedClass.uuid': { key: 'system.linkedClass.uuid', value: this.setup.class?.uuid }
            };

        if (equipment.includes(type))
            presets.filter = {
                'system.tier': { key: 'system.tier', value: 1 },
                'type': { key: 'type', value: type }
            };

        ui.compendiumBrowser.open(presets);
    }

    static async viewItem(_, target) {
        (await foundry.utils.fromUuid(target.dataset.uuid)).sheet.render(true);
    }

    static useSuggestedTraits() {
        this.setup.traits = Object.keys(this.setup.traits).reduce((acc, traitKey) => {
            acc[traitKey] = {
                ...this.setup.traits[traitKey],
                value: this.setup.class.system.characterGuide.suggestedTraits[traitKey]
            };
            return acc;
        }, {});

        this.setup.visibility = this.getUpdateVisibility();
        this.render();
    }

    static async equipmentChoice(_, target) {
        this.equipment.inventory[target.dataset.path] = await foundry.utils.fromUuid(target.dataset.uuid);
        this.render();
    }

    static setupGoNext() {
        switch (this.setup.visibility) {
            case 2:
                this.tabGroups.setup = 'ancestry';
                break;
            case 3:
                this.tabGroups.setup = 'community';
                break;
            case 4:
                this.tabGroups.setup = 'traits';
                break;
            case 5:
                this.tabGroups.setup = 'experience';
                break;
            case 6:
                this.tabGroups.setup = 'domainCards';
                break;
            case 7:
                this.tabGroups.setup = 'equipment';
                break;
        }

        this.render();
    }

    static async finish(_, button) {
        button.disabled = true;

        const primaryAncestryFeature = this.setup.primaryAncestry.system.primaryFeature;
        const secondaryAncestryFeature = this.setup.secondaryAncestry?.uuid
            ? this.setup.secondaryAncestry.system.secondaryFeature
            : this.setup.primaryAncestry.system.secondaryFeature;

        const { primary, secondary, overwrite } = this.setup.ancestryName;
        const ancestry = {
            ...this.setup.primaryAncestry,
            name: overwrite ?? (primary && secondary ? `${primary}/${secondary}` : primary),
            system: {
                ...this.setup.primaryAncestry.system,
                features: [
                    { type: 'primary', item: primaryAncestryFeature.uuid },
                    { type: 'secondary', item: secondaryAncestryFeature.uuid }
                ]
            }
        };

        await createEmbeddedItemWithEffects(this.character, ancestry);
        await createEmbeddedItemWithEffects(this.character, this.setup.community);
        await createEmbeddedItemWithEffects(this.character, this.setup.class);
        await createEmbeddedItemWithEffects(this.character, this.setup.subclass);
        await createEmbeddedItemsWithEffects(this.character, Object.values(this.setup.domainCards));

        if (this.equipment.armor.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.armor, {
                ...this.equipment.armor,
                system: { ...this.equipment.armor.system, equipped: true }
            });
        if (this.equipment.primaryWeapon.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.primaryWeapon, {
                ...this.equipment.primaryWeapon,
                system: { ...this.equipment.primaryWeapon.system, equipped: true }
            });
        if (this.equipment.secondaryWeapon.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.secondaryWeapon, {
                ...this.equipment.secondaryWeapon,
                system: { ...this.equipment.secondaryWeapon.system, equipped: true }
            });
        if (this.equipment.inventory.choiceA.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.inventory.choiceA);
        if (this.equipment.inventory.choiceB.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.inventory.choiceB);

        await createEmbeddedItemsWithEffects(
            this.character,
            this.setup.class.system.inventory.take.filter(x => x)
        );

        await this.character.update(
            {
                system: {
                    traits: this.setup.traits,
                    experiences: {
                        ...this.setup.experiences,
                        ...Object.keys(this.character.system.experiences).reduce((acc, key) => {
                            acc[`-=${key}`] = null;
                            return acc;
                        }, {})
                    }
                }
            },
            { overwrite: true }
        );

        if (ui.compendiumBrowser) ui.compendiumBrowser.close();
        this.close();
    }

    async _onDragStart(event) {
        const target = event.currentTarget;

        event.dataTransfer.setData('text/plain', JSON.stringify(target.dataset));
        event.dataTransfer.setDragImage(target, 60, 0);
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        const item = await foundry.utils.fromUuid(data.uuid);
        if (item.type === 'ancestry' && event.target.closest('.primary-ancestry-card')) {
            this.setup.ancestryName.primary = item.name;
            this.setup.primaryAncestry = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'ancestry' && event.target.closest('.secondary-ancestry-card')) {
            this.setup.ancestryName.secondary = item.name;
            this.setup.secondaryAncestry = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'community' && event.target.closest('.community-card')) {
            this.setup.community = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'class' && event.target.closest('.class-card')) {
            this.setup.class = { ...item, effects: Array.from(item.effects).map(x => x.toObject()), uuid: item.uuid };
            this.setup.subclass = {};
            this.setup.domainCards = {
                [foundry.utils.randomID()]: {},
                [foundry.utils.randomID()]: {}
            };
        } else if (item.type === 'subclass' && event.target.closest('.subclass-card')) {
            if (this.setup.class.system.subclasses.every(subclass => subclass.uuid !== item.uuid)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.subclassNotInClass'));
                return;
            }

            this.setup.subclass = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'domainCard' && event.target.closest('.domain-card')) {
            if (!this.setup.class.uuid) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.missingClass'));
                return;
            }

            if (!this.setup.class.system.domains.includes(item.system.domain)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.wrongDomain'));
                return;
            }

            if (item.system.level > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.cardTooHighLevel'));
                return;
            }

            if (Object.values(this.setup.domainCards).some(card => card.uuid === item.uuid)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.duplicateCard'));
                return;
            }

            this.setup.domainCards[event.target.closest('.domain-card').dataset.card] = { ...item, uuid: item.uuid };
        } else if (item.type === 'armor' && event.target.closest('.armor-card')) {
            if (item.system.tier > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.itemTooHighTier'));
                return;
            }

            this.equipment.armor = { ...item, uuid: item.uuid };
        } else if (item.type === 'weapon' && event.target.closest('.primary-weapon-card')) {
            if (item.system.secondary) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.notPrimary'));
                return;
            }

            if (item.system.tier > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.itemTooHighTier'));
                return;
            }

            if (item.system.burden === CONFIG.DH.GENERAL.burden.twoHanded.value) {
                this.equipment.secondaryWeapon = {};
            }

            this.equipment.primaryWeapon = { ...item, uuid: item.uuid };
        } else if (item.type === 'weapon' && event.target.closest('.secondary-weapon-card')) {
            if (this.equipment.primaryWeapon?.system?.burden === burden.twoHanded.value) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.primaryIsTwoHanded'));
                return;
            }

            if (!item.system.secondary) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.notSecondary'));
                return;
            }

            if (item.system.tier > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.itemTooHighTier'));
                return;
            }

            this.equipment.secondaryWeapon = { ...item, uuid: item.uuid };
        } else {
            return;
        }

        this.setup.visibility = this.getUpdateVisibility();
        this.render();
    }
}

var _module$i = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CharacterCreation: DhCharacterCreation
});

/**
 * Copyright (c) 2016 Denis Taran
 *
 * Homepage: https://smartscheduling.com/en/documentation/autocomplete
 * Source: https://github.com/denis-taran/autocomplete
 *
 * MIT License
 */
function autocomplete(settings) {
    // just an alias to minimize JS file size
    var doc = document;
    var container = settings.container || doc.createElement('div');
    var preventSubmit = settings.preventSubmit || 0 /* Never */;
    container.id = container.id || 'autocomplete-' + uid();
    var containerStyle = container.style;
    var debounceWaitMs = settings.debounceWaitMs || 0;
    var disableAutoSelect = settings.disableAutoSelect || false;
    var customContainerParent = container.parentElement;
    var items = [];
    var inputValue = '';
    var minLen = 2;
    var showOnFocus = settings.showOnFocus;
    var selected;
    var fetchCounter = 0;
    var debounceTimer;
    var destroyed = false;
    // Fixes #104: autocomplete selection is broken on Firefox for Android
    var suppressAutocomplete = false;
    if (settings.minLength !== undefined) {
        minLen = settings.minLength;
    }
    if (!settings.input) {
        throw new Error('input undefined');
    }
    var input = settings.input;
    container.className = [container.className, 'autocomplete', settings.className || ''].join(' ').trim();
    container.setAttribute('role', 'listbox');
    input.setAttribute('role', 'combobox');
    input.setAttribute('aria-expanded', 'false');
    input.setAttribute('aria-autocomplete', 'list');
    input.setAttribute('aria-controls', container.id);
    input.setAttribute('aria-owns', container.id);
    input.setAttribute('aria-activedescendant', '');
    input.setAttribute('aria-haspopup', 'listbox');
    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning
    containerStyle.position = 'absolute';
    /**
     * Generate a very complex textual ID that greatly reduces the chance of a collision with another ID or text.
     */
    function uid() {
        return Date.now().toString(36) + Math.random().toString(36).substring(2);
    }
    /**
     * Detach the container from DOM
     */
    function detach() {
        var parent = container.parentNode;
        if (parent) {
            parent.removeChild(container);
        }
    }
    /**
     * Clear debouncing timer if assigned
     */
    function clearDebounceTimer() {
        if (debounceTimer) {
            window.clearTimeout(debounceTimer);
        }
    }
    /**
     * Attach the container to DOM
     */
    function attach() {
        if (!container.parentNode) {
            (customContainerParent || doc.body).appendChild(container);
        }
    }
    /**
     * Check if container for autocomplete is displayed
     */
    function containerDisplayed() {
        return !!container.parentNode;
    }
    /**
     * Clear autocomplete state and hide container
     */
    function clear() {
        // prevent the update call if there are pending AJAX requests
        fetchCounter++;
        items = [];
        inputValue = '';
        selected = undefined;
        input.setAttribute('aria-activedescendant', '');
        input.setAttribute('aria-expanded', 'false');
        detach();
    }
    /**
     * Update autocomplete position
     */
    function updatePosition() {
        if (!containerDisplayed()) {
            return;
        }
        input.setAttribute('aria-expanded', 'true');
        containerStyle.height = 'auto';
        containerStyle.width = input.offsetWidth + 'px';
        var maxHeight = 0;
        var inputRect;
        function calc() {
            var docEl = doc.documentElement;
            var clientTop = docEl.clientTop || doc.body.clientTop || 0;
            var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
            var scrollTop = window.pageYOffset || docEl.scrollTop;
            var scrollLeft = window.pageXOffset || docEl.scrollLeft;
            inputRect = input.getBoundingClientRect();
            var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
            var left = inputRect.left + scrollLeft - clientLeft;
            containerStyle.top = top + 'px';
            containerStyle.left = left + 'px';
            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
            if (maxHeight < 0) {
                maxHeight = 0;
            }
            containerStyle.top = top + 'px';
            containerStyle.bottom = '';
            containerStyle.left = left + 'px';
            containerStyle.maxHeight = maxHeight + 'px';
        }
        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)
        calc();
        calc();
        if (settings.customize && inputRect) {
            settings.customize(input, inputRect, container, maxHeight);
        }
    }
    /**
     * Redraw the autocomplete div element with suggestions
     */
    function update() {
        container.textContent = '';
        input.setAttribute('aria-activedescendant', '');
        // function for rendering autocomplete suggestions
        var render = function (item, _, __) {
            var itemElement = doc.createElement('div');
            itemElement.textContent = item.label || '';
            return itemElement;
        };
        if (settings.render) {
            render = settings.render;
        }
        // function to render autocomplete groups
        var renderGroup = function (groupName, _) {
            var groupDiv = doc.createElement('div');
            groupDiv.textContent = groupName;
            return groupDiv;
        };
        if (settings.renderGroup) {
            renderGroup = settings.renderGroup;
        }
        var fragment = doc.createDocumentFragment();
        var prevGroup = uid();
        items.forEach(function (item, index) {
            if (item.group && item.group !== prevGroup) {
                prevGroup = item.group;
                var groupDiv = renderGroup(item.group, inputValue);
                if (groupDiv) {
                    groupDiv.className += ' group';
                    fragment.appendChild(groupDiv);
                }
            }
            var div = render(item, inputValue, index);
            if (div) {
                div.id = container.id + "_" + index;
                div.setAttribute('role', 'option');
                div.addEventListener('click', function (ev) {
                    suppressAutocomplete = true;
                    try {
                        settings.onSelect(item, input);
                    }
                    finally {
                        suppressAutocomplete = false;
                    }
                    clear();
                    ev.preventDefault();
                    ev.stopPropagation();
                });
                if (item === selected) {
                    div.className += ' selected';
                    div.setAttribute('aria-selected', 'true');
                    input.setAttribute('aria-activedescendant', div.id);
                }
                fragment.appendChild(div);
            }
        });
        container.appendChild(fragment);
        if (items.length < 1) {
            if (settings.emptyMsg) {
                var empty = doc.createElement('div');
                empty.id = container.id + "_" + uid();
                empty.className = 'empty';
                empty.textContent = settings.emptyMsg;
                container.appendChild(empty);
                input.setAttribute('aria-activedescendant', empty.id);
            }
            else {
                clear();
                return;
            }
        }
        attach();
        updatePosition();
        updateScroll();
    }
    function updateIfDisplayed() {
        if (containerDisplayed()) {
            update();
        }
    }
    function resizeEventHandler() {
        updateIfDisplayed();
    }
    function scrollEventHandler(e) {
        if (e.target !== container) {
            updateIfDisplayed();
        }
        else {
            e.preventDefault();
        }
    }
    function inputEventHandler() {
        if (!suppressAutocomplete) {
            fetch(0 /* Keyboard */);
        }
    }
    /**
     * Automatically move scroll bar if selected item is not visible
     */
    function updateScroll() {
        var elements = container.getElementsByClassName('selected');
        if (elements.length > 0) {
            var element = elements[0];
            // make group visible
            var previous = element.previousElementSibling;
            if (previous && previous.className.indexOf('group') !== -1 && !previous.previousElementSibling) {
                element = previous;
            }
            if (element.offsetTop < container.scrollTop) {
                container.scrollTop = element.offsetTop;
            }
            else {
                var selectBottom = element.offsetTop + element.offsetHeight;
                var containerBottom = container.scrollTop + container.offsetHeight;
                if (selectBottom > containerBottom) {
                    container.scrollTop += selectBottom - containerBottom;
                }
            }
        }
    }
    function selectPreviousSuggestion() {
        var index = items.indexOf(selected);
        selected = index === -1
            ? undefined
            : items[(index + items.length - 1) % items.length];
        updateSelectedSuggestion(index);
    }
    function selectNextSuggestion() {
        var index = items.indexOf(selected);
        selected = items.length < 1
            ? undefined
            : index === -1
                ? items[0]
                : items[(index + 1) % items.length];
        updateSelectedSuggestion(index);
    }
    function updateSelectedSuggestion(index) {
        if (items.length > 0) {
            unselectSuggestion(index);
            selectSuggestion(items.indexOf(selected));
            updateScroll();
        }
    }
    function selectSuggestion(index) {
        var element = doc.getElementById(container.id + "_" + index);
        if (element) {
            element.classList.add('selected');
            element.setAttribute('aria-selected', 'true');
            input.setAttribute('aria-activedescendant', element.id);
        }
    }
    function unselectSuggestion(index) {
        var element = doc.getElementById(container.id + "_" + index);
        if (element) {
            element.classList.remove('selected');
            element.removeAttribute('aria-selected');
            input.removeAttribute('aria-activedescendant');
        }
    }
    function handleArrowAndEscapeKeys(ev, key) {
        var containerIsDisplayed = containerDisplayed();
        if (key === 'Escape') {
            clear();
        }
        else {
            if (!containerIsDisplayed || items.length < 1) {
                return;
            }
            key === 'ArrowUp'
                ? selectPreviousSuggestion()
                : selectNextSuggestion();
        }
        ev.preventDefault();
        if (containerIsDisplayed) {
            ev.stopPropagation();
        }
    }
    function handleEnterKey(ev) {
        if (selected) {
            if (preventSubmit === 2 /* OnSelect */) {
                ev.preventDefault();
            }
            suppressAutocomplete = true;
            try {
                settings.onSelect(selected, input);
            }
            finally {
                suppressAutocomplete = false;
            }
            clear();
        }
        if (preventSubmit === 1 /* Always */) {
            ev.preventDefault();
        }
    }
    function keydownEventHandler(ev) {
        var key = ev.key;
        switch (key) {
            case 'ArrowUp':
            case 'ArrowDown':
            case 'Escape':
                handleArrowAndEscapeKeys(ev, key);
                break;
            case 'Enter':
                handleEnterKey(ev);
                break;
        }
    }
    function focusEventHandler() {
        if (showOnFocus) {
            fetch(1 /* Focus */);
        }
    }
    function fetch(trigger) {
        if (input.value.length >= minLen || trigger === 1 /* Focus */) {
            clearDebounceTimer();
            debounceTimer = window.setTimeout(function () { return startFetch(input.value, trigger, input.selectionStart || 0); }, trigger === 0 /* Keyboard */ || trigger === 2 /* Mouse */ ? debounceWaitMs : 0);
        }
        else {
            clear();
        }
    }
    function startFetch(inputText, trigger, cursorPos) {
        if (destroyed)
            return;
        var savedFetchCounter = ++fetchCounter;
        settings.fetch(inputText, function (elements) {
            if (fetchCounter === savedFetchCounter && elements) {
                items = elements;
                inputValue = inputText;
                selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];
                update();
            }
        }, trigger, cursorPos);
    }
    function keyupEventHandler(e) {
        if (settings.keyup) {
            settings.keyup({
                event: e,
                fetch: function () { return fetch(0 /* Keyboard */); }
            });
            return;
        }
        if (!containerDisplayed() && e.key === 'ArrowDown') {
            fetch(0 /* Keyboard */);
        }
    }
    function clickEventHandler(e) {
        settings.click && settings.click({
            event: e,
            fetch: function () { return fetch(2 /* Mouse */); }
        });
    }
    function blurEventHandler() {
        // when an item is selected by mouse click, the blur event will be initiated before the click event and remove DOM elements,
        // so that the click event will never be triggered. In order to avoid this issue, DOM removal should be delayed.
        setTimeout(function () {
            if (doc.activeElement !== input) {
                clear();
            }
        }, 200);
    }
    function manualFetch() {
        startFetch(input.value, 3 /* Manual */, input.selectionStart || 0);
    }
    /**
     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
     */
    container.addEventListener('mousedown', function (evt) {
        evt.stopPropagation();
        evt.preventDefault();
    });
    /**
     * Fixes #30: autocomplete closes when scrollbar is clicked in IE
     * See: https://stackoverflow.com/a/9210267/13172349
     */
    container.addEventListener('focus', function () { return input.focus(); });
    // If the custom autocomplete container is already appended to the DOM during widget initialization, detach it.
    detach();
    /**
     * This function will remove DOM elements and clear event handlers
     */
    function destroy() {
        input.removeEventListener('focus', focusEventHandler);
        input.removeEventListener('keyup', keyupEventHandler);
        input.removeEventListener('click', clickEventHandler);
        input.removeEventListener('keydown', keydownEventHandler);
        input.removeEventListener('input', inputEventHandler);
        input.removeEventListener('blur', blurEventHandler);
        window.removeEventListener('resize', resizeEventHandler);
        doc.removeEventListener('scroll', scrollEventHandler, true);
        input.removeAttribute('role');
        input.removeAttribute('aria-expanded');
        input.removeAttribute('aria-autocomplete');
        input.removeAttribute('aria-controls');
        input.removeAttribute('aria-activedescendant');
        input.removeAttribute('aria-owns');
        input.removeAttribute('aria-haspopup');
        clearDebounceTimer();
        clear();
        destroyed = true;
    }
    // setup event handlers
    input.addEventListener('keyup', keyupEventHandler);
    input.addEventListener('click', clickEventHandler);
    input.addEventListener('keydown', keydownEventHandler);
    input.addEventListener('input', inputEventHandler);
    input.addEventListener('blur', blurEventHandler);
    input.addEventListener('focus', focusEventHandler);
    window.addEventListener('resize', resizeEventHandler);
    doc.addEventListener('scroll', scrollEventHandler, true);
    return {
        destroy: destroy,
        fetch: manualFetch
    };
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$v, ApplicationV2: ApplicationV2$t } = foundry.applications.api;

class AttributionDialog extends HandlebarsApplicationMixin$v(ApplicationV2$t) {
    constructor(item) {
        super({});

        this.item = item;
        this.sources = Object.keys(CONFIG.DH.GENERAL.attributionSources).flatMap(groupKey => {
            const group = CONFIG.DH.GENERAL.attributionSources[groupKey];
            return group.values.map(x => ({ group: group.label, ...x }));
        });
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.APPLICATIONS.Attribution.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dh-style', 'dialog', 'views', 'attribution'],
        position: { width: 'auto', height: 'auto' },
        window: { icon: 'fa-solid fa-signature' },
        form: { handler: this.updateData, submitOnChange: false, closeOnSubmit: true }
    };

    static PARTS = {
        main: { template: 'systems/daggerheart/templates/dialogs/attribution.hbs' }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        const sources = this.sources;

        htmlElement.querySelectorAll('.attribution-input').forEach(element => {
            autocomplete({
                input: element,
                fetch: function (text, update) {
                    if (!text) {
                        update(sources);
                    } else {
                        text = text.toLowerCase();
                        var suggestions = sources.filter(n => n.label.toLowerCase().includes(text));
                        update(suggestions);
                    }
                },
                render: function (item, search) {
                    const label = game.i18n.localize(item.label);
                    const matchIndex = label.toLowerCase().indexOf(search);

                    const beforeText = label.slice(0, matchIndex);
                    const matchText = label.slice(matchIndex, matchIndex + search.length);
                    const after = label.slice(matchIndex + search.length, label.length);

                    const element = document.createElement('li');
                    element.innerHTML = `${beforeText}${matchText ? `<strong>${matchText}</strong>` : ''}${after}`;
                    if (item.hint) {
                        element.dataset.tooltip = game.i18n.localize(item.hint);
                    }

                    return element;
                },
                renderGroup: function (label) {
                    const itemElement = document.createElement('div');
                    itemElement.textContent = game.i18n.localize(label);
                    return itemElement;
                },
                onSelect: function (item) {
                    element.value = item.label;
                },
                click: e => e.fetch(),
                customize: function (_input, _inputRect, container) {
                    container.style.zIndex = foundry.applications.api.ApplicationV2._maxZ;
                },
                minLength: 0
            });
        });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.item = this.item;
        context.data = this.item.system.attribution;

        return context;
    }

    static async updateData(_event, _element, formData) {
        await this.item.update({ 'system.attribution': formData.object });
        this.item.sheet.refreshFrame();
    }
}

const { ApplicationV2: ApplicationV2$s, HandlebarsApplicationMixin: HandlebarsApplicationMixin$u } = foundry.applications.api;

class BeastformDialog extends HandlebarsApplicationMixin$u(ApplicationV2$s) {
    constructor(configData, item) {
        super();

        this.item = item;

        this.configData = configData;
        this.selected = null;
        this.evolved = { form: null };
        this.hybrid = { forms: {}, advantages: {}, features: {} };

        this._dragDrop = this._createDragDropHandlers();
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'dialog', 'dh-style', 'beastform-selection'],
        position: {
            width: 600,
            height: 'auto'
        },
        window: {
            icon: 'fa-solid fa-paw'
        },
        actions: {
            selectBeastform: this.selectBeastform,
            toggleHybridFeature: this.toggleHybridFeature,
            toggleHybridAdvantage: this.toggleHybridAdvantage,
            submitBeastform: this.submitBeastform
        },
        form: {
            handler: this.updateBeastform,
            submitOnChange: true,
            submitOnClose: false
        },
        dragDrop: [{ dragSelector: '.beastform-container', dropSelector: '.advanced-form-container' }]
    };

    get title() {
        return this.item.name;
    }

    /** @override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/dialogs/beastform/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/dialogs/beastform/tabs.hbs' },
        beastformTier: { template: 'systems/daggerheart/templates/dialogs/beastform/beastformTier.hbs' },
        advanced: { template: 'systems/daggerheart/templates/dialogs/beastform/advanced.hbs' },
        footer: { template: 'systems/daggerheart/templates/dialogs/beastform/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: '1' }, { id: '2' }, { id: '3' }, { id: '4' }],
            initial: '1',
            labelPrefix: 'DAGGERHEART.GENERAL.Tiers'
        }
    };

    changeTab(tab, group, options) {
        super.changeTab(tab, group, options);

        this.render();
    }

    _createDragDropHandlers() {
        return this.options.dragDrop.map(d => {
            d.callbacks = {
                dragstart: this._onDragStart.bind(this),
                drop: this._onDrop.bind(this)
            };
            return new foundry.applications.ux.DragDrop.implementation(d);
        });
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        this._dragDrop.forEach(d => d.bind(htmlElement));
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);

        context.selected = this.selected;
        context.selectedBeastformEffect = this.selected?.effects?.find?.(x => x.type === 'beastform');

        context.evolved = this.evolved;

        context.hybridForms = Object.keys(this.hybrid.forms).reduce((acc, formKey) => {
            if (!this.hybrid.forms[formKey]) {
                acc[formKey] = null;
            } else {
                const data = this.hybrid.forms[formKey].toObject();
                acc[formKey] = {
                    ...data,
                    system: {
                        ...data.system,
                        features: this.hybrid.forms[formKey].system.features.map(feature => ({
                            ...feature.toObject(),
                            uuid: feature.uuid,
                            selected: Boolean(this.hybrid.features?.[formKey]?.[feature.uuid])
                        })),
                        advantageOn: Object.keys(data.system.advantageOn).reduce((acc, key) => {
                            acc[key] = {
                                ...data.system.advantageOn[key],
                                selected: Boolean(this.hybrid.advantages?.[formKey]?.[key])
                            };
                            return acc;
                        }, {})
                    }
                };
            }
            return acc;
        }, {});

        const maximumDragTier = Math.max(
            this.selected?.system?.evolved?.maximumTier ?? 0,
            this.selected?.system?.hybrid?.maximumTier ?? 0
        );

        const compendiumBeastforms = await game.packs.get(`daggerheart.beastforms`)?.getDocuments();
        const beastformTiers = [...game.items, ...(compendiumBeastforms ? compendiumBeastforms : [])].reduce(
            (acc, x) => {
                const tier = CONFIG.DH.GENERAL.tiers[x.system.tier];
                if (x.type !== 'beastform' || tier.id > this.configData.tierLimit) return acc;

                if (!acc[tier.id]) acc[tier.id] = { label: game.i18n.localize(tier.label), values: {} };

                if (Object.values(acc[tier.id].values).find(existing => existing.value.name === x.name)) return acc;

                acc[tier.id].values[x.uuid] = {
                    selected: this.selected?.uuid == x.uuid,
                    value: x,
                    draggable:
                        !['evolved', 'hybrid'].includes(x.system.beastformType) && maximumDragTier
                            ? x.system.tier <= maximumDragTier
                            : false
                };

                return acc;
            },
            {}
        );

        context.tier = beastformTiers[this.tabGroups.primary];
        context.tierKey = this.tabGroups.primary;

        context.canSubmit = this.canSubmit();

        return context;
    }

    canSubmit() {
        if (this.selected) {
            switch (this.selected.system.beastformType) {
                case 'normal':
                    return true;
                case 'evolved':
                    return this.evolved.form;
                case 'hybrid':
                    const selectedAdvantages = Object.values(this.hybrid.advantages).reduce(
                        (acc, form) => acc + Object.values(form).length,
                        0
                    );
                    const selectedFeatures = Object.values(this.hybrid.features).reduce(
                        (acc, form) => acc + Object.values(form).length,
                        0
                    );

                    const advantagesSelected = selectedAdvantages === this.selected.system.hybrid.advantages;
                    const featuresSelected = selectedFeatures === this.selected.system.hybrid.features;
                    return advantagesSelected && featuresSelected;
            }
        }

        return false;
    }

    static updateBeastform(event, _, formData) {
        this.selected = foundry.utils.mergeObject(this.selected, formData.object);

        this.render();
    }

    static async selectBeastform(_, target) {
        this.element.querySelectorAll('.beastform-container ').forEach(element => {
            if (element.dataset.uuid === target.dataset.uuid && this.selected?.uuid !== target.dataset.uuid) {
                element.classList.remove('inactive');
            } else {
                element.classList.add('inactive');
            }
        });

        const uuid = this.selected?.uuid === target.dataset.uuid ? null : target.dataset.uuid;
        this.selected = uuid ? await foundry.utils.fromUuid(uuid) : null;

        if (this.selected) {
            if (this.selected.system.beastformType !== 'evolved') this.evolved.form = null;
            if (this.selected.system.beastformType !== 'hybrid') {
                this.hybrid.forms = {};
                this.hybrid.advantages = {};
                this.hybrid.features = {};
            } else {
                this.hybrid.forms = [...Array(this.selected.system.hybrid.beastformOptions).keys()].reduce((acc, _) => {
                    acc[foundry.utils.randomID()] = null;
                    return acc;
                }, {});
            }
        }

        this.render();
    }

    static toggleHybridFeature(_, button) {
        const current = this.hybrid.features[button.dataset.form];
        if (!current) this.hybrid.features[button.dataset.form] = {};

        if (this.hybrid.features[button.dataset.form][button.id])
            delete this.hybrid.features[button.dataset.form][button.id];
        else {
            const currentFeatures = Object.values(this.hybrid.features).reduce(
                (acc, form) => acc + Object.values(form).length,
                0
            );
            if (currentFeatures === this.selected.system.hybrid.features) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformToManyFeatures'));
                return;
            }

            const feature = this.hybrid.forms[button.dataset.form].system.features.find(x => x.uuid === button.id);
            this.hybrid.features[button.dataset.form][button.id] = feature;
        }

        this.render();
    }

    static toggleHybridAdvantage(_, button) {
        const current = this.hybrid.advantages[button.dataset.form];
        if (!current) this.hybrid.advantages[button.dataset.form] = {};

        if (this.hybrid.advantages[button.dataset.form][button.id])
            delete this.hybrid.advantages[button.dataset.form][button.id];
        else {
            const currentAdvantages = Object.values(this.hybrid.advantages).reduce(
                (acc, form) => acc + Object.values(form).length,
                0
            );
            if (currentAdvantages === this.selected.system.hybrid.advantages) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformToManyAdvantages'));
                return;
            }

            const advantage = this.hybrid.forms[button.dataset.form].system.advantageOn[button.id];
            this.hybrid.advantages[button.dataset.form][button.id] = advantage;
        }

        this.render();
    }

    static async submitBeastform() {
        await this.close({ submitted: true });
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.selected = null;
    }

    static async configure(configData, item) {
        return new Promise(resolve => {
            const app = new this(configData, item);
            const featureItem = item;
            app.addEventListener(
                'close',
                async () => {
                    const selected = app.selected.toObject();
                    const data = await game.system.api.data.items.DHBeastform.getWildcardImage(
                        app.configData.data.parent,
                        app.selected
                    );
                    if (data) {
                        if (!data.selectedImage) selected = null;
                        else {
                            if (data.usesDynamicToken) selected.system.tokenRingImg = data.selectedImage;
                            else selected.system.tokenImg = data.selectedImage;
                        }
                    }

                    resolve({ selected: selected, evolved: app.evolved, hybrid: app.hybrid, item: featureItem });
                },
                { once: true }
            );
            app.render({ force: true });
        });
    }

    async _onDragStart(event) {
        const target = event.currentTarget;
        const abort = () => event.preventDefault();
        if (!this.selected) abort();

        const draggedForm = await foundry.utils.fromUuid(target.dataset.uuid);
        if (['evolved', 'hybrid'].includes(draggedForm.system.beastformType)) abort();

        if (this.selected.system.beastformType === 'evolved') {
            if (draggedForm.system.tier > this.selected.system.evolved.maximumTier) abort();
        }
        if (this.selected.system.beastformType === 'hybrid') {
            if (draggedForm.system.tier > this.selected.system.hybrid.maximumTier) abort();
        }

        event.dataTransfer.setData('text/plain', JSON.stringify(target.dataset));
        event.dataTransfer.setDragImage(target, 60, 0);
    }

    async _onDrop(event) {
        event.stopPropagation();
        const data = foundry.applications.ux.TextEditor.getDragEventData(event);
        const item = await fromUuid(data.uuid);
        if (!item) return;

        if (event.target.closest('.advanced-form-container.evolved')) {
            this.evolved.form = item;
        } else {
            const hybridContainer = event.target.closest('.advanced-form-container.hybridized');
            if (hybridContainer) {
                const existingId = Object.keys(this.hybrid.forms).find(
                    key => this.hybrid.forms[key]?.uuid === item.uuid
                );
                if (existingId) this.hybrid.forms[existingId] = null;

                this.hybrid.forms[hybridContainer.id] = item;
            }
        }

        this.render();
    }
}

const { ApplicationV2: ApplicationV2$r, HandlebarsApplicationMixin: HandlebarsApplicationMixin$t } = foundry.applications.api;

class D20RollDialog extends HandlebarsApplicationMixin$t(ApplicationV2$r) {
    constructor(roll, config = {}, options = {}) {
        super(options);

        this.roll = roll;
        this.config = config;
        this.config.experiences = [];
        this.reactionOverride = config.actionType === 'reaction';

        if (config.source?.action) {
            this.item = config.data.parent.items.get(config.source.item) ?? config.data.parent;
            this.action =
                config.data.attack?._id == config.source.action
                    ? config.data.attack
                    : this.item.system.actionsList?.find(a => a.id === config.source.action);
        }
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        // id: 'roll-selection',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'roll-selection'],
        position: {
            width: 'auto'
        },
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            updateIsAdvantage: this.updateIsAdvantage,
            selectExperience: this.selectExperience,
            toggleReaction: this.toggleReaction,
            toggleTagTeamRoll: this.toggleTagTeamRoll,
            submitRoll: this.submitRoll
        },
        form: {
            handler: this.updateRollConfiguration,
            submitOnChange: true,
            submitOnClose: false
        }
    };

    get title() {
        return `${this.config.title}${this.actor ? `: ${this.actor.name}` : ''}`;
    }

    get actor() {
        return this.config?.data?.parent;
    }

    /** @override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/header.hbs'
        },
        rollSelection: {
            id: 'rollSelection',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/rollSelection.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.rollConfig = this.config;
        context.hasRoll = !!this.config.roll;
        context.canRoll = true;
        context.selectedRollMode = this.config.selectedRollMode ?? game.settings.get('core', 'rollMode');
        context.rollModes = Object.entries(CONFIG.Dice.rollModes).map(([action, { label, icon }]) => ({
            action,
            label,
            icon
        }));

        this.config.costs ??= [];
        if (this.config.costs?.length) {
            const updatedCosts = game.system.api.fields.ActionFields.CostField.calcCosts.call(
                this.action ?? { actor: this.actor },
                this.config.costs
            );
            context.costs = updatedCosts.map(x => ({
                ...x,
                label: x.itemId
                    ? this.action.parent.parent.name
                    : game.i18n.localize(CONFIG.DH.GENERAL.abilityCosts[x.key].label)
            }));
            context.canRoll = game.system.api.fields.ActionFields.CostField.hasCost.call(
                this.action ?? { actor: this.actor },
                updatedCosts
            );
            this.config.data.scale = this.config.costs[0].total;
        }
        if (this.config.uses?.max) {
            context.uses = game.system.api.fields.ActionFields.UsesField.calcUses.call(this.action, this.config.uses);
            context.canRoll =
                context.canRoll &&
                game.system.api.fields.ActionFields.UsesField.hasUses.call(this.action, context.uses);
        }
        if (this.roll) {
            context.roll = this.roll;
            context.rollType = this.roll?.constructor.name;
            context.rallyDie = this.roll.rallyChoices;
            const experiences = this.config.data?.experiences || {};
            context.experiences = Object.keys(experiences).map(id => ({
                id,
                ...experiences[id]
            }));
            context.selectedExperiences = this.config.experiences;
            context.advantage = this.config.roll?.advantage;
            context.disadvantage = this.config.roll?.disadvantage;
            context.diceOptions = CONFIG.DH.GENERAL.diceTypes;
            context.isLite = this.config.roll?.lite;
            context.extraFormula = this.config.extraFormula;
            context.formula = this.roll.constructFormula(this.config);
            if (this.actor?.system?.traits) context.abilities = this.getTraitModifiers();

            context.showReaction = !this.config.roll?.type && context.rollType === 'DualityRoll';
            context.reactionOverride = this.reactionOverride;
        }

        const tagTeamSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
        if (this.actor && tagTeamSetting.members[this.actor.id] && !this.config.skips?.createMessage) {
            context.activeTagTeamRoll = true;
            context.tagTeamSelected = this.config.tagTeamSelected;
        }

        return context;
    }

    getTraitModifiers() {
        return Object.values(abilities).map(a => ({
            id: a.id,
            label: `${game.i18n.localize(a.label)} (${this.actor.system.traits[a.id]?.value.signedString() ?? 0})`
        }));
    }

    static updateRollConfiguration(event, _, formData) {
        const { ...rest } = foundry.utils.expandObject(formData.object);

        this.config.selectedRollMode = rest.selectedRollMode;

        if (this.config.costs) {
            this.config.costs = foundry.utils.mergeObject(this.config.costs, rest.costs);
        }
        if (this.config.uses) this.config.uses = foundry.utils.mergeObject(this.config.uses, rest.uses);
        if (rest.roll?.dice) {
            Object.entries(rest.roll.dice).forEach(([key, value]) => {
                this.roll[key] = value;
            });
        }
        if (rest.hasOwnProperty('trait')) {
            this.config.roll.trait = rest.trait;
            this.config.title = game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: game.i18n.localize(abilities[this.config.roll.trait]?.label)
            });
        }
        this.config.extraFormula = rest.extraFormula;
        this.render();
    }

    static updateIsAdvantage(_, button) {
        const advantage = Number(button.dataset.advantage);
        this.advantage = advantage === 1;
        this.disadvantage = advantage === -1;

        this.config.roll.advantage = this.config.roll.advantage === advantage ? 0 : advantage;
        this.render();
    }

    static selectExperience(_, button) {
        this.config.experiences =
            this.config.experiences.indexOf(button.dataset.key) > -1
                ? this.config.experiences.filter(x => x !== button.dataset.key)
                : [...this.config.experiences, button.dataset.key];
        this.config.costs =
            this.config.costs.indexOf(this.config.costs.find(c => c.extKey === button.dataset.key)) > -1
                ? this.config.costs.filter(x => x.extKey !== button.dataset.key)
                : [
                      ...this.config.costs,
                      {
                          extKey: button.dataset.key,
                          key: this.config?.data?.parent?.isNPC ? 'fear' : 'hope',
                          value: 1,
                          name: this.config.data?.experiences?.[button.dataset.key]?.name
                      }
                  ];
        this.render();
    }

    static toggleReaction() {
        if (this.config.roll) {
            this.reactionOverride = !this.reactionOverride;
            this.config.actionType = this.reactionOverride
                ? CONFIG.DH.ITEM.actionTypes.reaction.id
                : this.config.actionType === CONFIG.DH.ITEM.actionTypes.reaction.id
                  ? CONFIG.DH.ITEM.actionTypes.action.id
                  : this.config.actionType;
            this.render();
        }
    }

    static toggleTagTeamRoll() {
        this.config.tagTeamSelected = !this.config.tagTeamSelected;
        this.render();
    }

    static async submitRoll() {
        await this.close({ submitted: true });
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.config = false;
    }

    static async configure(roll, config = {}, options = {}) {
        return new Promise(resolve => {
            const app = new this(roll, config, options);
            app.addEventListener('close', () => resolve(app.config), { once: true });
            app.render({ force: true });
        });
    }
}

const { ApplicationV2: ApplicationV2$q, HandlebarsApplicationMixin: HandlebarsApplicationMixin$s } = foundry.applications.api;

class DamageDialog extends HandlebarsApplicationMixin$s(ApplicationV2$q) {
    constructor(roll, config = {}, options = {}) {
        super(options);

        this.roll = roll;
        this.config = config;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'roll-selection',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'damage-selection'],
        position: {
            width: 400,
            height: 'auto'
        },
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            submitRoll: this.submitRoll
        },
        form: {
            handler: this.updateRollConfiguration,
            submitOnChange: true,
            submitOnClose: false
        }
    };

    /** @override */
    static PARTS = {
        damageSelection: {
            id: 'damageSelection',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/damageSelection.hbs'
        }
    };

    get title() {
        return game.i18n.localize(
            `DAGGERHEART.EFFECTS.ApplyLocations.${this.config.hasHealing ? 'healing' : 'damage'}Roll.name`
        );
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.config = CONFIG.DH;
        context.title = this.config.title ?? this.title;
        context.formula = this.roll.constructFormula(this.config);
        context.hasHealing = this.config.hasHealing;
        context.directDamage = this.config.directDamage;
        context.selectedRollMode = this.config.selectedRollMode;
        context.rollModes = Object.entries(CONFIG.Dice.rollModes).map(([action, { label, icon }]) => ({
            action,
            label,
            icon
        }));
        context.modifiers = this.config.modifiers;
        return context;
    }

    static updateRollConfiguration(_event, _, formData) {
        const { ...rest } = foundry.utils.expandObject(formData.object);
        foundry.utils.mergeObject(this.config.roll, rest.roll);
        foundry.utils.mergeObject(this.config.modifiers, rest.modifiers);
        this.config.selectedRollMode = rest.selectedRollMode;

        this.render();
    }

    static async submitRoll() {
        await this.close({ submitted: true });
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.config = false;
    }

    static async configure(roll, config = {}) {
        return new Promise(resolve => {
            const app = new this(roll, config);
            app.addEventListener('close', () => resolve(app.config), { once: true });
            app.render({ force: true });
        });
    }
}

const { ApplicationV2: ApplicationV2$p, HandlebarsApplicationMixin: HandlebarsApplicationMixin$r } = foundry.applications.api;

class DamageReductionDialog extends HandlebarsApplicationMixin$r(ApplicationV2$p) {
    constructor(resolve, reject, actor, damage, damageType) {
        super({});

        this.resolve = resolve;
        this.reject = reject;
        this.actor = actor;
        this.damage = damage;
        this.damageType = damageType;
        this.rulesDefault = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.Automation
        ).damageReductionRulesDefault;

        this.rulesOn = [CONFIG.DH.GENERAL.ruleChoice.on.id, CONFIG.DH.GENERAL.ruleChoice.onWithToggle.id].includes(
            this.rulesDefault
        );

        const canApplyArmor = damageType.every(t => actor.system.armorApplicableDamageTypes[t] === true);
        const availableArmor = actor.system.armorScore - actor.system.armor.system.marks.value;
        const maxArmorMarks = canApplyArmor ? availableArmor : 0;

        const armor = [...Array(maxArmorMarks).keys()].reduce((acc, _) => {
            acc[foundry.utils.randomID()] = { selected: false };
            return acc;
        }, {});
        const stress = [...Array(actor.system.rules.damageReduction.maxArmorMarked.stressExtra ?? 0).keys()].reduce(
            (acc, _) => {
                acc[foundry.utils.randomID()] = { selected: false };
                return acc;
            },
            {}
        );
        this.marks = { armor, stress };

        this.availableStressReductions = Object.keys(actor.system.rules.damageReduction.stressDamageReduction).reduce(
            (acc, key) => {
                const dr = actor.system.rules.damageReduction.stressDamageReduction[key];
                if (dr.cost) {
                    if (acc === null) acc = {};

                    const damage = damageKeyToNumber(key);
                    acc[damage] = {
                        cost: dr.cost,
                        selected: false,
                        any: key === 'any',
                        from: getDamageLabel(damage),
                        to: getDamageLabel(damage - 1)
                    };
                }

                return acc;
            },
            null
        );

        this.reduceSeverity = this.damageType.reduce((value, curr) => {
            return Math.max(this.actor.system.rules.damageReduction.reduceSeverity[curr], value);
        }, 0);
        this.actor.system.rules.damageReduction.reduceSeverity[this.damageType];

        this.thresholdImmunities = Object.keys(actor.system.rules.damageReduction.thresholdImmunities).reduce(
            (acc, key) => {
                if (actor.system.rules.damageReduction.thresholdImmunities[key])
                    acc[damageKeyToNumber(key)] = game.i18n.format(`DAGGERHEART.GENERAL.DamageThresholds.with`, {
                        threshold: game.i18n.localize(`DAGGERHEART.GENERAL.DamageThresholds.${key}`)
                    });
                return acc;
            },
            {}
        );
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'damage-reduction'],
        position: {
            width: 280,
            height: 'auto'
        },
        actions: {
            toggleRules: this.toggleRules,
            setMarks: this.setMarks,
            useStressReduction: this.useStressReduction,
            takeDamage: this.takeDamage
        },
        form: {
            handler: this.updateData,
            submitOnChange: true,
            closeOnSubmit: false
        }
    };

    /** @override */
    static PARTS = {
        damageSelection: {
            id: 'damageReduction',
            template: 'systems/daggerheart/templates/dialogs/damageReduction.hbs'
        }
    };

    /* -------------------------------------------- */

    /** @inheritDoc */
    get title() {
        return game.i18n.localize('DAGGERHEART.APPLICATIONS.DamageReduction.title');
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.rulesOn = this.rulesOn;
        context.rulesToggleable = [
            CONFIG.DH.GENERAL.ruleChoice.onWithToggle.id,
            CONFIG.DH.GENERAL.ruleChoice.offWithToggle.id
        ].includes(this.rulesDefault);
        context.reduceSeverity = this.reduceSeverity;
        context.thresholdImmunities =
            Object.keys(this.thresholdImmunities).length > 0 ? this.thresholdImmunities : null;

        const { selectedArmorMarks, selectedStressMarks, stressReductions, currentMarks, currentDamage } =
            this.getDamageInfo();

        context.armorScore = this.actor.system.armorScore;
        context.armorMarks = currentMarks;
        context.basicMarksUsed =
            selectedArmorMarks.length === this.actor.system.rules.damageReduction.maxArmorMarked.value;

        const stressReductionStress = this.availableStressReductions
            ? stressReductions.reduce((acc, red) => acc + red.cost, 0)
            : 0;
        context.stress =
            selectedStressMarks.length > 0 || this.availableStressReductions
                ? {
                      value:
                          this.actor.system.resources.stress.value + selectedStressMarks.length + stressReductionStress,
                      max: this.actor.system.resources.stress.max
                  }
                : null;

        const maxArmor = this.actor.system.rules.damageReduction.maxArmorMarked.value;
        context.marks = {
            armor: Object.keys(this.marks.armor).reduce((acc, key, index) => {
                const mark = this.marks.armor[key];
                if (!this.rulesOn || index + 1 <= maxArmor) acc[key] = mark;

                return acc;
            }, {}),
            stress: this.marks.stress
        };
        context.availableStressReductions = this.availableStressReductions;

        context.damage = getDamageLabel(this.damage);
        context.reducedDamage = currentDamage !== this.damage ? getDamageLabel(currentDamage) : null;
        context.currentDamage = context.reducedDamage ?? context.damage;
        context.currentDamageNr = currentDamage;

        return context;
    }

    static updateData(event, _, formData) {
        foundry.utils.expandObject(formData.object);
        this.render(true);
    }

    getDamageInfo = () => {
        const selectedArmorMarks = Object.values(this.marks.armor).filter(x => x.selected);
        const selectedStressMarks = Object.values(this.marks.stress).filter(x => x.selected);
        const stressReductions = this.availableStressReductions
            ? Object.values(this.availableStressReductions).filter(red => red.selected)
            : [];
        const currentMarks =
            this.actor.system.armor.system.marks.value + selectedArmorMarks.length + selectedStressMarks.length;

        const armorMarkReduction =
            selectedArmorMarks.length * this.actor.system.rules.damageReduction.increasePerArmorMark;
        let currentDamage = Math.max(
            this.damage - armorMarkReduction - selectedStressMarks.length - stressReductions.length,
            0
        );
        if (this.reduceSeverity) {
            currentDamage = Math.max(currentDamage - this.reduceSeverity, 0);
        }

        if (this.thresholdImmunities[currentDamage]) currentDamage = 0;

        return { selectedArmorMarks, selectedStressMarks, stressReductions, currentMarks, currentDamage };
    };

    static toggleRules() {
        this.rulesOn = !this.rulesOn;

        const maxArmor = this.actor.system.rules.damageReduction.maxArmorMarked.value;
        this.marks = {
            armor: Object.keys(this.marks.armor).reduce((acc, key, index) => {
                const mark = this.marks.armor[key];
                const keepSelectValue = !this.rulesOn || index + 1 <= maxArmor;
                acc[key] = { ...mark, selected: keepSelectValue ? mark.selected : false };

                return acc;
            }, {}),
            stress: this.marks.stress
        };

        this.render();
    }

    static setMarks(_, target) {
        const currentMark = this.marks[target.dataset.type][target.dataset.key];
        const { selectedStressMarks, stressReductions, currentMarks, currentDamage } = this.getDamageInfo();

        if (!currentMark.selected && currentDamage === 0) {
            ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.damageAlreadyNone'));
            return;
        }

        if (this.rulesOn) {
            if (!currentMark.selected && currentMarks === this.actor.system.armorScore) {
                ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noAvailableArmorMarks'));
                return;
            }
        }

        if (currentMark.selected) {
            const currentDamageLabel = getDamageLabel(currentDamage);
            for (let reduction of stressReductions) {
                if (reduction.selected && reduction.to === currentDamageLabel) {
                    reduction.selected = false;
                }
            }

            if (target.dataset.type === 'armor' && selectedStressMarks.length > 0) {
                selectedStressMarks.forEach(mark => (mark.selected = false));
            }
        }

        currentMark.selected = !currentMark.selected;
        this.render();
    }

    static useStressReduction(_, target) {
        const damageValue = Number(target.dataset.reduction);
        const stressReduction = this.availableStressReductions[damageValue];
        const { currentDamage, selectedStressMarks, stressReductions } = this.getDamageInfo();

        if (stressReduction.selected) {
            stressReduction.selected = false;

            const currentDamageLabel = getDamageLabel(currentDamage);
            for (let reduction of stressReductions) {
                if (reduction.selected && reduction.to === currentDamageLabel) {
                    reduction.selected = false;
                }
            }

            this.render();
        } else {
            const stressReductionStress = this.availableStressReductions
                ? stressReductions.reduce((acc, red) => acc + red.cost, 0)
                : 0;
            const currentStress =
                this.actor.system.resources.stress.value + selectedStressMarks.length + stressReductionStress;
            if (currentStress + stressReduction.cost > this.actor.system.resources.stress.max) {
                ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.notEnoughStress'));
                return;
            }

            const reducedDamage = currentDamage !== this.damage ? getDamageLabel(currentDamage) : null;
            const currentDamageLabel = reducedDamage ?? getDamageLabel(this.damage);

            if (!stressReduction.any && stressReduction.from !== currentDamageLabel) return;

            stressReduction.selected = true;
            this.render();
        }
    }

    static async takeDamage() {
        const { selectedArmorMarks, selectedStressMarks, stressReductions, currentDamage } = this.getDamageInfo();
        const armorSpent = selectedArmorMarks.length + selectedStressMarks.length;
        const stressSpent = selectedStressMarks.length + stressReductions.reduce((acc, red) => acc + red.cost, 0);

        this.resolve({ modifiedDamage: currentDamage, armorSpent, stressSpent });
        await this.close(true);
    }

    async close(fromSave) {
        if (!fromSave) {
            this.resolve();
        }

        await super.close({});
    }

    static async armorSlotQuery({ actorId, damage, type }) {
        return new Promise(async (resolve, reject) => {
            const actor = await fromUuid(actorId);
            if (!actor || !actor?.isOwner) reject();
            new DamageReductionDialog(resolve, reject, actor, damage, type).render({ force: true });
        });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$q, ApplicationV2: ApplicationV2$o } = foundry.applications.api;

class DhpDeathMove extends HandlebarsApplicationMixin$q(ApplicationV2$o) {
    constructor(actor) {
        super({});

        this.actor = actor;
        this.selectedMove = null;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.DeathMove.title', { actor: this.actor.name });
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dh-style', 'dialog', 'views', 'death-move'],
        position: { width: 'auto', height: 'auto' },
        window: { icon: 'fa-solid fa-skull' },
        actions: {
            selectMove: this.selectMove,
            takeMove: this.takeMove
        }
    };

    static PARTS = {
        application: {
            id: 'death-move',
            template: 'systems/daggerheart/templates/dialogs/deathMove.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.selectedMove = this.selectedMove;
        context.options = CONFIG.DH.GENERAL.deathMoves;
        context.title = game.i18n.localize('DAGGERHEART.APPLICATIONS.DeathMove.takeMove');

        return context;
    }

    static selectMove(_, button) {
        const move = button.dataset.move;
        this.selectedMove = CONFIG.DH.GENERAL.deathMoves[move];

        this.render();
    }

    static async takeMove() {
        const cls = getDocumentClass('ChatMessage');
        const msg = {
            user: game.user.id,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/deathMove.hbs',
                {
                    player: this.actor.name,
                    actor: { name: this.actor.name, img: this.actor.img },
                    author: game.users.get(game.user.id),
                    title: game.i18n.localize(this.selectedMove.name),
                    img: this.selectedMove.img,
                    description: game.i18n.localize(this.selectedMove.description)
                }
            ),
            title: game.i18n.localize(
                'DAGGERHEART.UI.Chat.deathMove.title'
            ),
            speaker: cls.getSpeaker(),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);

        this.close();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$p, ApplicationV2: ApplicationV2$n } = foundry.applications.api;

class DhpDowntime extends HandlebarsApplicationMixin$p(ApplicationV2$n) {
    constructor(actor, shortrest) {
        super({});

        this.actor = actor;
        this.shortrest = shortrest;

        this.moveData = foundry.utils.deepClone(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).restMoves
        );
        this.nrChoices = {
            shortRest: {
                taken: 0,
                max:
                    (shortrest ? this.moveData.shortRest.nrChoices : 0) +
                    actor.system.bonuses.rest[`${shortrest ? 'short' : 'long'}Rest`].shortMoves
            },
            longRest: {
                taken: 0,
                max:
                    (!shortrest ? this.moveData.longRest.nrChoices : 0) +
                    actor.system.bonuses.rest[`${shortrest ? 'short' : 'long'}Rest`].longMoves
            }
        };

        this.refreshables = this.getRefreshables();
    }

    get title() {
        return '';
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'dh-style', 'dialog', 'downtime'],
        position: { width: 'auto', height: 'auto' },
        actions: {
            selectMove: this.selectMove,
            takeDowntime: this.takeDowntime
        },
        form: { handler: this.updateData, submitOnChange: true, closeOnSubmit: false }
    };

    static PARTS = {
        application: {
            id: 'downtime',
            template: 'systems/daggerheart/templates/dialogs/downtime/downtime.hbs'
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement
            .querySelectorAll('.activity-container')
            .forEach(element => element.addEventListener('contextmenu', this.deselectMove.bind(this)));
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.title = game.i18n.localize(
            `DAGGERHEART.APPLICATIONS.Downtime.${this.shortrest ? 'shortRest' : 'longRest'}.title`
        );
        context.selectedActivity = this.selectedActivity;
        context.moveData = this.moveData;

        const shortRestMovesSelected = this.nrSelectedMoves('shortRest');
        const longRestMovesSelected = this.nrSelectedMoves('longRest');
        context.nrChoices = {
            ...this.nrChoices,
            shortRest: {
                ...this.nrChoices.shortRest,
                current: this.nrChoices.shortRest.taken + shortRestMovesSelected
            },
            longRest: {
                ...this.nrChoices.longRest,
                current: this.nrChoices.longRest.taken + longRestMovesSelected
            }
        };

        context.shortRestMoves = this.nrChoices.shortRest.max > 0 ? this.moveData.shortRest : null;
        context.longRestMoves = this.nrChoices.longRest.max > 0 ? this.moveData.longRest : null;

        context.refreshables = this.refreshables;

        context.disabledDowntime = shortRestMovesSelected === 0 && longRestMovesSelected === 0;

        return context;
    }

    getRefreshables() {
        const actionItems = this.actor.items.reduce((acc, x) => {
            if (x.system.actions) {
                const recoverable = x.system.actions.reduce((acc, action) => {
                    if (refreshIsAllowed([this.shortrest ? 'shortRest' : 'longRest'], action.uses.recovery)) {
                        acc.push({
                            title: x.name,
                            name: action.name,
                            uuid: action.uuid
                        });
                    }

                    return acc;
                }, []);

                if (recoverable) {
                    acc.push(...recoverable);
                }
            }

            return acc;
        }, []);
        const resourceItems = this.actor.items.reduce((acc, x) => {
            if (
                x.system.resource &&
                x.system.resource.type &&
                refreshIsAllowed([this.shortrest ? 'shortRest' : 'longRest'], action.uses.recovery)
            ) {
                acc.push({
                    title: game.i18n.localize(`TYPES.Item.${x.type}`),
                    name: x.name,
                    uuid: x.uuid
                });
            }

            return acc;
        }, []);
        return {
            actionItems,
            resourceItems
        };
    }

    static selectMove(_, target) {
        const { category, move } = target.dataset;

        const nrSelected = this.nrSelectedMoves(category);

        if (nrSelected + this.nrChoices[category].taken >= this.nrChoices[category].max) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noMoreMoves'));
            return;
        }

        this.moveData[category].moves[move].selected = this.moveData[category].moves[move].selected
            ? this.moveData[category].moves[move].selected + 1
            : 1;

        this.render();
    }

    deselectMove(event) {
        const button = event.target.closest('.activity-container');
        const { move, category } = button.dataset;
        this.moveData[category].moves[move].selected = this.moveData[category].moves[move].selected
            ? this.moveData[category].moves[move].selected - 1
            : 0;

        this.render();

        // On macOS with a single-button mouse (e.g. a laptop trackpad),
        // right-click is triggered with ctrl+click, which triggers both a
        // `contextmenu` event and a regular click event. We need to stop
        // event propagation to prevent the click event from triggering the
        // `selectMove` function and undoing the change we just made.
        event.stopPropagation();

        // Having stopped propagation, we're no longer subject to Foundry's
        // default `contextmenu` handler, so we also have to prevent the
        // default behaviour to prevent a context menu from appearing.
        event.preventDefault();
    }

    static async takeDowntime() {
        const moves = Object.keys(this.moveData).flatMap(categoryKey => {
            const category = this.moveData[categoryKey];
            return Object.keys(category.moves)
                .filter(x => category.moves[x].selected)
                .flatMap(key => {
                    const move = category.moves[key];
                    return [...Array(move.selected).keys()].map(_ => ({
                        ...move,
                        movePath: `${categoryKey}.moves.${key}`
                    }));
                });
        });

        const cls = getDocumentClass('ChatMessage');
        const msg = {
            user: game.user.id,
            system: {
                moves: moves,
                actor: this.actor.uuid
            },
            speaker: cls.getSpeaker(),
            title: game.i18n.localize(
                `DAGGERHEART.APPLICATIONS.Downtime.${this.shortrest ? 'shortRest' : 'longRest'}.title`
            ),
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/downtime.hbs',
                {
                    title: game.i18n.localize(
                        `DAGGERHEART.APPLICATIONS.Downtime.${this.shortrest ? 'shortRest' : 'longRest'}.title`
                    ),
                    actor: { name: this.actor.name, img: this.actor.img },
                    moves: moves
                }
            ),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);

        // Reset selection and update number of taken moves
        for (const [catName, category] of Object.entries(this.moveData)) {
            for (const move of Object.values(category.moves)) {
                if (move.selected > 0) {
                    this.nrChoices[catName].taken += move.selected;
                    move.selected = 0;
                }
            }
        }

        // We can close the window and refresh resources when all moves are taken
        if (
            this.nrChoices.shortRest.taken >= this.nrChoices.shortRest.max &&
            this.nrChoices.longRest.taken >= this.nrChoices.longRest.max
        ) {
            for (var data of this.refreshables.actionItems) {
                const action = await foundry.utils.fromUuid(data.uuid);
                await action.parent.parent.update({ [`system.actions.${action.id}.uses.value`]: 0 });
            }

            for (var data of this.refreshables.resourceItems) {
                const feature = await foundry.utils.fromUuid(data.uuid);
                const increasing =
                    feature.system.resource.progression === CONFIG.DH.ITEM.itemResourceProgression.increasing.id;
                const resetValue = increasing
                    ? 0
                    : feature.system.resource.max
                      ? Roll.replaceFormulaData(feature.system.resource.max, this.actor)
                      : 0;
                await feature.update({ 'system.resource.value': resetValue });
            }

            this.close();
        } else {
            this.render();
        }
    }

    static async updateData(event, element, formData) {
        this.customActivity = foundry.utils.mergeObject(this.customActivity, formData.object);
        this.render();
    }

    nrSelectedMoves(category) {
        return Object.values(this.moveData[category].moves).reduce((acc, x) => acc + (x.selected ?? 0), 0);
    }
}

const { ApplicationV2: ApplicationV2$m, HandlebarsApplicationMixin: HandlebarsApplicationMixin$o } = foundry.applications.api;

class ImageSelectDialog extends HandlebarsApplicationMixin$o(ApplicationV2$m) {
    constructor(titleName, images) {
        super();

        this.titleName = titleName;
        this.images = images;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dialog', 'dh-style', 'image-select'],
        position: {
            width: 612,
            height: 'auto'
        },
        window: {
            icon: 'fa-solid fa-paw'
        },
        actions: {
            selectImage: ImageSelectDialog.#selectImage,
            finishSelection: ImageSelectDialog.#finishSelection
        }
    };

    get title() {
        return this.titleName;
    }

    /** @override */
    static PARTS = {
        main: {
            template: 'systems/daggerheart/templates/dialogs/image-select/main.hbs',
            scrollable: ['.images-container']
        },
        footer: { template: 'systems/daggerheart/templates/dialogs/image-select/footer.hbs' }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.images = this.images;
        context.selectedImage = this.selectedImage;

        return context;
    }

    static #selectImage(_event, button) {
        this.selectedImage = button.dataset.image ?? button.querySelector('img').dataset.image;
        this.render();
    }

    static #finishSelection() {
        this.close({ submitted: true });
    }

    async close(options = {}) {
        if (!options.submitted) this.selectedImage = null;

        await super.close();
    }

    static async configure(title, images) {
        return new Promise(resolve => {
            const app = new this(title, images);
            app.addEventListener('close', () => resolve(app.selectedImage), { once: true });
            app.render({ force: true });
        });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$n, ApplicationV2: ApplicationV2$l } = foundry.applications.api;

class ItemTransferDialog extends HandlebarsApplicationMixin$n(ApplicationV2$l) {
    constructor(item) {
        super({});

        this.item = item;
        this.quantity = item.system.quantity;
    }

    get title() {
        return this.item.name;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dh-style', 'dialog', 'item-transfer'],
        position: { width: 300, height: 'auto' },
        window: { icon: 'fa-solid fa-hand-holding-hand' },
        actions: {
            finish: ItemTransferDialog.#finish
        },
        form: { handler: this.updateData, submitOnChange: true, closeOnSubmit: false }
    };

    static PARTS = {
        main: { template: 'systems/daggerheart/templates/dialogs/item-transfer.hbs' }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelector('.number-display').addEventListener('change', event => {
            this.quantity = isNaN(event.target.value) ? this.quantity : Number(event.target.value);
            this.render();
        });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.item = this.item;
        context.quantity = this.quantity;

        return context;
    }

    static async updateData(_event, _element, formData) {
        const { quantity } = foundry.utils.expandObject(formData.object);
        this.quantity = quantity;
        this.render();
    }

    static async #finish() {
        this.close({ submitted: true });
    }

    close(options = {}) {
        if (!options.submitted) this.quantity = null;

        super.close();
    }

    static async configure(item) {
        return new Promise(resolve => {
            const app = new this(item);
            app.addEventListener('close', () => resolve(app.quantity), { once: true });
            app.render({ force: true });
        });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$m, ApplicationV2: ApplicationV2$k } = foundry.applications.api;

class MulticlassChoiceDialog extends HandlebarsApplicationMixin$m(ApplicationV2$k) {
    constructor(actor, multiclass, options) {
        super(options);

        this.actor = actor;
        this.multiclass = multiclass;
        this.selectedDomain = null;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.MulticlassChoice.title', { actor: this.actor.name });
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dh-style', 'dialog', 'views', 'multiclass-choice'],
        position: { width: 'auto', height: 'auto' },
        window: { icon: 'fa-solid fa-person-rays' },
        actions: {
            save: MulticlassChoiceDialog.#save,
            selectDomain: MulticlassChoiceDialog.#selectDomain
        }
    };

    static PARTS = {
        application: {
            id: 'multiclass-choice',
            template: 'systems/daggerheart/templates/dialogs/multiclassChoice.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.multiclass = this.multiclass;
        context.domainChoices = this.multiclass.domains.map(value => {
            const domain = CONFIG.DH.DOMAIN.allDomains()[value];
            return {
                value: value,
                label: game.i18n.localize(domain.label),
                description: game.i18n.localize(domain.description),
                src: domain.src,
                selected: value === this.selectedDomain,
                disabled: this.actor.system.domains.includes(value)
            };
        });
        context.multiclassDisabled = !this.selectedDomain;

        return context;
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.move = null;
    }

    static async configure(actor, multiclass, options = {}) {
        return new Promise(resolve => {
            const app = new this(actor, multiclass, options);
            app.addEventListener('close', () => resolve(app.selectedDomain), { once: true });
            app.render({ force: true });
        });
    }

    static #save() {
        this.close({ submitted: true });
    }

    static #selectDomain(_event, button) {
        this.selectedDomain = this.selectedDomain === button.dataset.domain ? null : button.dataset.domain;
        this.render();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$l, ApplicationV2: ApplicationV2$j } = foundry.applications.api;

class OwnershipSelection extends HandlebarsApplicationMixin$l(ApplicationV2$j) {
    constructor(name, ownership, defaultOwnership) {
        super({});

        this.name = name;
        this.ownership = foundry.utils.deepClone(ownership);
        this.defaultOwnership = defaultOwnership;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'dialog', 'dh-style', 'ownership-selection'],
        window: {
            icon: 'fa-solid fa-users'
        },
        position: {
            width: 600,
            height: 'auto'
        },
        form: { handler: this.updateData }
    };

    static PARTS = {
        selection: {
            template: 'systems/daggerheart/templates/dialogs/ownershipSelection.hbs'
        }
    };

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.OwnershipSelection.title', { name: this.name });
    }

    getOwnershipData(id) {
        return this.ownership[id] ?? CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT;
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.ownershipDefaultOptions = CONFIG.DH.GENERAL.basicOwnershiplevels;
        context.ownershipOptions = CONFIG.DH.GENERAL.simpleOwnershiplevels;
        context.defaultOwnership = this.defaultOwnership;
        context.ownership = game.users.reduce((acc, user) => {
            if (!user.isGM) {
                acc[user.id] = {
                    ...user,
                    img: user.character?.img ?? 'icons/svg/cowled.svg',
                    ownership: this.getOwnershipData(user.id)
                };
            }

            return acc;
        }, {});

        return context;
    }

    static async updateData(event, _, formData) {
        const data = foundry.utils.expandObject(formData.object);
        this.close(data);
    }

    async close(data) {
        if (data) {
            this.saveData = data;
        }

        await super.close();
    }

    static async configure(name, ownership, defaultOwnership) {
        return new Promise(resolve => {
            const app = new this(name, ownership, defaultOwnership);
            app.addEventListener('close', () => resolve(app.saveData), { once: true });
            app.render({ force: true });
        });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$k } = foundry.applications.api;

const typeSettingsMap = {
    character: 'extendCharacterDescriptions',
    adversary: 'extendAdversaryDescriptions',
    environment: 'extendEnvironmentDescriptions',
    ancestry: 'extendItemDescriptions',
    community: 'extendItemDescriptions',
    class: 'extendItemDescriptions',
    subclass: 'extendItemDescriptions',
    feature: 'extendItemDescriptions',
    domainCard: 'extendItemDescriptions',
    loot: 'extendItemDescriptions',
    consumable: 'extendItemDescriptions',
    weapon: 'extendItemDescriptions',
    armor: 'extendItemDescriptions',
    beastform: 'extendItemDescriptions'
};

/**
 * @typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction
 */

/**
 * @typedef {object} DragDropConfig
 * @property {string} [dragSelector] - A CSS selector that identifies draggable elements.
 * @property {string} [dropSelector] - A CSS selector that identifies drop targets.
 *
 * @typedef {object} ContextMenuConfig
 * @property {() => ContextMenuEntry[]} handler - A handler function that provides initial context options
 * @property {string} selector - A CSS selector to which the ContextMenu will be bound
 * @property {object} [options] - Additional options which affect ContextMenu construction
 * @property {HTMLElement} [options.container] - A parent HTMLElement which contains the selector target
 * @property {string} [options.hookName] - The hook name
 * @property {boolean} [options.parentClassHooks=true] - Whether to call hooks for the parent classes in the inheritance chain.
 *
 * @typedef {Object} TagOption
 * @property {string} label
 * @property {string} [src]
 *
 * @typedef {object} TagifyConfig
 * @property {String} selector - The CSS selector for get the element to transform into a tag input
 * @property {Record<string, TagOption> | (() => Record<string, TagOption>)} options - Available tag options as key-value pairs
 * @property {TagChangeCallback} callback - Callback function triggered when tags change
 * @property {TagifyOptions} [tagifyOptions={}] - Additional configuration for Tagify
 *
 * @callback TagChangeCallback
 * @param {Array<{value: string, name: string, src?: string}>} selectedOptions - Current selected tags
 * @param {{option: string, removed: boolean}} change - What changed (added/removed tag)
 * @param {HTMLElement} inputElement - Original input element
 *
 *
 * @typedef {Object} TagifyOptions
 * @property {number} [maxTags] - Maximum number of allowed tags
 */

/**
 * @typedef {import("@client/applications/api/handlebars-application.mjs").HandlebarsRenderOptions} HandlebarsRenderOptions
 * @typedef {foundry.applications.types.ApplicationConfiguration} FoundryAppConfig
 *
 * @typedef {FoundryAppConfig & HandlebarsRenderOptions & {
 *   dragDrop?: DragDropConfig[],
 *   tagifyConfigs?: TagifyConfig[],
 *   contextMenus?: ContextMenuConfig[],
 * }} DHSheetV2Configuration
 */

/**
 * @template {new (...args: any[]) => {}} T
 * @arg Base {T}
 */
function DHApplicationMixin(Base) {
    class DHSheetV2 extends HandlebarsApplicationMixin$k(Base) {
        /**
         * @param {DHSheetV2Configuration} [options={}]
         */
        constructor(options = {}) {
            super(options);
            /**
             * @type {foundry.applications.ux.DragDrop[]}
             * @private
             */
            this._dragDrop = this._createDragDropHandlers();
        }

        #nonHeaderAttribution = ['environment', 'ancestry', 'community', 'domainCard'];

        /**
         * The default options for the sheet.
         * @type {DHSheetV2Configuration}
         */
        static DEFAULT_OPTIONS = {
            classes: ['daggerheart', 'sheet', 'dh-style'],
            actions: {
                triggerContextMenu: DHSheetV2.#triggerContextMenu,
                createDoc: DHSheetV2.#createDoc,
                editDoc: DHSheetV2.#editDoc,
                deleteDoc: DHSheetV2.#deleteDoc,
                toChat: DHSheetV2.#toChat,
                useItem: DHSheetV2.#useItem,
                viewItem: DHSheetV2.#viewItem,
                toggleEffect: DHSheetV2.#toggleEffect,
                toggleExtended: DHSheetV2.#toggleExtended,
                addNewItem: DHSheetV2.#addNewItem,
                browseItem: DHSheetV2.#browseItem,
                editAttribution: DHSheetV2.#editAttribution
            },
            contextMenus: [
                {
                    handler: DHSheetV2.#getEffectContextOptions,
                    selector: '[data-item-uuid][data-type="effect"]',
                    options: {
                        parentClassHooks: false,
                        fixed: true
                    }
                },
                {
                    handler: DHSheetV2.#getActionContextOptions,
                    selector: '[data-item-uuid][data-type="action"]',
                    options: {
                        parentClassHooks: false,
                        fixed: true
                    }
                }
            ],
            dragDrop: [{ dragSelector: '.inventory-item[data-type="effect"]', dropSelector: null }],
            tagifyConfigs: []
        };

        /**@inheritdoc */
        async _renderFrame(options) {
            const frame = await super._renderFrame(options);

            const hideAttribution = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.appearance
            ).hideAttribution;
            const headerAttribution = !this.#nonHeaderAttribution.includes(this.document.type);
            if (!hideAttribution && this.document.system.metadata.hasAttribution && headerAttribution) {
                const { source, page } = this.document.system.attribution;
                const attribution = [source, page ? `pg ${page}.` : null].filter(x => x).join('. ');
                const element = `<label class="attribution-header-label">${attribution}</label>`;
                this.window.controls.insertAdjacentHTML('beforebegin', element);
            }

            return frame;
        }

        /**
         *  Refresh the custom parts of the application frame
         */
        refreshFrame() {
            const hideAttribution = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.appearance
            ).hideAttribution;
            const headerAttribution = !this.#nonHeaderAttribution.includes(this.document.type);
            if (!hideAttribution && this.document.system.metadata.hasAttribution && headerAttribution) {
                const { source, page } = this.document.system.attribution;
                const attribution = [source, page ? `pg ${page}.` : null].filter(x => x).join('. ');

                const label = this.window.header.querySelector('.attribution-header-label');
                label.innerHTML = attribution;
            }
        }

        /**
         * Related documents that should cause a rerender of this application when updated.
         */
        get relatedDocs() {
            return [];
        }

        /* -------------------------------------------- */

        /**@inheritdoc */
        _attachPartListeners(partId, htmlElement, options) {
            super._attachPartListeners(partId, htmlElement, options);
            this._dragDrop.forEach(d => d.bind(htmlElement));
        }

        /**@inheritdoc */
        async _onFirstRender(context, options) {
            await super._onFirstRender(context, options);

            const docs = [];
            for (const docData of this.relatedDocs) {
                if (!docData) continue;
                const doc = await foundry.utils.fromUuid(docData.uuid);
                docs.push(doc);
            }

            docs.filter(doc => doc).forEach(doc => (doc.apps[this.id] = this));

            if (!!this.options.contextMenus.length) this._createContextMenus();

            this.#autoExtendDescriptions(context);
        }

        /** @inheritDoc */
        _onClose(options) {
            super._onClose(options);
            this.relatedDocs.filter(doc => doc).map(doc => delete doc.apps[this.id]);
        }

        /** @inheritdoc */
        async _renderHTML(context, options) {
            const rendered = await super._renderHTML(context, options);
            for (const result of Object.values(rendered)) {
                await this.#prepareInventoryDescription(result);
            }
            return rendered;
        }

        /**@inheritdoc */
        async _onRender(context, options) {
            await super._onRender(context, options);
            this._createTagifyElements(this.options.tagifyConfigs);
        }

        /* -------------------------------------------- */
        /*  Sync Parts                                  */
        /* -------------------------------------------- */

        /**@inheritdoc */
        _preSyncPartState(partId, newElement, priorElement, state) {
            super._preSyncPartState(partId, newElement, priorElement, state);
            for (const el of priorElement.querySelectorAll('.extensible.extended')) {
                const { actionId, itemUuid } = el.parentElement.dataset;
                const selector = `${actionId ? `[data-action-id="${actionId}"]` : `[data-item-uuid="${itemUuid}"]`} .extensible`;
                const newExtensible = newElement.querySelector(selector);
                newExtensible?.classList.add('extended');
            }
        }

        /* -------------------------------------------- */
        /*  Tags                                        */
        /* -------------------------------------------- */

        /**
         * Creates Tagify elements from configuration objects
         * @param {TagifyConfig[]} tagConfigs - Array of Tagify configuration objects
         * @throws {TypeError} If tagConfigs is not an array
         * @throws {Error} If required properties are missing in config objects
         * @param {TagifyConfig[]} tagConfigs
         */
        _createTagifyElements(tagConfigs) {
            if (!Array.isArray(tagConfigs)) throw new TypeError('tagConfigs must be an array');

            tagConfigs.forEach(config => {
                try {
                    const { selector, options, callback, tagifyOptions = {} } = config;

                    // Validate required fields
                    if (!selector || !options || !callback) {
                        throw new Error('Invalid TagifyConfig - missing required properties', config);
                    }

                    // Find target element
                    const element = this.element.querySelector(selector);
                    if (!element) {
                        throw new Error(`Element not found with selector: ${selector}`);
                    }
                    // Resolve dynamic options if function provided
                    const resolvedOptions = typeof options === 'function' ? options.call(this) : options;

                    // Initialize Tagify
                    tagifyElement(element, resolvedOptions, callback.bind(this), tagifyOptions);
                } catch (error) {
                    console.error('Error initializing Tagify:', error);
                }
            });
        }

        /* -------------------------------------------- */
        /*  Drag and Drop                               */
        /* -------------------------------------------- */

        /**
         * Creates drag-drop handlers from the configured options.
         * @returns {foundry.applications.ux.DragDrop[]}
         * @private
         */
        _createDragDropHandlers() {
            return this.options.dragDrop.map(d => {
                d.callbacks = {
                    dragstart: this._onDragStart.bind(this),
                    drop: this._onDrop.bind(this)
                };
                return new foundry.applications.ux.DragDrop.implementation(d);
            });
        }

        /**
         * Handle dragStart event.
         * @param {DragEvent} event
         * @protected
         */
        async _onDragStart(event) {
            const inventoryItem = event.currentTarget.closest('.inventory-item');
            if (inventoryItem) {
                const { type, itemUuid } = inventoryItem.dataset;
                if (type === 'effect') {
                    const effect = await foundry.utils.fromUuid(itemUuid);
                    const effectData = {
                        type: 'ActiveEffect',
                        data: { ...effect.toObject(), _id: null },
                        fromInternal: this.document.uuid
                    };
                    event.dataTransfer.setData('text/plain', JSON.stringify(effectData));
                    event.dataTransfer.setDragImage(inventoryItem.querySelector('img'), 60, 0);
                }
            }
        }

        /**
         * Handle drop event.
         * @param {DragEvent} event
         * @protected
         */
        _onDrop(event) {
            event.stopPropagation();
            const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
            if (data.type === 'ActiveEffect' && data.fromInternal !== this.document.uuid) {
                this.document.createEmbeddedDocuments('ActiveEffect', [data.data]);
            } else {
                return super._onDrop(event);
            }
        }

        /* -------------------------------------------- */
        /*  Context Menu                                */
        /* -------------------------------------------- */

        /**
         * Create all configured context menus for this application ins tance.
         */
        _createContextMenus() {
            for (const config of this.options.contextMenus) {
                const { handler, selector, options } = config;
                this._createContextMenu(handler.bind(this), selector, options);
            }
        }

        /* -------------------------------------------- */

        /**
         * Get the set of ContextMenu options for ActiveEffects.
         * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
         * @this {DHSheetV2}
         * @protected
         */
        static #getEffectContextOptions() {
            /**@type {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} */
            const options = [
                {
                    name: 'disableEffect',
                    icon: 'fa-solid fa-lightbulb',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc && !doc.disabled;
                    },
                    callback: async target => (await getDocFromElement(target)).update({ disabled: true })
                },
                {
                    name: 'enableEffect',
                    icon: 'fa-regular fa-lightbulb',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc && doc.disabled;
                    },
                    callback: async target => (await getDocFromElement(target)).update({ disabled: false })
                }
            ].map(option => ({
                ...option,
                name: `DAGGERHEART.APPLICATIONS.ContextMenu.${option.name}`,
                icon: `<i class="${option.icon}"></i>`
            }));

            return [...options, ...this._getContextMenuCommonOptions.call(this, { toChat: true })];
        }

        /**
         * Get the set of ContextMenu options for Actions.
         * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
         * @this {DHSheetV2}
         * @protected
         */
        static #getActionContextOptions() {
            /**@type {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} */
            const options = [];
            return [...options, ...this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true })];
        }

        /**
         * Get the common ContextMenu options for an element.
         * @param {Object} options
         * @param {boolean} [options.usable=false] - Whether to include an option to use the item or apply damage.
         * @param {boolean} [options.toChat=false] - Whether to include an option to send the item to chat.
         * @param {boolean} [options.deletable=true] - Whether to include an option to delete the item.
         *
         * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]}
         */
        _getContextMenuCommonOptions({ usable = false, toChat = false, deletable = true }) {
            const options = [
                {
                    name: 'CONTROLS.CommonEdit',
                    icon: 'fa-solid fa-pen-to-square',
                    condition: target => {
                        const { dataset } = target.closest('[data-item-uuid]');
                        const doc = getDocFromElementSync(target);
                        return (
                            (!dataset.noCompendiumEdit && !doc) ||
                            (doc && (!doc?.hasOwnProperty('systemPath') || doc?.inCollection))
                        );
                    },
                    callback: async target => (await getDocFromElement(target)).sheet.render({ force: true })
                }
            ];

            if (usable) {
                options.unshift({
                    name: 'DAGGERHEART.GENERAL.damage',
                    icon: 'fa-solid fa-explosion',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc?.system?.attack?.damage.parts.length || doc?.damage?.parts.length;
                    },
                    callback: async (target, event) => {
                        const doc = await getDocFromElement(target),
                            action = doc?.system?.attack ?? doc;
                        const config = action.prepareConfig(event);
                        config.hasRoll = false;
                        return action && action.workflow.get('damage').execute(config, null, true);
                    }
                });

                options.unshift({
                    name: 'DAGGERHEART.APPLICATIONS.ContextMenu.useItem',
                    icon: 'fa-solid fa-burst',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc && !(doc.type === 'domainCard' && doc.system.inVault);
                    },
                    callback: async (target, event) => (await getDocFromElement(target)).use(event)
                });
            }

            if (toChat)
                options.push({
                    name: 'DAGGERHEART.APPLICATIONS.ContextMenu.sendToChat',
                    icon: 'fa-solid fa-message',
                    callback: async target => (await getDocFromElement(target)).toChat(this.document.uuid)
                });

            if (deletable)
                options.push({
                    name: 'CONTROLS.CommonDelete',
                    icon: 'fa-solid fa-trash',
                    callback: async (target, event) => {
                        const doc = await getDocFromElement(target);
                        if (event.shiftKey) return doc.delete();
                        else return doc.deleteDialog();
                    }
                });

            return options.map(option => ({
                ...option,
                icon: `<i class="${option.icon}"></i>`
            }));
        }

        /* -------------------------------------------- */
        /*  Prepare Context                             */
        /* -------------------------------------------- */

        /**@inheritdoc*/
        async _prepareContext(options) {
            const context = await super._prepareContext(options);
            context.config = CONFIG.DH;
            context.source = this.document;
            context.fields = this.document.schema.fields;
            context.systemFields = this.document.system.schema.fields;
            context.settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance);
            return context;
        }

        /* -------------------------------------------- */
        /*  Prepare Descriptions                        */
        /* -------------------------------------------- */

        /**
         * Prepares and enriches an inventory item or action description for display.
         * @param {HTMLElement} element the element to enrich the inventory items of
         * @returns {Promise<void>}
         */
        async #prepareInventoryDescription(element) {
            // Get all inventory item elements with a data-item-uuid attribute
            const inventoryItems = element.querySelectorAll('.inventory-item[data-item-uuid]');
            for (const el of inventoryItems) {
                // Get the doc uuid from the element
                const { itemUuid } = el?.dataset || {};
                if (!itemUuid) continue;

                //get doc by uuid
                const doc = await fromUuid(itemUuid);

                //get inventory-item description element
                const descriptionElement = el.querySelector('.invetory-description');
                if (!doc || !descriptionElement) continue;

                // localize the description (idk if it's still necessary)
                const description = game.i18n.localize(doc.system?.description ?? doc.description);

                // Enrich the description and attach it;
                const isAction = doc.documentName === 'Action';
                descriptionElement.innerHTML = await foundry.applications.ux.TextEditor.implementation.enrichHTML(
                    description,
                    {
                        relativeTo: isAction ? doc.parent : doc,
                        rollData: doc.getRollData?.(),
                        secrets: isAction ? doc.parent.isOwner : doc.isOwner
                    }
                );
            }
        }

        /* -------------------------------------------- */
        /*  Extend Descriptions by Settings             */
        /* -------------------------------------------- */

        /**
         * Extend inventory description when enabled in settings.
         * @returns {Promise<void>}
         */
        async #autoExtendDescriptions(context) {
            const inventoryItems = this.element.querySelectorAll('.inventory-item[data-item-uuid]');
            for (const el of inventoryItems) {
                // Get the doc uuid from the element
                const { itemUuid } = el?.dataset || {};
                if (!itemUuid) continue;

                //get doc by uuid
                const doc = await fromUuid(itemUuid);

                //check the type of the document
                const actorType =
                    doc?.type === 'adversary' && context.document?.type === 'environment'
                        ? typeSettingsMap[doc?.type]
                        : doc.actor?.type;

                // If the actor type is defined and the setting is enabled, extend the description
                if (typeSettingsMap[actorType]) {
                    const settingKey = typeSettingsMap[actorType];
                    if (context.settings[settingKey]) this.#activeExtended(el);
                }
            }
        }

        /* -------------------------------------------- */
        /*  Application Clicks Actions                  */
        /* -------------------------------------------- */

        static async #addNewItem(event, target) {
            const createChoice = await foundry.applications.api.DialogV2.wait({
                classes: ['dh-style', 'two-big-buttons'],
                buttons: [
                    {
                        action: 'create',
                        label: 'Create Item',
                        icon: 'fa-solid fa-plus'
                    },
                    {
                        action: 'browse',
                        label: 'Browse Compendium',
                        icon: 'fa-solid fa-book'
                    }
                ]
            });

            if (!createChoice) return;

            if (createChoice === 'browse') return DHSheetV2.#browseItem.call(this, event, target);
            else return DHSheetV2.#createDoc.call(this, event, target);
        }

        static async #browseItem(event, target) {
            const type = target.dataset.compendium ?? target.dataset.type;

            const presets = {
                render: {
                    noFolder: true
                }
            };

            switch (type) {
                case 'loot':
                    presets.folder = 'equipments.folders.loots';
                    break;
                case 'consumable':
                    presets.folder = 'equipments.folders.consumables';
                    break;
                case 'armor':
                    presets.folder = 'equipments.folders.armors';
                    break;
                case 'weapon':
                    presets.folder = 'equipments.folders.weapons';
                    break;
                case 'domainCard':
                    presets.folder = 'domains';
                    presets.filter = {
                        'level.max': { key: 'level.max', value: this.document.system.levelData.level.current },
                        'system.domain': { key: 'system.domain', value: this.document.system.domains }
                    };
                    break;
                default:
                    return;
            }

            ui.compendiumBrowser.open(presets);
        }

        /**
         * Open the attribution dialog
         * @type {ApplicationClickAction}
         */
        static async #editAttribution() {
            new game.system.api.applications.dialogs.AttributionDialog(this.document).render({ force: true });
        }

        /**
         * Create an embedded document.
         * @type {ApplicationClickAction}
         */
        static async #createDoc(event, target) {
            const { documentClass, type, inVault, disabled } = target.dataset;
            const parentIsItem = this.document.documentName === 'Item';
            const featureOnCharacter = this.document.parent?.type === 'character' && type === 'feature';
            const parent = featureOnCharacter
                ? this.document.parent
                : parentIsItem && documentClass === 'Item'
                  ? type === 'action'
                      ? this.document.system
                      : null
                  : this.document;

            let systemData = {};
            if (featureOnCharacter) {
                systemData = {
                    originItemType: this.document.type,
                    identifier: this.document.system.isMulticlass ? 'multiclass' : null
                };
            }

            const cls =
                type === 'action' ? game.system.api.models.actions.actionsTypes.base : getDocumentClass(documentClass);
            const data = {
                name: cls.defaultName({ type, parent }),
                type,
                system: systemData
            };
            if (inVault) data['system.inVault'] = true;
            if (disabled) data.disabled = true;
            if (type === "domainCard" && parent?.system.domains?.length) {
                data.system.domain = parent.system.domains[0];
            }

            const doc = await cls.create(data, { parent, renderSheet: !event.shiftKey });
            if (parentIsItem && type === 'feature') {
                await this.document.update({
                    'system.features': this.document.system.toObject().features.concat(doc.uuid)
                });
            }
            return doc;
        }

        /**
         * Renders an embedded document.
         * @type {ApplicationClickAction}
         */
        static async #editDoc(_event, target) {
            const doc = await getDocFromElement(target);
            if (doc) return doc.sheet.render({ force: true });
        }

        /**
         * Delete an embedded document.
         * @type {ApplicationClickAction}
         */
        static async #deleteDoc(event, target) {
            const doc = await getDocFromElement(target);
            if (doc) {
                if (event.shiftKey) return doc.delete();
                else return await doc.deleteDialog();
            }
        }

        /**
         * Send item to Chat
         * @type {ApplicationClickAction}
         */
        static async #toChat(_event, target) {
            const doc = await getDocFromElement(target);
            return doc.toChat(doc.uuid);
        }

        /**
         * Use a item
         * @type {ApplicationClickAction}
         */
        static async #useItem(event, target) {
            const doc = await getDocFromElement(target);
            await doc.use(event);
        }

        /**
         * View an item by opening its sheet
         * @type {ApplicationClickAction}
         */
        static async #viewItem(_, target) {
            const doc = await getDocFromElement(target);
            await doc.sheet.render({ force: true });
        }

        /**
         * Toggle a ActiveEffect
         * @type {ApplicationClickAction}
         */
        static async #toggleEffect(_, target) {
            const doc = await getDocFromElement(target);
            await doc.update({ disabled: !doc.disabled });
        }

        /**
         * Trigger the context menu.
         * @type {ApplicationClickAction}
         */
        static #triggerContextMenu(event, _) {
            return CONFIG.ux.ContextMenu.triggerContextMenu(event);
        }

        /**
         * Toggle the 'extended' class on the .extensible element inside inventory-item-content
         * @type {ApplicationClickAction}
         * @this {DHSheetV2}
         */
        static async #toggleExtended(_, target) {
            const container = target.closest('.inventory-item');
            const extensible = container?.querySelector('.extensible');
            extensible?.classList.toggle('extended');
        }

        async #activeExtended(element) {
            const extensible = element?.querySelector('.extensible');
            extensible?.classList.add('extended');
        }
    }

    return DHSheetV2;
}

const { DocumentSheetV2 } = foundry.applications.api;

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

/**
 * Base settings sheet for Daggerheart actors.
 * @extends {DHApplicationMixin<DocumentSheetV2>}
 */
class DHBaseActorSettings extends DHApplicationMixin(DocumentSheetV2) {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['dialog'],
        window: {
            icon: 'fa-solid fa-wrench',
            resizable: false,
            title: 'DAGGERHEART.GENERAL.Tabs.settings'
        },
        position: { width: 455, height: 'auto' },
        actions: {},
        form: {
            submitOnChange: true
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /** @inheritDoc */
    _initializeApplicationOptions(options) {
        options = super._initializeApplicationOptions(options);
        options.classes = options.classes.filter(c => c !== 'sheet');
        return options;
    }

    /**@returns {foundry.documents.Actor} */
    get actor() {
        return this.document;
    }

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.isNPC = this.actor.isNPC;

        if (context.systemFields.attack)
            context.systemFields.attack.fields = this.actor.system.attack.schema.fields;

        return context;
    }
}

const { ActorSheetV2 } = foundry.applications.sheets;

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

/**
 * A base actor sheet extending {@link ActorSheetV2} via {@link DHApplicationMixin}
 */
class DHBaseActorSheet extends DHApplicationMixin(ActorSheetV2) {
    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['actor'],
        position: {
            width: 480
        },
        form: {
            submitOnChange: true
        },
        actions: {
            openSettings: DHBaseActorSheet.#openSettings,
            sendExpToChat: DHBaseActorSheet.#sendExpToChat,
            increaseActionUses: event => DHBaseActorSheet.#modifyActionUses(event, true)
        },
        contextMenus: [
            {
                handler: DHBaseActorSheet.#getFeatureContextOptions,
                selector: '[data-item-uuid][data-type="feature"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            }
        ],
        dragDrop: [{ dragSelector: '.inventory-item[data-type="attack"]', dropSelector: null }]
    };

    /* -------------------------------------------- */

    /**@type {typeof DHBaseActorSettings}*/
    #settingSheet;

    /**@returns {DHBaseActorSettings|null} */
    get settingSheet() {
        const SheetClass = this.document.system.metadata.settingSheet;
        return (this.#settingSheet ??= SheetClass ? new SheetClass({ document: this.document }) : null);
    }

    get isVisible() {
        const viewPermission = this.document.testUserPermission(game.user, this.options.viewPermission);
        const limitedOnly = this.document.testUserPermission(game.user, this.options.viewPermission, { exact: true });
        return limitedOnly ? this.document.system.metadata.hasLimitedView : viewPermission;
    }

    /* -------------------------------------------- */
    /*  Prepare Context                             */
    /* -------------------------------------------- */

    /**@inheritdoc */
    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.isNPC = this.document.isNPC;
        context.useResourcePips = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.appearance
        ).useResourcePips;
        context.showAttribution = !game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance)
            .hideAttribution;

        // Prepare inventory data
        if (['party', 'character'].includes(this.document.type)) {
            context.inventory = {
                currencies: {},
                weapons: this.document.itemTypes.weapon.sort((a, b) => a.sort - b.sort),
                armor: this.document.itemTypes.armor.sort((a, b) => a.sort - b.sort),
                consumables: this.document.itemTypes.consumable.sort((a, b) => a.sort - b.sort),
                loot: this.document.itemTypes.loot.sort((a, b) => a.sort - b.sort)
            };
            const { title, ...currencies } = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.Homebrew
            ).currency;
            for (const key in currencies) {
                context.inventory.currencies[key] = {
                    ...currencies[key],
                    field: context.systemFields.gold.fields[key],
                    value: context.source.system.gold[key]
                };
            }
        }

        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'effects':
                await this._prepareEffectsContext(context, options);
                break;
        }
        return context;
    }

    _configureRenderParts(options) {
        const parts = super._configureRenderParts(options);
        if (!this.document.system.metadata.hasLimitedView) return parts;

        if (this.document.testUserPermission(game.user, 'LIMITED', { exact: true })) return { limited: parts.limited };

        return Object.keys(parts).reduce((acc, key) => {
            if (key !== 'limited') acc[key] = parts[key];

            return acc;
        }, {});
    }

    /** @inheritDoc */
    async _onRender(context, options) {
        await super._onRender(context, options);

        if (
            this.document.system.metadata.hasLimitedView &&
            this.document.testUserPermission(game.user, 'LIMITED', { exact: true })
        ) {
            this.element.classList = `${this.element.classList} limited`;
        }
    }

    /**@inheritdoc */
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.item-button .action-uses-button').forEach(element => {
            element.addEventListener('contextmenu', DHBaseActorSheet.#modifyActionUses);
        });
    }

    /**
     * Prepare render context for the Effect part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareEffectsContext(context, _options) {
        context.effects = {
            actives: [],
            inactives: []
        };

        for (const effect of this.actor.allApplicableEffects()) {
            const list = effect.active ? context.effects.actives : context.effects.inactives;
            list.push(effect);
        }
    }

    /* -------------------------------------------- */
    /*  Context Menu                                */
    /* -------------------------------------------- */

    /**
     * Get the set of ContextMenu options for Features.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {DHBaseActorSheet}
     * @protected
     */
    static #getFeatureContextOptions() {
        return this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true });
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Open the Actor Setting Sheet
     * @type {ApplicationClickAction}
     */
    static async #openSettings() {
        await this.settingSheet.render({ force: true });
    }

    /**
     * Send Experience to Chat
     * @type {ApplicationClickAction}
     */
    static async #sendExpToChat(_, button) {
        const experience = this.document.system.experiences[button.dataset.id];
        const cls = getDocumentClass('ChatMessage');

        const systemData = {
            actor: { name: this.actor.name, img: this.actor.img },
            author: game.users.get(game.user.id),
            action: {
                name: `${experience.name} ${experience.value.signedString()}`,
                img: '/icons/sundries/misc/admission-ticket-blue.webp'
            },
            itemOrigin: {
                name: game.i18n.localize('DAGGERHEART.GENERAL.Experience.single')
            },
            description: experience.description
        };

        const msg = {
            user: game.user.id,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/action.hbs',
                systemData
            ),
            title: game.i18n.localize('DAGGERHEART.ACTIONS.Config.displayInChat'),
            speaker: cls.getSpeaker(),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);
    }

    /**
     *
     */
    static async #modifyActionUses(event, increase) {
        event.stopPropagation();
        event.preventDefault();
        const actionId = event.target.dataset.itemUuid;
        const action = await foundry.utils.fromUuid(actionId);

        const newValue = (action.uses.value ?? 0) + (increase ? 1 : -1);
        await action.update({ 'uses.value': Math.min(Math.max(newValue, 0), action.uses.max ?? 0) });
    }

    /* -------------------------------------------- */
    /*  Application Drag/Drop                       */
    /* -------------------------------------------- */

    async _onDropItem(event, item) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        const physicalActorTypes = ['character', 'party'];
        const originActor = item.actor;
        if (
            item.actor?.uuid === this.document.uuid ||
            !originActor ||
            !physicalActorTypes.includes(this.document.type)
        ) {
            return super._onDropItem(event, item);
        }

        /* Handling transfer of inventoryItems */
        if (item.system.metadata.isInventoryItem) {
            if (item.system.metadata.isQuantifiable) {
                const actorItem = originActor.items.get(data.originId);
                const quantityTransfered =
                    actorItem.system.quantity === 1
                        ? 1
                        : await game.system.api.applications.dialogs.ItemTransferDialog.configure(item);

                if (quantityTransfered) {
                    if (quantityTransfered === actorItem.system.quantity) {
                        await originActor.deleteEmbeddedDocuments('Item', [data.originId]);
                    } else {
                        await actorItem.update({
                            'system.quantity': actorItem.system.quantity - quantityTransfered
                        });
                    }

                    const existingItem = this.document.items.find(x => itemIsIdentical(x, item));
                    if (existingItem) {
                        await existingItem.update({
                            'system.quantity': existingItem.system.quantity + quantityTransfered
                        });
                    } else {
                        const createData = item.toObject();
                        await this.document.createEmbeddedDocuments('Item', [
                            {
                                ...createData,
                                system: {
                                    ...createData.system,
                                    quantity: quantityTransfered
                                }
                            }
                        ]);
                    }
                }
            } else {
                await originActor.deleteEmbeddedDocuments('Item', [data.originId]);
                await this.document.createEmbeddedDocuments('Item', [item.toObject()]);
            }
        }
    }

    /**
     * On dragStart on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDragStart(event) {
        const attackItem = event.currentTarget.closest('.inventory-item[data-type="attack"]');
        if (attackItem) {
            const attackData = {
                type: 'Attack',
                actorUuid: this.document.uuid,
                img: this.document.system.attack.img,
                fromInternal: true
            };
            event.dataTransfer.setData('text/plain', JSON.stringify(attackData));
            event.dataTransfer.setDragImage(attackItem.querySelector('img'), 60, 0);
            return;
        } 
        
        const item = await getDocFromElement(event.target);
        if (item) {
            const dragData = {
                originActor: this.document.uuid,
                originId: item.id,
                type: item.documentName,
                uuid: item.uuid
            };
            event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
        }

        super._onDragStart(event);
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$j, ApplicationV2: ApplicationV2$i } = foundry.applications.api;

/**
 * A UI element which displays the Users defined for this world.
 * Currently active users are always displayed, while inactive users can be displayed on toggle.
 *
 * @extends ApplicationV2
 * @mixes HandlebarsApplication
 */

class ItemBrowser extends HandlebarsApplicationMixin$j(ApplicationV2$i) {
    constructor(options = {}) {
        super(options);
        this.items = [];
        this.fieldFilter = [];
        this.selectedMenu = { path: [], data: null };
        this.config = CONFIG.DH.ITEMBROWSER.compendiumConfig;
        this.presets = {};
        this.compendiumBrowserTypeKey = 'compendiumBrowserDefault';
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        id: 'itemBrowser',
        classes: ['daggerheart', 'dh-style', 'dialog', 'compendium-browser', 'daggerheart-loader'],
        tag: 'div',
        window: {
            frame: true,
            title: 'Compendium Browser',
            icon: 'fa-solid fa-book-atlas',
            positioned: true,
            resizable: true
        },
        actions: {
            selectFolder: this.selectFolder,
            expandContent: this.expandContent,
            resetFilters: this.resetFilters,
            sortList: this.sortList
        },
        position: {
            left: 100,
            width: 850,
            height: 600
        }
    };

    /** @override */
    static PARTS = {
        sidebar: {
            template: 'systems/daggerheart/templates/ui/itemBrowser/sidebar.hbs'
        },
        list: {
            template: 'systems/daggerheart/templates/ui/itemBrowser/itemBrowser.hbs'
        }
    };

    /* -------------------------------------------- */
    /*  Filter Tracking                             */
    /* -------------------------------------------- */

    /**
     * The currently active search filter.
     * @type {foundry.applications.ux.SearchFilter}
     */
    #search = {};

    #input = {};

    /**
     * Tracks which item IDs are currently displayed, organized by filter type and section.
     * @type {{
     *   inventory: {
     *     search: Set<string>,
     *     input: Set<string>
     *   }
     * }}
     */
    #filteredItems = {
        browser: {
            search: new Set(),
            input: new Set()
        }
    };

    /** @inheritDoc */
    async _preRender(context, options) {
        this.presets = options.presets ?? {};
        const noFolder = this.presets?.render?.noFolder;
        if (noFolder === true) {
            this.compendiumBrowserTypeKey = 'compendiumBrowserNoFolder';
        }
        const lite = this.presets?.render?.lite;
        if (lite === true) {
            this.compendiumBrowserTypeKey = 'compendiumBrowserLite';
        }
        const userPresetPosition = game.user.getFlag(
            CONFIG.DH.id,
            CONFIG.DH.FLAGS[`${this.compendiumBrowserTypeKey}`].position
        );

        options.position = userPresetPosition ?? ItemBrowser.DEFAULT_OPTIONS.position;

        if (!userPresetPosition) {
            const width = noFolder === true || lite === true ? 600 : 850;
            if (this.rendered) this.setPosition({ width });
            else options.position.width = width;
        }

        await super._preRender(context, options);
    }

    /** @inheritDoc */
    async _onRender(context, options) {
        await super._onRender(context, options);

        this.element
            .querySelectorAll('[data-action="selectFolder"]')
            .forEach(element =>
                element.classList.toggle('is-selected', element.dataset.folderId === this.selectedMenu.path.join('.'))
            );

        this._createSearchFilter();

        this.element.classList.toggle('lite', this.presets?.render?.lite === true);
        this.element.classList.toggle('no-folder', this.presets?.render?.noFolder === true);
        this.element.classList.toggle('no-filter', this.presets?.render?.noFilter === true);
        this.element.querySelectorAll('.folder-list > [data-action="selectFolder"]').forEach(element => {
            element.hidden =
                this.presets.render?.folders?.length && !this.presets.render.folders.includes(element.dataset.folderId);
        });
    }

    _onPosition(position) {
        game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS[`${this.compendiumBrowserTypeKey}`].position, position);
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('[data-action="selectFolder"]').forEach(element =>
            element.addEventListener('contextmenu', event => {
                event.target.classList.toggle('expanded');
            })
        );
    }

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    /** @override */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.compendiums = this.getCompendiumFolders(foundry.utils.deepClone(this.config));
        context.menu = this.selectedMenu;
        context.formatLabel = this.formatLabel;
        context.formatChoices = this.formatChoices;
        context.items = this.items;
        context.presets = this.presets;
        return context;
    }

    open(presets = {}) {
        this.presets = presets;
        ItemBrowser.selectFolder.call(this);
    }

    getCompendiumFolders(config, parent = null, depth = 0) {
        let folders = [];
        Object.values(config).forEach(c => {
            // if(this.presets.render?.folders?.length && !this.presets.render.folders.includes(c.id)) return;
            const folder = {
                id: c.id,
                label: game.i18n.localize(c.label),
                selected: (!parent || parent.selected) && this.selectedMenu.path[depth] === c.id
            };
            folder.folders = c.folders
                ? ItemBrowser.sortBy(this.getCompendiumFolders(c.folders, folder, depth + 2), 'label')
                : [];
            folders.push(folder);
        });
        folders.sort((a, b) => a.label.localeCompare(b.label));

        return folders;
    }

    static async selectFolder(_, target) {
        const folderId = target?.dataset?.folderId ?? this.presets.folder,
            folderData = foundry.utils.getProperty(this.config, folderId) ?? {};

        const columns = ItemBrowser.getFolderConfig(folderData).map(col => ({
            ...col,
            label: game.i18n.localize(col.label)
        }));

        this.selectedMenu = {
            path: folderId?.split('.') ?? [],
            data: {
                ...folderData,
                columns: columns
            }
        };

        await this.render({ force: true, presets: this.presets });

        if (this.selectedMenu?.data?.type?.length) this.loadItems();
    }

    _replaceHTML(result, content, options) {
        if (!options.isFirstRender) delete result.sidebar;
        super._replaceHTML(result, content, options);
    }

    loadItems() {
        let loadTimeout = this.toggleLoader(true);

        const promises = [];

        game.packs.forEach(pack => {
            promises.push(
                new Promise(async resolve => {
                    const items = await pack.getDocuments({ type__in: this.selectedMenu?.data?.type });
                    resolve(items);
                })
            );
        });

        Promise.all(promises).then(async result => {
            this.items = ItemBrowser.sortBy(
                result.flatMap(r => r),
                'name'
            );
            this.fieldFilter = this._createFieldFilter();

            if (this.presets?.filter) {
                Object.entries(this.presets.filter).forEach(([k, v]) => {
                    const filter = this.fieldFilter.find(c => c.name === k);
                    if (filter) filter.value = v.value;
                });
                // await this._onInputFilterBrowser();
            }

            const filterList = await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/itemBrowser/filterContainer.hbs',
                {
                    fieldFilter: this.fieldFilter,
                    presets: this.presets,
                    formatChoices: this.formatChoices
                }
            );

            this.element.querySelector('.filter-content .wrapper').innerHTML = filterList;
            const filterContainer = this.element.querySelector('.filter-header > [data-action="expandContent"]');
            if (this.fieldFilter.length === 0) filterContainer.setAttribute('disabled', '');
            else filterContainer.removeAttribute('disabled');

            const itemList = await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/itemBrowser/itemContainer.hbs',
                {
                    items: this.items,
                    menu: this.selectedMenu,
                    formatLabel: this.formatLabel
                }
            );

            this.element.querySelector('.item-list').innerHTML = itemList;

            this._createFilterInputs();
            await this._onInputFilterBrowser();
            this._createDragProcess();

            clearTimeout(loadTimeout);
            this.toggleLoader(false);
        });
    }

    toggleLoader(state) {
        const container = this.element.querySelector('.item-list');
        return setTimeout(() => {
            container.classList.toggle('daggerheart-loader', state);
        }, 100);
    }

    static expandContent(_, target) {
        const parent = target.parentElement;
        parent.classList.toggle('expanded');
    }

    static sortBy(data, property) {
        return data.sort((a, b) => (a[property] > b[property] ? 1 : -1));
    }

    formatLabel(item, field) {
        const property = foundry.utils.getProperty(item, field.key);
        if (Array.isArray(property)) property.join(', ');
        if (typeof field.format !== 'function') return property ?? '-';
        return game.i18n.localize(field.format(property));
    }

    formatChoices(data) {
        if (!data.field.choices) return null;
        const config = {
            choices: data.field.choices
        };
        foundry.data.fields.StringField._prepareChoiceConfig(config);
        return config.options.filter(
            c => data.filtered.includes(c.value) || data.filtered.includes(c.label.toLowerCase())
        );
    }

    _createFieldFilter() {
        const filters = ItemBrowser.getFolderConfig(this.selectedMenu.data, 'filters');
        filters.forEach(f => {
            if (typeof f.field === 'string') f.field = foundry.utils.getProperty(game, f.field);
            else if (typeof f.choices === 'function') {
                f.choices = f.choices(this.items);
            }

            // Clear field label so template uses our custom label parameter
            if (f.field && f.label) {
                f.field.label = undefined;
            }

            f.name ??= f.key;
            f.value = this.presets?.filter?.[f.name]?.value ?? null;
        });
        return filters;
    }

    /* -------------------------------------------- */
    /*  Search Inputs                               */
    /* -------------------------------------------- */

    /**
     * Create and initialize search filter instance.
     *
     * @private
     */
    _createSearchFilter() {
        //Filters could be a application option if needed
        const filters = [
            {
                key: 'browser',
                input: 'input[type="search"].search-input',
                content: '[data-application-part="list"] .item-list',
                callback: this._onSearchFilterBrowser.bind(this)
            }
        ];

        for (const { key, input, content, callback } of filters) {
            const filter = new foundry.applications.ux.SearchFilter({
                inputSelector: input,
                contentSelector: content,
                callback
            });
            filter.bind(this.element);
            this.#search[key] = filter;
        }
    }

    /* -------------------------------------------- */
    /*  Filter Inputs                                */
    /* -------------------------------------------- */

    _createFilterInputs() {
        const inputs = [
            {
                key: 'browser',
                container: '[data-application-part="list"] .filter-content .wrapper',
                content: '[data-application-part="list"] .item-list',
                callback: this._onInputFilterBrowser.bind(this)
            }
        ];

        inputs.forEach(m => {
            const container = this.element.querySelector(m.container);
            if (!container) return (this.#input[m.key] = {});
            const inputs = container.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('change', this._onInputFilterBrowser.bind(this));
            });
            this.#filteredItems[m.key].input = new Set(this.items.map(i => i.id));
            this.#input[m.key] = inputs;
        });
    }

    /**
     * Handle invetory items search and filtering.
     * @param {KeyboardEvent} event  The keyboard input event.
     * @param {string} query         The input search string.
     * @param {RegExp} rgx           The regular expression query that should be matched against.
     * @param {HTMLElement} html     The container to filter items from.
     * @protected
     */
    async _onSearchFilterBrowser(event, query, rgx, html) {
        this.#filteredItems.browser.search.clear();

        for (const li of html.querySelectorAll('.item-container')) {
            const itemUUID = li.dataset.itemUuid,
                item = this.items.find(i => i.uuid === itemUUID);
            if (!item) continue;
            const matchesSearch = !query || foundry.applications.ux.SearchFilter.testQuery(rgx, item.name);
            if (matchesSearch) this.#filteredItems.browser.search.add(item.id);
            const { input } = this.#filteredItems.browser;
            li.hidden = !(input.has(item.id) && matchesSearch);
        }
    }

    /**
     * Callback when filters change
     * @param {PointerEvent} event
     * @param {HTMLElement} html
     */
    async _onInputFilterBrowser(event) {
        this.#filteredItems.browser.input.clear();

        if (event) this.fieldFilter.find(f => f.name === event.target.name).value = event.target.value;

        for (const li of this.element.querySelectorAll('.item-container')) {
            const itemUUID = li.dataset.itemUuid,
                item = this.items.find(i => i.uuid === itemUUID);

            if (!item) continue;

            const matchesMenu =
                this.fieldFilter.length === 0 ||
                this.fieldFilter.every(
                    f => (!f.value && f.value !== false) || ItemBrowser.evaluateFilter(item, this.createFilterData(f))
                );
            if (matchesMenu) this.#filteredItems.browser.input.add(item.id);

            const { search } = this.#filteredItems.browser;
            li.hidden = !((this.#search.browser.query.length === 0 || search.has(item.id)) && matchesMenu);
        }
    }

    /**
     * Foundry evaluateFilter doesn't allow you to match if filter values are included into item data
     * @param {*} obj
     * @param {*} filter
     */
    static evaluateFilter(obj, filter) {
        let docValue = foundry.utils.getProperty(obj, filter.field);
        let filterValue = filter.value;
        switch (filter.operator) {
            case 'contains2':
                filterValue = Array.isArray(filterValue) ? filterValue : [filterValue];
                docValue = Array.isArray(docValue) ? docValue : [docValue];
                return docValue.some(dv => filterValue.includes(dv));
            case 'contains3':
                return docValue.some(f => f.value === filterValue);
            default:
                return foundry.applications.ux.SearchFilter.evaluateFilter(obj, filter);
        }
    }

    createFilterData(filter) {
        return {
            field: filter.key,
            value: isNaN(filter.value)
                ? ['true', 'false'].includes(filter.value)
                    ? filter.value === 'true'
                    : filter.value
                : Number(filter.value),
            operator: filter.operator,
            negate: filter.negate
        };
    }

    static resetFilters() {
        this.render({ force: true });
        this.loadItems();
    }

    static getFolderConfig(folder, property = 'columns') {
        if (!folder) return [];
        return folder[property] ?? CONFIG.DH.ITEMBROWSER.typeConfig[folder.listType]?.[property] ?? [];
    }

    static sortList(_, target) {
        const key = target.dataset.sortKey,
            type = !target.dataset.sortType || target.dataset.sortType === 'DESC' ? 'ASC' : 'DESC',
            itemListContainer = target.closest('.compendium-results').querySelector('.item-list'),
            itemList = itemListContainer.querySelectorAll('.item-container');

        target
            .closest('.item-list-header')
            .querySelectorAll('[data-sort-key]')
            .forEach(b => (b.dataset.sortType = ''));
        target.dataset.sortType = type;

        const newOrder = [...itemList].reverse().sort((a, b) => {
            const aProp = a.querySelector(`[data-item-key="${key}"]`),
                bProp = b.querySelector(`[data-item-key="${key}"]`),
                aValue = isNaN(aProp.innerText) ? aProp.innerText : Number(aProp.innerText),
                bValue = isNaN(bProp.innerText) ? bProp.innerText : Number(bProp.innerText);
            if (type === 'DESC') {
                return aValue < bValue ? 1 : -1;
            } else {
                return aValue > bValue ? 1 : -1;
            }
        });

        itemListContainer.replaceChildren(...newOrder);
    }

    _createDragProcess() {
        new foundry.applications.ux.DragDrop.implementation({
            dragSelector: '.item-container',
            permissions: {
                dragstart: this._canDragStart.bind(this)
            },
            callbacks: {
                dragstart: this._onDragStart.bind(this)
            }
        }).bind(this.element);
    }

    async _onDragStart(event) {
        const { itemUuid } = event.target.closest('[data-item-uuid]').dataset,
            item = await foundry.utils.fromUuid(itemUuid),
            dragData = item.toDragData();
        event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
    }

    _canDragStart() {
        return true;
    }

    static injectSidebarButton(html) {
        if (!game.user.isGM) return;
        const sectionId = html.dataset.tab,
            menus = {
                actors: {
                    folder: 'adversaries',
                    render: {
                        folders: ['adversaries', 'characters', 'environments']
                    }
                },
                items: {
                    folder: 'equipments',
                    render: {
                        noFolder: true
                    }
                },
                compendium: {}
            };

        if (Object.keys(menus).includes(sectionId)) {
            const headerActions = html.querySelector('.header-actions');

            const button = document.createElement('button');
            button.type = 'button';
            button.classList.add('open-compendium-browser');
            button.innerHTML = `
                <i class="fa-solid fa-book-atlas"></i>
                ${game.i18n.localize('DAGGERHEART.UI.Tooltip.compendiumBrowser')}
            `;
            button.addEventListener('click', event => {
                ui.compendiumBrowser.open(menus[sectionId]);
            });

            headerActions.append(button);
        }
    }
}

/**
 * @typedef {Object} FilterItem
 * @property {string} group - The group name this filter belongs to (e.g., "Type").
 * @property {string} name - The display name of the filter (e.g., "Weapons").
 * @property {import("@client/applications/ux/search-filter.mjs").FieldFilter} filter - The filter condition.
 */

class FilterMenu extends foundry.applications.ux.ContextMenu {
    /**
     * Filter Menu
     * @param {HTMLElement} container - Container element
     * @param {string} selector - CSS selector for menu targets
     * @param {Array} menuItems - Array of menu entries
     * @param {Function} callback - Callback when filters change
     * @param {Object} [options] - Additional options
     */
    constructor(container, selector, menuItems, callback, options = {}) {
        // Set default options
        const mergedOptions = {
            eventName: 'click',
            fixed: true,
            ...options,
            jQuery: false
        };

        super(container, selector, menuItems, mergedOptions);

        // Initialize filter states
        this.menuItems = menuItems.map(item => ({
            ...item,
            enabled: false
        }));

        this.callback = callback;
        this.contentElement = container.querySelector(mergedOptions.contentSelector);

        const syntheticEvent = {
            type: 'pointerdown',
            bubbles: true,
            cancelable: true,
            pointerType: 'mouse',
            isPrimary: true,
            button: 0
        };

        this.callback(syntheticEvent, this.contentElement, this.getActiveFilterData());
    }

    /** @inheritdoc */
    async render(target, options = {}) {
        await super.render(target, { ...options, animate: false });

        // Create menu structure
        const menu = document.createElement('menu');
        menu.className = 'filter-menu';

        // Group items by their group property
        const groups = this.#groupItems(this.menuItems);

        // Create sections for each group
        for (const [groupName, items] of Object.entries(groups)) {
            if (!items.length) continue;

            const section = this.#createSection(groupName, items);
            menu.appendChild(section);
        }

        // Update menu and set position
        this.element.replaceChildren(menu);

        menu.addEventListener('click', this.#handleClick.bind(this));

        this._setPosition(this.element, target, options);

        if (options.animate !== false) await this._animate(true);
        return this._onRender(options);
    }

    /**
     * Groups an array of items by their `group`.
     * @param {Array<Object>} items - The array of items to group. Each item is expected to have an optional `group` property.
     * @returns {Object<string, Array<Object>>} An object where keys are group names and values are arrays of items belonging to each group.
     */
    #groupItems(items) {
        return items.reduce((groups, item) => {
            const group = item.group ?? '_none';
            groups[group] = groups[group] || [];
            groups[group].push(item);
            return groups;
        }, {});
    }

    /**
     * Creates a DOM section element for a group of items with corresponding filter buttons.
     * @param {string} groupName - The name of the group, used as the section label.
     * @param {Array<Object>} items - The items to create buttons for. Each item should have:
     * @returns {HTMLDivElement} The section DOM element containing the label and buttons.
     */
    #createSection(groupName, items) {
        const section = document.createElement('fieldset');
        section.className = 'filter-section';

        const header = document.createElement('legend');
        header.textContent = groupName;
        section.appendChild(header);

        const buttons = document.createElement('div');
        buttons.className = 'filter-buttons';

        items.forEach(item => {
            const button = document.createElement('button');
            button.className = `filter-button ${item.enabled ? 'active' : ''}`;
            button.textContent = item.name;
            item.element = button;
            buttons.appendChild(button);
        });

        section.appendChild(buttons);
        return section;
    }

    /**
     * Get filter data from active filters
     * @returns {Array} Array of filter configurations
     */
    getActiveFilterData() {
        return this.menuItems.filter(item => item.enabled).map(item => item.filter);
    }

    /**
     * Handles click events on filter buttons.
     * Toggles the active state of the clicked button and updates the corresponding item's `enabled` state.
     * Then triggers the provided callback with the event, the content element, and the current active filter data.
     * @param {PointerEvent} event - The click event triggered by interacting with a filter button.
     * @returns {void}
     */
    #handleClick(event) {
        event.preventDefault();
        event.stopPropagation();

        const button = event.target.closest('.filter-button');
        if (!button) return;

        const clickedItem = this.menuItems.find(item => item.element === button);
        if (!clickedItem) return;

        const isActive = button.classList.toggle('active');
        clickedItem.enabled = isActive;

        const filters = this.getActiveFilterData();

        if (filters.length > 0) {
            this.target.classList.add('fa-beat', 'active');
        } else {
            this.target.classList.remove('fa-beat', 'active');
        }

        this.callback(event, this.contentElement, filters);
    }

    /**
     * Generate and return a sorted array of inventory filters.
     * @returns {Array<Object>} An array of filter objects, sorted by name within each group.
     */
    static get invetoryFilters() {
        const { OPERATORS } = foundry.applications.ux.SearchFilter;

        const typesFilters = Object.entries(CONFIG.Item.dataModels)
            .filter(([, { metadata }]) => metadata.isInventoryItem)
            .map(([type, { metadata }]) => ({
                group: game.i18n.localize('Type'),
                name: game.i18n.localize(metadata.label),
                filter: {
                    field: 'type',
                    operator: OPERATORS.EQUALS,
                    value: type
                }
            }));

        const burdenFilter = Object.values(CONFIG.DH.GENERAL.burden).map(({ value, label }) => ({
            group: game.i18n.localize('DAGGERHEART.GENERAL.burden'),
            name: game.i18n.localize(label),
            filter: {
                field: 'system.burden',
                operator: OPERATORS.EQUALS,
                value: value
            }
        }));

        const damageTypeFilter = Object.values(CONFIG.DH.GENERAL.damageTypes).map(({ id, abbreviation }) => ({
            group: 'Damage Type', //TODO localize
            name: game.i18n.localize(abbreviation),
            filter: {
                field: 'system.damage.type',
                operator: OPERATORS.EQUALS,
                value: id
            }
        }));

        const sort = arr => game.i18n.sortObjects(arr, 'name');

        return [...sort(typesFilters), ...sort(burdenFilter), ...sort(damageTypeFilter)];
    }

    /**
     * Generate and return a sorted array of inventory filters.
     * @returns {Array<Object>} An array of filter objects, sorted by name within each group.
     */
    static get cardsFilters() {
        const { OPERATORS } = foundry.applications.ux.SearchFilter;

        const typesFilters = Object.values(CONFIG.DH.DOMAIN.cardTypes).map(({ id, label }) => ({
            group: game.i18n.localize('Type'),
            name: game.i18n.localize(label),
            filter: {
                field: 'system.type',
                operator: OPERATORS.EQUALS,
                value: id
            }
        }));

        const domainFilter = Object.values(CONFIG.DH.DOMAIN.allDomains()).map(({ id, label }) => ({
            group: game.i18n.localize('DAGGERHEART.GENERAL.Domain.single'),
            name: game.i18n.localize(label),
            filter: {
                field: 'system.domain',
                operator: OPERATORS.EQUALS,
                value: id
            }
        }));

        const sort = arr => game.i18n.sortObjects(arr, 'name');

        return [...sort(typesFilters), ...sort(domainFilter)];
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$i } = foundry.applications.api;
const { AbstractSidebarTab } = foundry.applications.sidebar;
/**
 * The daggerheart menu tab.
 * @extends {AbstractSidebarTab}
 * @mixes HandlebarsApplication
 */
class DaggerheartMenu extends HandlebarsApplicationMixin$i(AbstractSidebarTab) {
    constructor(options) {
        super(options);

        this.refreshSelections = DaggerheartMenu.defaultRefreshSelections();
    }

    static defaultRefreshSelections() {
        return {
            session: { selected: false, label: game.i18n.localize('DAGGERHEART.GENERAL.RefreshType.session') },
            scene: { selected: false, label: game.i18n.localize('DAGGERHEART.GENERAL.RefreshType.scene') },
            longRest: { selected: false, label: game.i18n.localize('DAGGERHEART.GENERAL.RefreshType.longrest') },
            shortRest: { selected: false, label: game.i18n.localize('DAGGERHEART.GENERAL.RefreshType.shortrest') }
        };
    }

    /** @override */
    static DEFAULT_OPTIONS = {
        classes: ['dh-style'],
        window: {
            title: 'SIDEBAR.TabSettings'
        },
        actions: {
            selectRefreshable: DaggerheartMenu.#selectRefreshable,
            refreshActors: DaggerheartMenu.#refreshActors
        }
    };

    /** @override */
    static tabName = 'daggerheartMenu';

    /** @override */
    static PARTS = {
        main: { template: 'systems/daggerheart/templates/sidebar/daggerheart-menu/main.hbs' }
    };

    /* -------------------------------------------- */

    /** @inheritDoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.refreshables = this.refreshSelections;
        context.disableRefresh = Object.values(this.refreshSelections).every(x => !x.selected);

        return context;
    }

    async getRefreshables(types) {
        const refreshedActors = {};
        for (let actor of game.actors) {
            if (['character', 'adversary'].includes(actor.type) && actor.prototypeToken.actorLink) {
                const updates = {};
                for (let item of actor.items) {
                    if (item.system.metadata?.hasResource && refreshIsAllowed(types, item.system.resource?.recovery)) {
                        if (!refreshedActors[actor.id])
                            refreshedActors[actor.id] = { name: actor.name, img: actor.img, refreshed: new Set() };
                        refreshedActors[actor.id].refreshed.add(
                            game.i18n.localize(CONFIG.DH.GENERAL.refreshTypes[item.system.resource.recovery].label)
                        );

                        if (!updates[item.id]?.system) updates[item.id] = { system: {} };

                        const increasing =
                            item.system.resource.progression === CONFIG.DH.ITEM.itemResourceProgression.increasing.id;
                        updates[item.id].system = {
                            ...updates[item.id].system,
                            'resource.value': increasing
                                ? 0
                                : Roll.replaceFormulaData(item.system.resource.max, actor.getRollData())
                        };
                    }
                    if (item.system.metadata?.hasActions) {
                        const refreshTypes = new Set();
                        const actions = item.system.actions.filter(action => {
                            if (refreshIsAllowed(types, action.uses.recovery)) {
                                refreshTypes.add(action.uses.recovery);
                                return true;
                            }

                            return false;
                        });
                        if (actions.length === 0) continue;

                        if (!refreshedActors[actor.id])
                            refreshedActors[actor.id] = { name: actor.name, img: actor.img, refreshed: new Set() };
                        refreshedActors[actor.id].refreshed.add(
                            ...refreshTypes.map(type => game.i18n.localize(CONFIG.DH.GENERAL.refreshTypes[type].label))
                        );

                        if (!updates[item.id]?.system) updates[item.id] = { system: {} };

                        updates[item.id].system = {
                            ...updates[item.id].system,
                            ...actions.reduce(
                                (acc, action) => {
                                    acc.actions[action.id] = { 'uses.value': 0 };
                                    return acc;
                                },
                                { actions: updates[item.id].system.actions ?? {} }
                            )
                        };
                    }
                }

                for (let key in updates) {
                    const update = updates[key];
                    await actor.items.get(key).update(update);
                }
            }
        }

        return refreshedActors;
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    static async #selectRefreshable(_event, button) {
        const { type } = button.dataset;
        this.refreshSelections[type].selected = !this.refreshSelections[type].selected;
        this.render();
    }

    static async #refreshActors() {
        const refreshKeys = Object.keys(this.refreshSelections).filter(key => this.refreshSelections[key].selected);
        await this.getRefreshables(refreshKeys);
        const types = refreshKeys.map(x => this.refreshSelections[x].label).join(', ');
        ui.notifications.info(
            game.i18n.format('DAGGERHEART.UI.Notifications.gmMenuRefresh', {
                types: `[${types}]`
            })
        );
        this.refreshSelections = DaggerheartMenu.defaultRefreshSelections();

        const cls = getDocumentClass('ChatMessage');
        const msg = {
            user: game.user.id,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/refreshMessage.hbs',
                {
                    types: types
                }
            ),
            title: game.i18n.localize('DAGGERHEART.UI.Chat.refreshMessage.title'),
            speaker: cls.getSpeaker()
        };

        cls.create(msg);

        this.render();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$h, ApplicationV2: ApplicationV2$h } = foundry.applications.api;

class GroupRollDialog extends HandlebarsApplicationMixin$h(ApplicationV2$h) {
    constructor(actors) {
        super();
        this.actors = actors;
        this.actorLeader = {};
        this.actorsMembers = [];
    }

    get title() {
        return 'Group Roll';
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'dh-style', 'dialog', 'group-roll'],
        position: { width: 'auto', height: 'auto' },
        window: {
            title: 'DAGGERHEART.UI.Chat.groupRoll.title'
        },
        actions: {
            roll: GroupRollDialog.#roll,
            removeLeader: GroupRollDialog.#removeLeader,
            removeMember: GroupRollDialog.#removeMember
        },
        form: { handler: this.updateData, submitOnChange: true, closeOnSubmit: false }
    };

    static PARTS = {
        application: {
            id: 'group-roll',
            template: 'systems/daggerheart/templates/dialogs/group-roll/group-roll.hbs'
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        const leaderChoices = this.actors.filter(x => this.actorsMembers.every(member => member.actor?.id !== x.id));
        const memberChoices = this.actors.filter(
            x => this.actorLeader?.actor?.id !== x.id && this.actorsMembers.every(member => member.actor?.id !== x.id)
        );

        htmlElement.querySelectorAll('.leader-change-input').forEach(element => {
            autocomplete({
                input: element,
                fetch: function (text, update) {
                    if (!text) {
                        update(leaderChoices);
                    } else {
                        text = text.toLowerCase();
                        var suggestions = leaderChoices.filter(n => n.name.toLowerCase().includes(text));
                        update(suggestions);
                    }
                },
                render: function (actor, search) {
                    const actorName = game.i18n.localize(actor.name);
                    const matchIndex = actorName.toLowerCase().indexOf(search);

                    const beforeText = actorName.slice(0, matchIndex);
                    const matchText = actorName.slice(matchIndex, matchIndex + search.length);
                    const after = actorName.slice(matchIndex + search.length, actorName.length);
                    const img = document.createElement('img');
                    img.src = actor.img;

                    const element = document.createElement('li');
                    element.appendChild(img);

                    const label = document.createElement('span');
                    label.innerHTML = `${beforeText}${matchText ? `<strong>${matchText}</strong>` : ''}${after}`;
                    element.appendChild(label);

                    return element;
                },
                renderGroup: function (label) {
                    const itemElement = document.createElement('div');
                    itemElement.textContent = game.i18n.localize(label);
                    return itemElement;
                },
                onSelect: actor => {
                    element.value = actor.uuid;
                    this.actorLeader = { actor: actor, trait: 'agility', difficulty: 0 };
                    this.render();
                },
                click: e => e.fetch(),
                customize: function (_input, _inputRect, container) {
                    container.style.zIndex = foundry.applications.api.ApplicationV2._maxZ;
                },
                minLength: 0
            });
        });

        htmlElement.querySelectorAll('.team-push-input').forEach(element => {
            autocomplete({
                input: element,
                fetch: function (text, update) {
                    if (!text) {
                        update(memberChoices);
                    } else {
                        text = text.toLowerCase();
                        var suggestions = memberChoices.filter(n => n.name.toLowerCase().includes(text));
                        update(suggestions);
                    }
                },
                render: function (actor, search) {
                    const actorName = game.i18n.localize(actor.name);
                    const matchIndex = actorName.toLowerCase().indexOf(search);

                    const beforeText = actorName.slice(0, matchIndex);
                    const matchText = actorName.slice(matchIndex, matchIndex + search.length);
                    const after = actorName.slice(matchIndex + search.length, actorName.length);
                    const img = document.createElement('img');
                    img.src = actor.img;

                    const element = document.createElement('li');
                    element.appendChild(img);

                    const label = document.createElement('span');
                    label.innerHTML = `${beforeText}${matchText ? `<strong>${matchText}</strong>` : ''}${after}`;
                    element.appendChild(label);

                    return element;
                },
                renderGroup: function (label) {
                    const itemElement = document.createElement('div');
                    itemElement.textContent = game.i18n.localize(label);
                    return itemElement;
                },
                onSelect: actor => {
                    element.value = actor.uuid;
                    this.actorsMembers.push({ actor: actor, trait: 'agility', difficulty: 0 });
                    this.render({ force: true });
                },
                click: e => e.fetch(),
                customize: function (_input, _inputRect, container) {
                    container.style.zIndex = foundry.applications.api.ApplicationV2._maxZ;
                },
                minLength: 0
            });
        });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.leader = this.actorLeader;
        context.members = this.actorsMembers;
        context.traitList = abilities;

        context.allSelected = this.actorsMembers.length + (this.actorLeader?.actor ? 1 : 0) === this.actors.length;
        context.rollDisabled = context.members.length === 0 || !this.actorLeader?.actor;

        return context;
    }

    static updateData(event, _, formData) {
        const { actorLeader, actorsMembers } = foundry.utils.expandObject(formData.object);
        this.actorLeader = foundry.utils.mergeObject(this.actorLeader, actorLeader);
        this.actorsMembers = foundry.utils.mergeObject(this.actorsMembers, actorsMembers);
        this.render(true);
    }

    static async #removeLeader(_, button) {
        this.actorLeader = null;
        this.render();
    }

    static async #removeMember(_, button) {
        this.actorsMembers = this.actorsMembers.filter(m => m.actor.uuid !== button.dataset.memberUuid);
        this.render();
    }

    static async #roll() {
        const cls = getDocumentClass('ChatMessage');
        const systemData = {
            leader: this.actorLeader,
            members: this.actorsMembers
        };
        const msg = {
            type: 'groupRoll',
            user: game.user.id,
            speaker: cls.getSpeaker(),
            title: game.i18n.localize('DAGGERHEART.UI.Chat.groupRoll.title'),
            system: systemData,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/groupRoll.hbs',
                { system: systemData }
            )
        };

        cls.create(msg);
        this.close();
    }
}

class DhLevelTiers extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            tiers: new fields.TypedObjectField(new fields.EmbeddedDataField(DhLevelTier))
        };
    }

    get availableChoicesPerLevel() {
        return Object.values(this.tiers).reduce((acc, tier) => {
            for (var level = tier.levels.start; level < tier.levels.end + 1; level++) {
                acc[level] = tier.availableOptions;
            }

            return acc;
        }, {});
    }
}

class DhLevelTier extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            tier: new fields.NumberField({ required: true, integer: true }),
            name: new fields.StringField({ required: true }),
            levels: new fields.SchemaField({
                start: new fields.NumberField({ required: true, integer: true }),
                end: new fields.NumberField({ required: true, integer: true })
            }),
            initialAchievements: new fields.SchemaField({
                experience: new fields.SchemaField({
                    nr: new fields.NumberField({ required: true, initial: 1 }),
                    modifier: new fields.NumberField({ required: true, initial: 2 })
                }),
                proficiency: new fields.NumberField({ integer: true, initial: 1 })
            }),
            availableOptions: new fields.NumberField({ required: true, initial: 2 }),
            domainCardByLevel: new fields.NumberField({ initial: 1 }),
            options: new fields.TypedObjectField(new fields.EmbeddedDataField(DhLevelOption))
        };
    }
}

class DhLevelOption extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            label: new fields.StringField({ required: true }),
            checkboxSelections: new fields.NumberField({ required: true, integer: true, initial: 1 }),
            minCost: new fields.NumberField({ required: true, integer: true, initial: 1 }),
            type: new fields.StringField({ required: true, choices: LevelOptionType }),
            value: new fields.NumberField({ integer: true }),
            amount: new fields.NumberField({ integer: true })
        };
    }
}

const CompanionLevelOptionType = {
    hope: {
        id: 'hope',
        label: 'Light In The Dark'
    },
    creatureComfort: {
        id: 'creatureComfort',
        label: 'Creature Comfort',
        features: [
            {
                name: 'DAGGERHEART.APPLICATIONS.Levelup.actions.creatureComfort.name',
                img: 'icons/magic/life/heart-cross-purple-orange.webp',
                description: 'DAGGERHEART.APPLICATIONS.Levelup.actions.creatureComfort.description',
                toPartner: true
            }
        ]
    },
    armored: {
        id: 'armored',
        label: 'Armored',
        features: [
            {
                name: 'DAGGERHEART.APPLICATIONS.Levelup.actions.armored.name',
                img: 'icons/equipment/shield/kite-wooden-oak-glow.webp',
                description: 'DAGGERHEART.APPLICATIONS.Levelup.actions.armored.description',
                toPartner: true
            }
        ]
    },
    vicious: {
        id: 'vicious',
        label: 'Viscious'
    },
    resilient: {
        id: 'resilient',
        label: 'Resilient'
    },
    bonded: {
        id: 'bonded',
        label: 'Bonded',
        features: [
            {
                name: 'DAGGERHEART.APPLICATIONS.Levelup.actions.bonded.name',
                img: 'icons/magic/life/heart-red-blue.webp',
                description: 'DAGGERHEART.APPLICATIONS.Levelup.actions.bonded.description',
                toPartner: true
            }
        ]
    },
    aware: {
        id: 'aware',
        label: 'Aware'
    }
};

const LevelOptionType = {
    trait: {
        id: 'trait',
        label: 'Character Trait',
        dataPath: ''
    },
    hitPoint: {
        id: 'hitPoint',
        label: 'Hit Points',
        dataPath: 'resources.hitPoints',
        dataPathData: {
            property: 'max',
            dependencies: ['value']
        }
    },
    stress: {
        id: 'stress',
        label: 'Stress',
        dataPath: 'resources.stress',
        dataPathData: {
            property: 'max',
            dependencies: ['value']
        }
    },
    evasion: {
        id: 'evasion',
        label: 'Evasion',
        dataPath: 'evasion'
    },
    proficiency: {
        id: 'proficiency',
        label: 'Proficiency'
    },
    experience: {
        id: 'experience',
        label: 'Experience'
    },
    domainCard: {
        id: 'domainCard',
        label: 'Domain Card'
    },
    subclass: {
        id: 'subclass',
        label: 'Subclass'
    },
    multiclass: {
        id: 'multiclass',
        label: 'Multiclass'
    },
    ...CompanionLevelOptionType
};

const defaultLevelTiers = {
    tiers: {
        2: {
            tier: 2,
            name: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.name',
            levels: {
                start: 2,
                end: 4
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                },
                proficiency: 1
            },
            availableOptions: 2,
            domainCardByLevel: 1,
            options: {
                trait: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.trait',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.trait.id,
                    amount: 2
                },
                hitPoint: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.hitPoint',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.hitPoint.id,
                    value: 1,
                    value: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.stress',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.experience',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 2
                },
                domainCard: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.domainCard',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.domainCard.id,
                    amount: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.evasion',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 1
                }
            }
        },
        3: {
            tier: 3,
            name: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.name',
            levels: {
                start: 5,
                end: 7
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                },
                proficiency: 1
            },
            availableOptions: 2,
            domainCardByLevel: 1,
            options: {
                trait: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.trait',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.trait.id,
                    amount: 2
                },
                hitPoint: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.hitPoint',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.hitPoint.id,
                    value: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.stress',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.experience',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 2
                },
                domainCard: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.domainCard',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.domainCard.id,
                    amount: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.evasion',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 1
                },
                subclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.subclass',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.subclass.id
                },
                proficiency: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.proficiency',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.proficiency.id,
                    value: 1
                },
                multiclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.multiclass',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.multiclass.id
                }
            }
        },
        4: {
            tier: 4,
            name: 'DAGGERHEART.APPLICATIONS.Levelup.tier4.name',
            levels: {
                start: 8,
                end: 10
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                },
                proficiency: 1
            },
            availableOptions: 2,
            domainCardByLevel: 1,
            options: {
                trait: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.trait',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.trait.id,
                    amount: 2
                },
                hitPoint: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.hitPoint',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.hitPoint.id,
                    value: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.stress',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.experience',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 2
                },
                domainCard: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.domainCard',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.domainCard.id,
                    amount: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.evasion',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 1
                },
                subclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.subclass',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.subclass.id
                },
                proficiency: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.proficiency',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.proficiency.id,
                    value: 1
                },
                multiclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.multiclass',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.multiclass.id
                }
            }
        }
    }
};

const defaultCompanionTier = {
    tiers: {
        2: {
            tier: 2,
            name: 'Companion Choices',
            levels: {
                start: 2,
                end: 10
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                }
            },
            /* Improved this. Quick solution for companions */
            extraAchievements: {
                5: {
                    experience: {
                        nr: 1,
                        modifier: 2
                    }
                },
                8: {
                    experience: {
                        nr: 1,
                        modifier: 2
                    }
                }
            },
            availableOptions: 1,
            domainCardByLevel: 0,
            options: {
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.intelligent',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 1
                },
                hope: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.lightInTheDark',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.hope.id,
                    value: 1
                },
                creatureComfort: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.creatureComfort',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.creatureComfort.id,
                    value: 1
                },
                armored: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.armored',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.armored.id,
                    value: 1
                },
                vicious: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.vicious',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: CompanionLevelOptionType.vicious.id,
                    value: 1,
                    amount: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.resilient',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                bonded: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.bonded',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.bonded.id,
                    value: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.aware',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 2,
                    amount: 1
                }
            }
        }
    }
};

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$g } = foundry.applications.api;

//Just used by action config

function DhpApplicationMixin(Base) {
    return class DhpSheetV2 extends HandlebarsApplicationMixin$g(Base) {
        constructor(options = {}) {
            super(options);

            this._dragDrop = this._createDragDropHandlers();
        }

        _attachPartListeners(partId, htmlElement, options) {
            super._attachPartListeners(partId, htmlElement, options);

            this._dragDrop.forEach(d => d.bind(htmlElement));
        }

        static DEFAULT_OPTIONS = {
            position: {
                width: 480,
                height: 'auto'
            },
            actions: {
                onEditImage: this._onEditImage
            },
            dragDrop: []
        };

        async _prepareContext(_options, objectPath = 'document') {
            const context = await super._prepareContext(_options);
            context.source = this[objectPath];
            context.fields = this[objectPath].schema.fields;
            context.systemFields = this[objectPath].system ? this[objectPath].system.schema.fields : {};

            return context;
        }

        static _onEditImage(event, target) {
            const attr = target.dataset.edit;
            const current = foundry.utils.getProperty(this.document, attr);
            const { img } = this.document.constructor.getDefaultArtwork?.(this.document.toObject()) ?? {};
            const fp = new foundry.applications.apps.FilePicker.implementation({
                current,
                type: 'image',
                redirectToRoot: img ? [img] : [],
                callback: async path => this._updateImage.bind(this)(path),
                top: this.position.top + 40,
                left: this.position.left + 10
            });
            return fp.browse();
        }

        async _updateImage(path) {
            await this.document.update({ img: path });
        }

        _createDragDropHandlers() {
            return this.options.dragDrop.map(d => {
                // d.permissions = {
                //   dragstart: this._canDragStart.bind(this),
                //   drop: this._canDragDrop.bind(this)
                // };
                d.callbacks = {
                    dragstart: this._onDragStart.bind(this),
                    // dragover: this._onDragOver.bind(this),
                    drop: this._onDrop.bind(this)
                };
                return new foundry.applications.ux.DragDrop.implementation(d);
            });
        }

        async _onDragStart(event) {}
        _onDrop(event) {}

        _getTabs(tabs) {
            for (const v of Object.values(tabs)) {
                v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
                v.cssClass = v.active ? 'active' : '';
            }

            return tabs;
        }
    };
}

const { ApplicationV2: ApplicationV2$g } = foundry.applications.api;
class DHActionBaseConfig extends DhpApplicationMixin(ApplicationV2$g) {
    constructor(action) {
        super({});

        this.action = action;
        this.openSection = null;
    }

    get title() {
        return `${game.i18n.localize('DAGGERHEART.GENERAL.Tabs.settings')}: ${this.action.name}`;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dh-style', 'dialog', 'max-800'],
        window: {
            icon: 'fa-solid fa-wrench',
            resizable: false
        },
        position: { width: 600, height: 'auto' },
        actions: {
            toggleSection: this.toggleSection,
            addEffect: this.addEffect,
            removeEffect: this.removeEffect,
            addElement: this.addElement,
            removeElement: this.removeElement,
            editEffect: this.editEffect,
            addDamage: this.addDamage,
            removeDamage: this.removeDamage
        },
        form: {
            handler: this.updateForm,
            submitOnChange: true,
            closeOnSubmit: false
        }
    };

    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        base: {
            id: 'base',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/base.hbs'
        },
        configuration: {
            id: 'configuration',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/configuration.hbs'
        },
        effect: {
            id: 'effect',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/effect.hbs'
        }
    };

    static TABS = {
        base: {
            active: true,
            cssClass: '',
            group: 'primary',
            id: 'base',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.base'
        },
        config: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'config',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.configuration'
        },
        effect: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'effect',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.effects'
        }
    };

    static CLEAN_ARRAYS = ['damage.parts', 'cost', 'effects'];

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
            v.cssClass = v.active ? 'active' : '';
        }

        return tabs;
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options, 'action');
        context.source = this.action.toObject(false);
        context.openSection = this.openSection;
        context.tabs = this._getTabs(this.constructor.TABS);
        context.config = CONFIG.DH;
        if (this.action.damage?.hasOwnProperty('includeBase') && this.action.type === 'attack')
            context.hasBaseDamage = !!this.action.parent.attack;
        context.costOptions = this.getCostOptions();
        context.getRollTypeOptions = this.getRollTypeOptions();
        context.disableOption = this.disableOption.bind(this);
        context.isNPC = this.action.actor?.isNPC;
        context.baseSaveDifficulty = this.action.actor?.baseSaveDifficulty;
        context.baseAttackBonus = this.action.actor?.system.attack?.roll.bonus;
        context.hasRoll = this.action.hasRoll;

        const settingsTiers = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers;
        context.tierOptions = [
            { key: 1, label: game.i18n.localize('DAGGERHEART.GENERAL.Tiers.1') },
            ...Object.values(settingsTiers).map(x => ({ key: x.tier, label: x.name }))
        ];
        return context;
    }

    static toggleSection(_, button) {
        this.openSection = button.dataset.section === this.openSection ? null : button.dataset.section;
        this.render(true);
    }

    getCostOptions() {
        const options = foundry.utils.deepClone(CONFIG.DH.GENERAL.abilityCosts);
        const resource = this.action.parent.resource;
        if (resource) {
            options.resource = {
                label: 'DAGGERHEART.GENERAL.itemResource',
                group: 'Global'
            };
        }

        if (this.action.parent.metadata?.isQuantifiable) {
            options.quantity = {
                label: 'DAGGERHEART.GENERAL.itemQuantity',
                group: 'Global'
            };
        }

        return options;
    }

    getRollTypeOptions() {
        const types = foundry.utils.deepClone(CONFIG.DH.GENERAL.rollTypes);
        if (!this.action.actor) return types;
        Object.values(types).forEach(t => {
            if (this.action.actor.type !== 'character' && t.playerOnly) delete types[t.id];
        });
        return types;
    }

    disableOption(index, costOptions, choices) {
        const filtered = foundry.utils.deepClone(costOptions);
        Object.keys(filtered).forEach(o => {
            if (choices.find((c, idx) => c.type === o && index !== idx)) filtered[o].disabled = true;
        });
        return filtered;
    }

    _prepareSubmitData(_event, formData) {
        const submitData = foundry.utils.expandObject(formData.object);

        const itemAbilityCostKeys = Object.keys(CONFIG.DH.GENERAL.itemAbilityCosts);
        for (const keyPath of this.constructor.CLEAN_ARRAYS) {
            const data = foundry.utils.getProperty(submitData, keyPath);
            const dataValues = data ? Object.values(data) : [];
            if (keyPath === 'cost') {
                for (var value of dataValues) {
                    value.itemId = itemAbilityCostKeys.includes(value.key) ? this.action.parent.parent.id : null;
                }
            }

            if (data) foundry.utils.setProperty(submitData, keyPath, dataValues);
        }
        return submitData;
    }

    static async updateForm(event, _, formData) {
        const submitData = this._prepareSubmitData(event, formData),
            data = foundry.utils.mergeObject(this.action.toObject(), submitData);
        this.action = await this.action.update(data);

        this.sheetUpdate?.(this.action);
        this.render();
    }

    static addElement(event) {
        const data = this.action.toObject(),
            key = event.target.closest('[data-key]').dataset.key;
        if (!this.action[key]) return;

        data[key].push(this.action.defaultValues[key] ?? {});
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static removeElement(event, button) {
        event.stopPropagation();
        const data = this.action.toObject(),
            key = event.target.closest('[data-key]').dataset.key,
            index = button.dataset.index;
        data[key].splice(index, 1);
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static addDamage(_event) {
        if (!this.action.damage.parts) return;
        const data = this.action.toObject(),
            part = {};
        if (this.action.actor?.isNPC) part.value = { multiplier: 'flat' };
        data.damage.parts.push(part);
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static removeDamage(_event, button) {
        if (!this.action.damage.parts) return;
        const data = this.action.toObject(),
            index = button.dataset.index;
        data.damage.parts.splice(index, 1);
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    /** Specific implementation in extending classes **/
    static async addEffect(_event) {}
    static removeEffect(_event, _button) {}
    static editEffect(_event) {}

    async close(options) {
        this.tabGroups.primary = 'base';
        await super.close(options);
    }
}

class DHActionConfig extends DHActionBaseConfig {
    static DEFAULT_OPTIONS = {
        ...DHActionBaseConfig.DEFAULT_OPTIONS,
        actions: {
            ...DHActionBaseConfig.DEFAULT_OPTIONS.actions,
            addEffect: this.addEffect,
            removeEffect: this.removeEffect,
            editEffect: this.editEffect
        }
    };

    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        if (!!this.action.effects) context.effects = this.action.effects.map(e => this.action.item.effects.get(e._id));
        context.getEffectDetails = this.getEffectDetails.bind(this);

        return context;
    }

    static async addEffect(_event) {
        if (!this.action.effects) return;
        const effectData = this._addEffectData.bind(this)();
        const data = this.action.toObject();

        const [created] = await this.action.item.createEmbeddedDocuments('ActiveEffect', [effectData], {
            render: false
        });
        data.effects.push({ _id: created._id });
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
        this.action.item.effects.get(created._id).sheet.render(true);
    }

    /**
     * The data for a newly created applied effect.
     * @returns {object}
     * @protected
     */
    _addEffectData() {
        return {
            name: this.action.item.name,
            img: this.action.item.img,
            origin: this.action.item.uuid,
            transfer: false
        };
    }

    getEffectDetails(id) {
        return this.action.item.effects.get(id);
    }

    static removeEffect(event, button) {
        if (!this.action.effects) return;
        const index = button.dataset.index,
            effectId = this.action.effects[index]._id;
        this.constructor.removeElement.bind(this)(event, button);
        this.action.item.deleteEmbeddedDocuments('ActiveEffect', [effectId]);
    }

    static editEffect(event) {
        const id = event.target.closest('[data-effect-id]')?.dataset?.effectId;
        this.action.item.effects.get(id).sheet.render(true);
    }
}

/**
 * A subclass of ObjectField that represents a mapping of keys to the provided DataField type.
 *
 * @param {DataField} model                    The class of DataField which should be embedded in this field.
 * @param {MappingFieldOptions} [options={}]   Options which configure the behavior of the field.
 * @property {string[]} [initialKeys]          Keys that will be created if no data is provided.
 * @property {MappingFieldInitialValueBuilder} [initialValue]  Function to calculate the initial value for a key.
 * @property {boolean} [initialKeysOnly=false]  Should the keys in the initialized data be limited to the keys provided
 *                                              by `options.initialKeys`?
 */
class MappingField extends foundry.data.fields.ObjectField {
    constructor(model, options) {
        if (!(model instanceof foundry.data.fields.DataField)) {
            throw new Error('MappingField must have a DataField as its contained element');
        }
        super(options);

        /**
         * The embedded DataField definition which is contained in this field.
         * @type {DataField}
         */
        this.model = model;
        model.parent = this;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    static get _defaults() {
        return foundry.utils.mergeObject(super._defaults, {
            initialKeys: null,
            initialValue: null,
            initialKeysOnly: false
        });
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _cleanType(value, options) {
        Object.entries(value).forEach(([k, v]) => {
            if (k.startsWith('-=')) return;
            value[k] = this.model.clean(v, options);
        });
        return value;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    getInitialValue(data) {
        let keys = this.initialKeys;
        const initial = super.getInitialValue(data);
        if (!keys || !foundry.utils.isEmpty(initial)) return initial;
        if (!(keys instanceof Array)) keys = Object.keys(keys);
        for (const key of keys) initial[key] = this._getInitialValueForKey(key);
        return initial;
    }

    /* -------------------------------------------- */

    /**
     * Get the initial value for the provided key.
     * @param {string} key       Key within the object being built.
     * @param {object} [object]  Any existing mapping data.
     * @returns {*}              Initial value based on provided field type.
     */
    _getInitialValueForKey(key, object) {
        const initial = this.model.getInitialValue();
        return this.initialValue?.(key, initial, object) ?? initial;
    }

    /* -------------------------------------------- */

    /** @override */
    _validateType(value, options = {}) {
        if (foundry.utils.getType(value) !== 'Object') throw new Error('must be an Object');
        const errors = this._validateValues(value, options);
        if (!foundry.utils.isEmpty(errors)) {
            const failure = new foundry.data.validation.DataModelValidationFailure();
            failure.elements = Object.entries(errors).map(([id, failure]) => ({ id, failure }));
            throw failure.asError();
        }
    }

    /* -------------------------------------------- */

    /**
     * Validate each value of the object.
     * @param {object} value     The object to validate.
     * @param {object} options   Validation options.
     * @returns {Record<string, Error>}  An object of value-specific errors by key.
     */
    _validateValues(value, options) {
        const errors = {};
        for (const [k, v] of Object.entries(value)) {
            if (k.startsWith('-=')) continue;
            const error = this.model.validate(v, options);
            if (error) errors[k] = error;
        }
        return errors;
    }

    /* -------------------------------------------- */

    /** @override */
    initialize(value, model, options = {}) {
        if (!value) return value;
        const obj = {};
        const initialKeys = this.initialKeys instanceof Array ? this.initialKeys : Object.keys(this.initialKeys ?? {});
        const keys = this.initialKeysOnly ? initialKeys : Object.keys(value);
        for (const key of keys) {
            const data = value[key] ?? this._getInitialValueForKey(key, value);
            obj[key] = this.model.initialize(data, model, options);
        }
        return obj;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _getField(path) {
        if (path.length === 0) return this;
        else if (path.length === 1) return this.model;
        path.shift();
        return this.model._getField(path);
    }
}

/**
 * Specialized collection type for stored actions.
 * @param {DataModel} model     The parent DataModel to which this ActionCollection belongs.
 * @param {Action[]} entries  The actions to store.
 */
class ActionCollection extends Collection {
    constructor(model, entries) {
        super();
        this.#model = model;
        for (const entry of entries) {
            if (!(entry instanceof game.system.api.models.actions.actionsTypes.base)) continue;
            this.set(entry._id, entry);
        }
    }

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /**
     * The parent DataModel to which this ActionCollection belongs.
     * @type {DataModel}
     */
    #model;

    /* -------------------------------------------- */

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /* -------------------------------------------- */

    /**
     * Test the given predicate against every entry in the Collection.
     * @param {function(*, number, ActionCollection): boolean} predicate  The predicate.
     * @returns {boolean}
     */
    every(predicate) {
        return this.reduce((pass, v, i) => pass && predicate(v, i, this), true);
    }

    /* -------------------------------------------- */

    /**
     * Convert the ActionCollection to an array of simple objects.
     * @param {boolean} [source=true]  Draw data for contained Documents from the underlying data source?
     * @returns {object[]}             The extracted array of primitive objects.
     */
    toObject(source = true) {
        return this.map(doc => doc.toObject(source));
    }
}

/* -------------------------------------------- */

/**
 * Field that stores actions.
 */
class ActionsField extends MappingField {
    constructor(options) {
        super(new ActionField(), options);
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    initialize(value, model, options) {
        const actions = Object.values(super.initialize(value, model, options));
        return new ActionCollection(model, actions);
    }
}

/* -------------------------------------------- */

/**
 * Field that stores action data and swaps class based on action type.
 */
class ActionField extends foundry.data.fields.ObjectField {
    getModel(value) {
        return game.system.api.models.actions.actionsTypes[value.type] ?? null;
    }

    /* -------------------------------------------- */

    /** @override */
    _cleanType(value, options) {
        if (!(typeof value === 'object')) value = {};
        const cls = this.getModel(value);
        if (cls) return cls.cleanData(value, options);
        return value;
    }

    /* -------------------------------------------- */

    /** @override */
    initialize(value, model, options = {}) {
        const cls = this.getModel(value);
        if (cls) return new cls(value, { parent: model, ...options });
        return foundry.utils.deepClone(value);
    }

    /* -------------------------------------------- */

    /**
     * Migrate this field's candidate source data.
     * @param {object} sourceData  Candidate source data of the root model.
     * @param {any} fieldData      The value of this field within the source data.
     */
    migrateSource(sourceData, fieldData) {
        const cls = this.getModel(fieldData);
        if (cls) cls.migrateDataSafe(fieldData);
    }
}

/* -------------------------------------------- */

function ActionMixin(Base) {
    class Action extends Base {
        static metadata = Object.freeze({
            name: 'Action',
            label: 'DAGGERHEART.GENERAL.Action.single',
            sheetClass: DHActionConfig
        });

        static _sheets = new Map();

        static get documentName() {
            return this.metadata.name;
        }

        get documentName() {
            return this.constructor.documentName;
        }

        static defaultName() {
            return this.documentName;
        }

        get relativeUUID() {
            return `.Item.${this.item.id}.Action.${this.id}`;
        }

        get uuid() {
            return `${this.item.uuid}.${this.documentName}.${this.id}`;
        }

        get sheet() {
            if (!this.constructor._sheets.has(this.uuid)) {
                const sheet = new this.constructor.metadata.sheetClass(this);
                this.constructor._sheets.set(this.uuid, sheet);
            }
            return this.constructor._sheets.get(this.uuid);
        }

        get inCollection() {
            return foundry.utils.getProperty(this.parent, this.systemPath) instanceof Collection;
        }

        get remainingUses() {
            if (!this.uses) return null;

            return Math.max(
                (this.uses.max ? itemAbleRollParse(this.uses.max, this.actor) : 0) - (this.uses.value ?? 0),
                0
            );
        }

        static async create(data, operation = {}) {
            const { parent, renderSheet } = operation;
            let { type } = data;
            if (!type || !game.system.api.models.actions.actionsTypes[type]) {
                ({ type } =
                    (await foundry.applications.api.DialogV2.input({
                        window: { title: game.i18n.localize('DAGGERHEART.CONFIG.SelectAction.selectType') },
                        position: { width: 300 },
                        classes: ['daggerheart', 'dh-style'],
                        content: await foundry.applications.handlebars.renderTemplate(
                            'systems/daggerheart/templates/actionTypes/actionType.hbs',
                            {
                                types: CONFIG.DH.ACTIONS.actionTypes,
                                itemName: parent.parent?.name
                            }
                        ),
                        ok: {
                            label: game.i18n.format('DOCUMENT.Create', {
                                type: game.i18n.localize('DAGGERHEART.GENERAL.Action.single')
                            })
                        }
                    })) ?? {});
            }
            if (!type) return;

            const cls = game.system.api.models.actions.actionsTypes[type];
            const action = new cls(
                {
                    type,
                    ...cls.getSourceConfig(parent)
                },
                {
                    parent
                }
            );
            const created = await parent.parent.update({ [`system.actions.${action.id}`]: action.toObject() });
            const newAction = created.system.actions.get(action.id);
            if (!newAction) return null;
            if (renderSheet) newAction.sheet.render({ force: true });
            return newAction;
        }

        async update(updates, options = {}) {
            const isSetting = !this.parent.parent;
            const basePath = isSetting ? this.systemPath : `system.${this.systemPath}`;
            const path = this.inCollection ? `${basePath}.${this.id}` : basePath;
            let result = null;
            if (isSetting) {
                await this.parent.updateSource({ [path]: updates }, options);
                result = this.parent;
            } else {
                result = await this.item.update({ [path]: updates }, options);
            }

            return this.inCollection
                ? foundry.utils.getProperty(result, basePath)?.get(this.id)
                : foundry.utils.getProperty(result, basePath);
        }

        delete() {
            if (!this.inCollection) return this.item;
            const action = foundry.utils.getProperty(this.item, `system.${this.systemPath}`)?.get(this.id);
            if (!action) return this.item;
            this.item.update({ [`system.${this.systemPath}.-=${this.id}`]: null });
            this.constructor._sheets.get(this.uuid)?.close();
        }

        async deleteDialog() {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                        type: game.i18n.localize(`DAGGERHEART.GENERAL.Action.single`),
                        name: this.name
                    })
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', {
                    name: this.name
                })
            });
            if (!confirmed) return;
            return this.delete();
        }

        async toChat(origin) {
            const cls = getDocumentClass('ChatMessage');
            const systemData = {
                title: game.i18n.localize('DAGGERHEART.CONFIG.ActionType.action'),
                origin: origin,
                action: {
                    name: this.name,
                    img: this.baseAction ? this.parent.parent.img : this.img,
                    tags: this.tags ? this.tags : ['Spell', 'Arcana', 'Lv 10']
                },
                itemOrigin: this.item,
                description: this.description || (this.item instanceof Item ? this.item.system.description : '')
            };
            const msg = {
                type: 'abilityUse',
                user: game.user.id,
                actor: { name: this.actor.name, img: this.actor.img },
                author: this.author,
                speaker: cls.getSpeaker(),
                title: game.i18n.localize('DAGGERHEART.UI.Chat.action.title'),
                system: systemData,
                content: await foundry.applications.handlebars.renderTemplate(
                    'systems/daggerheart/templates/ui/chat/action.hbs',
                    systemData
                ),
                flags: {
                    daggerheart: {
                        cssClass: 'dh-chat-message dh-style'
                    }
                }
            };

            ChatMessage.applyRollMode(msg, game.settings.get('core', 'rollMode'));
            cls.create(msg);
        }
    }

    return Action;
}

/**
 * @typedef {foundry.data.types.StringFieldOptions} StringFieldOptions
 * @typedef {foundry.data.types.DataFieldContext} DataFieldContext
 */

/**
 * @typedef _FormulaFieldOptions
 * @property {boolean} [deterministic] - Is this formula not allowed to have dice values?
 */

/**
 * @typedef {StringFieldOptions & _FormulaFieldOptions} FormulaFieldOptions
 */

/**
 * Special case StringField which represents a formula.
 */
class FormulaField extends foundry.data.fields.StringField {
    /**
     * @param {FormulaFieldOptions} [options] - Options which configure the behavior of the field
     * @param {foundry.data.types.DataFieldContext} [context] - Additional context which describes the field
     */
    constructor(options, context) {
        super(options, context);
    }

    /** @inheritDoc */
    static get _defaults() {
        return foundry.utils.mergeObject(super._defaults, {
            deterministic: false
        });
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _validateType(value) {
        /* A bit suss, but seems to work */
        let roll = null;
        try {
            roll = new Roll(value.replace(/@([a-z.0-9_-]+)/gi, '1'));
        } catch (_) {
            roll = new Roll(value.replace(/@([a-z.0-9_-]+)/gi, 'd6'));
        }
        roll.evaluateSync({ strict: false });
        if (this.options.deterministic && !roll.isDeterministic)
            throw new Error(`must not contain dice terms: ${value}`);
        super._validateType(value);
    }

    /* -------------------------------------------- */
    /*  Active Effect Integration                   */
    /* -------------------------------------------- */

    /** @override */
    _castChangeDelta(delta) {
        return this._cast(delta).trim();
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeAdd(value, delta, model, change) {
        if (!value) return delta;
        const operator = delta.startsWith('-') ? '-' : '+';
        delta = delta.replace(/^[+-]/, '').trim();
        return `${value} ${operator} ${delta}`;
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeMultiply(value, delta, model, change) {
        if (!value) return delta;
        const terms = new Roll(value).terms;
        if (terms.length > 1) return `(${value}) * ${delta}`;
        return `${value} * ${delta}`;
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeUpgrade(value, delta, model, change) {
        if (!value) return delta;
        const terms = new Roll(value).terms;
        if (terms.length === 1 && terms[0].fn === 'max') return value.replace(/\)$/, `, ${delta})`);
        return `max(${value}, ${delta})`;
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeDowngrade(value, delta, model, change) {
        if (!value) return delta;
        const terms = new Roll(value).terms;
        if (terms.length === 1 && terms[0].fn === 'min') return value.replace(/\)$/, `, ${delta})`);
        return `min(${value}, ${delta})`;
    }
}

/**
 * Describes metadata about the item data model type
 * @typedef {Object} ItemDataModelMetadata
 * @property {string} label - A localizable label used on application.
 * @property {string} type - The system type that this data model represents.
 * @property {boolean} hasDescription - Indicates whether items of this type have description field
 * @property {boolean} isQuantifiable - Indicates whether items of this type have quantity field
 * @property {boolean} isInventoryItem- Indicates whether items of this type is a Inventory Item
 */


const fields$f = foundry.data.fields;

class BaseDataItem extends foundry.abstract.TypeDataModel {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ITEMS'];

    /** @returns {ItemDataModelMetadata}*/
    static get metadata() {
        return {
            label: 'Base Item',
            type: 'base',
            hasDescription: false,
            hasResource: false,
            isQuantifiable: false,
            isInventoryItem: false,
            hasActions: false,
            hasAttribution: true
        };
    }

    /**@returns {ItemDataModelMetadata}*/
    get metadata() {
        return this.constructor.metadata;
    }

    /** @inheritDoc */
    static defineSchema() {
        const schema = {
            attribution: new fields$f.SchemaField({
                source: new fields$f.StringField(),
                page: new fields$f.NumberField(),
                artist: new fields$f.StringField()
            })
        };

        if (this.metadata.hasDescription) schema.description = new fields$f.HTMLField({ required: true, nullable: true });

        if (this.metadata.hasResource) {
            schema.resource = new fields$f.SchemaField(
                {
                    type: new fields$f.StringField({
                        choices: CONFIG.DH.ITEM.itemResourceTypes,
                        initial: CONFIG.DH.ITEM.itemResourceTypes.simple
                    }),
                    value: new fields$f.NumberField({ integer: true, min: 0, initial: 0 }),
                    max: new FormulaField({ nullable: true, initial: null, deterministic: true }),
                    icon: new fields$f.StringField(),
                    recovery: new fields$f.StringField({
                        choices: CONFIG.DH.GENERAL.refreshTypes,
                        initial: null,
                        nullable: true
                    }),
                    progression: new fields$f.StringField({
                        required: true,
                        choices: CONFIG.DH.ITEM.itemResourceProgression,
                        initial: CONFIG.DH.ITEM.itemResourceProgression.increasing.id
                    }),
                    diceStates: new fields$f.TypedObjectField(
                        new fields$f.SchemaField({
                            value: new fields$f.NumberField({ integer: true, initial: 1, min: 1 }),
                            used: new fields$f.BooleanField({ initial: false })
                        })
                    ),
                    dieFaces: new fields$f.StringField({
                        choices: CONFIG.DH.GENERAL.diceTypes,
                        initial: CONFIG.DH.GENERAL.diceTypes.d4
                    })
                },
                { nullable: true, initial: null }
            );
        }

        if (this.metadata.isQuantifiable)
            schema.quantity = new fields$f.NumberField({ integer: true, initial: 1, min: 0, required: true });

        if (this.metadata.hasActions) schema.actions = new ActionsField();

        return schema;
    }

    /* -------------------------------------------- */

    /**
     * The default icon used for newly created Item documents
     * @type {string}
     */
    static DEFAULT_ICON = null;

    /* -------------------------------------------- */

    /**
     * Convenient access to the item's actor, if it exists.
     * @returns {foundry.documents.Actor | null}
     */
    get actor() {
        return this.parent.actor;
    }

    get actionsList() {
        return this.actions;
    }

    get itemFeatures() {
        return [];
    }

    get attributionLabel() {
        if (!this.attribution) return;

        const { source, page } = this.attribution;
        return [source, page ? `pg ${page}.` : null].filter(x => x).join('. ');
    }

    /**
     * Obtain a data object used to evaluate any dice rolls associated with this Item Type
     * @param {object} [options] - Options which modify the getRollData method.
     * @returns {object}
     */
    getRollData(options = {}) {
        const actorRollData = this.actor?.getRollData() ?? {};
        const data = { ...actorRollData, item: { ...this } };
        return data;
    }

    async _preCreate(data, options, user) {
        // Skip if no initial action is required or actions already exist
        if (this.metadata.hasInitialAction && foundry.utils.isEmpty(this.actions)) {
            const metadataType = this.metadata.type;
            const actionType = { weapon: 'attack' }[metadataType];
            const ActionClass = game.system.api.models.actions.actionsTypes[actionType];

            const action = new ActionClass(
                {
                    _id: foundry.utils.randomID(),
                    type: actionType,
                    name: game.i18n.localize(CONFIG.DH.ACTIONS.actionTypes[actionType].name),
                    ...ActionClass.getSourceConfig(this.parent)
                },
                {
                    parent: this.parent
                }
            );

            this.updateSource({ actions: [action] });
        }

        if (this.actor && this.actor.type === 'character' && this.features) {
            const features = [];
            for (let f of this.features) {
                const fBase = f.item ?? f;
                const feature = fBase.system ? fBase : await foundry.utils.fromUuid(fBase.uuid);
                features.push(
                    foundry.utils.mergeObject(
                        feature.toObject(),
                        {
                            _stats: { compendiumSource: fBase.uuid },
                            system: {
                                originItemType: this.parent.type,
                                identifier: f.item ? f.type : null,
                                multiclassOrigin: this.isMulticlass
                            }
                        },
                        { inplace: false }
                    )
                );
            }

            await this.actor.createEmbeddedDocuments('Item', features);
        }
    }

    async _preUpdate(changed, options, userId) {
        const allowed = await super._preUpdate(changed, options, userId);
        if (allowed === false) return false;

        addLinkedItemsDiff(changed.system?.features, this.features, options);

        const autoSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation);
        const armorChanged =
            changed.system?.marks?.value !== undefined && changed.system.marks.value !== this.marks.value;
        if (armorChanged && autoSettings.resourceScrollTexts && this.parent.parent?.type === 'character') {
            const armorData = getScrollTextData(this.parent.parent.system.resources, changed.system.marks, 'armor');
            options.scrollingTextData = [armorData];
        }
    }

    _onUpdate(changed, options, userId) {
        super._onUpdate(changed, options, userId);

        updateLinkedItemApps(options, this.parent.sheet);

        if (this.parent?.parent && options.scrollingTextData)
            this.parent.parent.queueScrollText(options.scrollingTextData);
    }
}

class DHFeature extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.feature',
            type: 'feature',
            hasDescription: true,
            hasResource: true,
            hasActions: true
        });
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/stars-stack.svg';

    /* -------------------------------------------- */

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            originItemType: new fields.StringField({
                choices: CONFIG.DH.ITEM.featureTypes,
                nullable: true,
                initial: null
            }),
            multiclassOrigin: new fields.BooleanField({ initial: false }),
            identifier: new fields.StringField()
        };
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$f, ApplicationV2: ApplicationV2$f } = foundry.applications.api;

class DhlevelUp extends HandlebarsApplicationMixin$f(ApplicationV2$f) {
    constructor(actor) {
        super({});

        this.actor = actor;

        this._dragDrop = this._createDragDropHandlers();
        this.tabGroups.primary = 'advancements';
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.title', { actor: this.actor.name });
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dialog', 'dh-style', 'levelup'],
        position: { width: 1000, height: 'auto' },
        window: {
            resizable: true,
            icon: 'fa-solid fa-arrow-turn-up'
        },
        actions: {
            save: this.save,
            viewCompendium: this.viewCompendium,
            selectPreview: this.selectPreview,
            selectDomain: this.selectDomain,
            selectSubclass: this.selectSubclass,
            updateCurrentLevel: this.updateCurrentLevel,
            activatePart: this.activatePart
        },
        form: {
            handler: this.updateForm,
            submitOnChange: true,
            closeOnSubmit: false
        },
        dragDrop: [{ dragSelector: null, dropSelector: '.levelup-card-selection .card-preview-container' }]
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/levelup/tabs/tab-navigation.hbs' },
        advancements: {
            template: 'systems/daggerheart/templates/levelup/tabs/advancements.hbs'
        },
        selections: {
            template: 'systems/daggerheart/templates/levelup/tabs/selections.hbs',
            scrollable: ['.levelup-selections-container']
        },
        summary: { template: 'systems/daggerheart/templates/levelup/tabs/summary.hbs' },
        footer: { template: 'systems/daggerheart/templates/levelup/tabs/footer.hbs' }
    };

    static TABS = {
        advancements: {
            active: true,
            cssClass: '',
            group: 'primary',
            id: 'advancements',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.advancement'
        },
        selections: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'selections',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.selections'
        },
        summary: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'summary',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.summary'
        }
    };

    addBonusChoices(levelTiers) {
        for (var tierKey in levelTiers.tiers) {
            const tier = levelTiers.tiers[tierKey];
            tier.maxSelections = [...Array(tier.levels.end - tier.levels.start + 1).keys()].reduce((acc, index) => {
                const level = tier.levels.start + index;
                const bonus = this.actor.system.levelData.level.bonuses[level];
                acc[level] = tier.availableOptions + (bonus ?? 0);

                return acc;
            }, {});
        }

        return levelTiers;
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.levelup = this.levelup;
        context.tabs = this._getTabs(this.constructor.TABS);
        context.levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

        return context;
    }

    async _preparePartContext(partId, context) {
        const currentLevel = this.levelup.levels[this.levelup.currentLevel];
        switch (partId) {
            case 'tabs':
                const previous =
                    this.levelup.currentLevel === this.levelup.startLevel ? null : this.levelup.currentLevel - 1;
                const next = this.levelup.currentLevel === this.levelup.endLevel ? null : this.levelup.currentLevel + 1;
                context.navigate = {
                    previous: {
                        disabled: !previous,
                        label: previous
                            ? game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.navigateLevel', { level: previous })
                            : '',
                        fromSummary: this.tabGroups.primary === 'summary'
                    },
                    next: {
                        disabled: !this.levelup.currentLevelFinished,
                        label: next
                            ? game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.navigateLevel', { level: next })
                            : '',
                        toSummary: !next,
                        show: this.tabGroups.primary !== 'summary'
                    }
                };

                const { selections } = currentLevel.nrSelections;
                context.tabs.advancements.progress = { selected: selections, max: currentLevel.maxSelections };
                context.showTabs = this.tabGroups.primary !== 'summary';
                break;
        }

        return context;
    }

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
            v.cssClass = v.active ? 'active' : '';
        }

        return tabs;
    }

    _createDragDropHandlers() {
        return this.options.dragDrop.map(d => {
            d.callbacks = {
                drop: this._onDrop.bind(this)
            };
            return new foundry.applications.ux.DragDrop.implementation(d);
        });
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        htmlElement
            .querySelectorAll('.selection-checkbox')
            .forEach(element => element.addEventListener('change', this.selectionClick.bind(this)));

        const traitsTagify = htmlElement.querySelector('.levelup-trait-increases');
        if (traitsTagify) {
            tagifyElement(traitsTagify, this.levelup.unmarkedTraits, this.tagifyUpdate('trait').bind(this));
        }

        const experienceIncreaseTagify = htmlElement.querySelector('.levelup-experience-increases');
        if (experienceIncreaseTagify) {
            tagifyElement(
                experienceIncreaseTagify,
                Object.keys(this.actor.system.experiences).reduce((acc, id) => {
                    const experience = this.actor.system.experiences[id];
                    acc.push({ id: id, label: experience.name });

                    return acc;
                }, []),
                this.tagifyUpdate('experience').bind(this)
            );
        }

        this._dragDrop.forEach(d => d.bind(htmlElement));
    }

    tagifyUpdate =
        type =>
        async (_, { option, removed }) => {
            const updatePath = Object.keys(this.levelup.levels[this.levelup.currentLevel].choices).reduce(
                (acc, choiceKey) => {
                    const choice = this.levelup.levels[this.levelup.currentLevel].choices[choiceKey];
                    Object.keys(choice).forEach(checkboxNr => {
                        const checkbox = choice[checkboxNr];
                        if (
                            choiceKey === type &&
                            (removed ? checkbox.data.includes(option) : checkbox.data.length < checkbox.amount)
                        ) {
                            acc = `levels.${this.levelup.currentLevel}.choices.${choiceKey}.${checkboxNr}.data`;
                        }
                    });

                    return acc;
                },
                null
            );

            if (!updatePath) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noSelectionsLeft'));
                return;
            }

            const currentData = foundry.utils.getProperty(this.levelup, updatePath);
            const updatedData = removed ? currentData.filter(x => x !== option) : [...currentData, option];
            await this.levelup.updateSource({ [updatePath]: updatedData });
            this.render();
        };

    static async updateForm(event, _, formData) {
        const { levelup } = foundry.utils.expandObject(formData.object);
        await this.levelup.updateSource(levelup);
        this.render();
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.getDragEventData(event);
        const item = await fromUuid(data.uuid);
        if (event.target.closest('.domain-cards')) {
            const target = event.target.closest('.card-preview-container');
            if (item.type === 'domainCard') {
                const { multiclass } = this.levelup.classUpgradeChoices;
                const isMulticlass = !multiclass ? false : item.system.domain === multiclass.domain;
                if (
                    !this.actor.system.domains.includes(item.system.domain) &&
                    this.levelup.classUpgradeChoices?.multiclass?.domain !== item.system.domain
                ) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.domainCardWrongDomain'));
                    return;
                }

                const levelBase = isMulticlass ? Math.ceil(this.levelup.currentLevel / 2) : this.levelup.currentLevel;
                const levelMax = target.dataset.limit ? Math.min(Number(target.dataset.limit), levelBase) : levelBase;
                if (levelMax < item.system.level) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.domainCardToHighLevel'));
                    return;
                }

                const cardExistsInCharacter = this.actor.items.find(x => x.name === item.name); // Any other way to check? The item is a copy so different ids
                const cardExistsInLevelup = Object.values(this.levelup.levels).some(level => {
                    const achievementExists = Object.values(level.achievements.domainCards).some(
                        card => card.uuid === item.uuid
                    );
                    const advancementExists = Object.keys(level.choices).some(choiceKey => {
                        if (choiceKey !== 'domainCard') return false;
                        const choice = level.choices[choiceKey];
                        return Object.values(choice).some(checkbox => checkbox.data.includes(item.uuid));
                    });

                    return achievementExists || advancementExists;
                });
                if (cardExistsInCharacter || cardExistsInLevelup) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.domainCardDuplicate'));
                    return;
                }

                await this.levelup.updateSource({ [target.dataset.path]: item.uuid });
                this.render();
            }
        } else if (event.target.closest('.multiclass-cards')) {
            const target = event.target.closest('.multiclass-cards');
            if (item.type === 'class') {
                if (item.name === this.actor.system.class.value.name) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.alreadySelectedClass'));
                    return;
                }

                const secondaryData = Object.keys(
                    foundry.utils.getProperty(this.levelup, `${target.dataset.path}.secondaryData`)
                ).reduce((acc, key) => {
                    acc[`-=${key}`] = null;
                    return acc;
                }, {});
                await this.levelup.updateSource({
                    multiclass: {
                        class: item.uuid,
                        level: this.levelup.currentLevel,
                        tier: Number(target.dataset.tier)
                    },
                    [target.dataset.path]: {
                        tier: Number(target.dataset.tier),
                        minCost: Number(target.dataset.minCost),
                        amount: target.dataset.amount ? Number(target.dataset.amount) : null,
                        value: target.dataset.value,
                        type: target.dataset.type,
                        data: item.uuid,
                        secondaryData: secondaryData
                    }
                });
                this.render();
            }
        }
    }

    async selectionClick(event) {
        event.stopPropagation();
        const button = event.currentTarget;

        const update = {};
        if (!button.checked) {
            const basePath = `levels.${this.levelup.currentLevel}.choices`;
            const current = foundry.utils.getProperty(this.levelup, `${basePath}.${button.dataset.option}`);
            if (Number(button.dataset.cost) > 1 || Object.keys(current).length === 1) {
                // Simple handling that doesn't cover potential Custom LevelTiers.
                update[`${basePath}.-=${button.dataset.option}`] = null;
            } else {
                update[`${basePath}.${button.dataset.option}.-=${button.dataset.checkboxNr}`] = null;
            }
        } else {
            if (this.levelup.levels[this.levelup.currentLevel].nrSelections.available < Number(button.dataset.cost)) {
                ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.insufficentAdvancements'));
                this.render();
                return;
            }

            const updateData = {
                tier: Number(button.dataset.tier),
                minCost: Number(button.dataset.cost),
                amount: button.dataset.amount ? Number(button.dataset.amount) : null,
                value: button.dataset.value,
                type: button.dataset.type
            };

            if (button.dataset.type === 'domainCard') {
                updateData.secondaryData = {
                    limit: Math.max(...this.levelup.tiers[button.dataset.tier].belongingLevels)
                };
            }

            update[
                `levels.${this.levelup.currentLevel}.choices.${button.dataset.option}.${button.dataset.checkboxNr}`
            ] = updateData;
        }

        await this.levelup.updateSource(update);
        this.render();
    }

    static async viewCompendium(event, target) {
        const type = target.dataset.compendium ?? target.dataset.type;

        const presets = {
            folder: type,
            render: {
                noFolder: true
            }
        };

        if (type == 'domains') {
            const domains = this.actor.system.domains,
                multiclassDomain = this.levelup.classUpgradeChoices?.multiclass?.domain;
            if (multiclassDomain) {
                if (!domains.includes(x => x === multiclassDomain)) domains.push(multiclassDomain);
            }
            presets.filter = {
                'level.max': { key: 'level.max', value: this.levelup.currentLevel },
                'system.domain': { key: 'system.domain', value: domains }
            };
        }

        ui.compendiumBrowser.open(presets);
    }

    static async selectPreview(_, button) {
        const remove = button.dataset.selected;
        await this.levelup.updateSource({
            [`${button.dataset.path}`]: {
                data: remove ? [] : [button.dataset.uuid],
                secondaryData: {
                    featureState: button.dataset.featureState,
                    isMulticlass: button.dataset.isMulticlass
                }
            }
        });

        this.render();
    }

    static async selectDomain(_, button) {
        const option = foundry.utils.getProperty(this.levelup, button.dataset.path);
        const domain = option.secondaryData.domain ? null : button.dataset.domain;
        const update = { [`${button.dataset.path}.secondaryData.domain`]: domain };

        const domainCards = this.levelup.levels[this.levelup.currentLevel].achievements.domainCards;
        const illegalDomainCards = option.secondaryData.domain
            ? Object.keys(domainCards)
                  .map(key => ({ ...domainCards[key], key }))
                  .filter(
                      x => x.uuid && foundry.utils.fromUuidSync(x.uuid).system.domain === option.secondaryData.domain
                  )
            : [];
        illegalDomainCards.forEach(card => {
            update[`levels.${this.levelup.currentLevel}.achievements.domainCards.${card.key}.uuid`] = null;
        });

        await this.levelup.updateSource(update);
        this.render();
    }

    static async selectSubclass(_, button) {
        const option = foundry.utils.getProperty(this.levelup, button.dataset.path);
        const subclass = option.secondaryData.subclass ? null : button.dataset.subclass;

        await this.levelup.updateSource({
            [`${button.dataset.path}.secondaryData.subclass`]: subclass
        });
        this.render();
    }

    static async updateCurrentLevel(_, button) {
        if (!button.dataset.forward) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.APPLICATIONS.Levelup.delevel.title')
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.delevel.content')
            });

            if (!confirmed) return;

            await this.levelup.updateSource({
                currentLevel: Math.min(this.levelup.currentLevel - 1, this.levelup.startLevel),
                levels: Object.keys(this.levelup.levels).reduce((acc, key) => {
                    const level = this.levelup.levels[key];
                    if (Number(key) === this.levelup.currentLevel) {
                        acc[key] = {
                            achievements: {
                                experiences: getDeleteKeys(level.achievements.experiences, 'name', ''),
                                domainCards: getDeleteKeys(level.achievements.domainCards, 'uuid', null)
                            },
                            choices: getDeleteKeys(level.choices)
                        };
                    }
                    return acc;
                }, {})
            });
        } else {
            await this.levelup.updateSource({
                currentLevel: Math.min(this.levelup.currentLevel + 1, this.levelup.endLevel)
            });
        }

        this.tabGroups.primary = 'advancements';
        this.render();
    }

    static activatePart(_, button) {
        this.tabGroups.primary = button.dataset.part;
        this.render();
    }

    static async save(_, button) {
        button.disabled = true;

        const levelupData = Object.keys(this.levelup.levels).reduce((acc, level) => {
            if (level >= this.levelup.startLevel) {
                acc[level] = this.levelup.levels[level].toObject();
            }

            return acc;
        }, {});

        await this.actor.levelUp(levelupData);

        if (ui.compendiumBrowser) ui.compendiumBrowser.close();
        this.close();
    }
}

class DhLevelup extends foundry.abstract.DataModel {
    static initializeData(levelTierData, pcLevelData) {
        const startLevel = pcLevelData.level.current + 1;
        const currentLevel = pcLevelData.level.current + 1;
        const endLevel = pcLevelData.level.changed;

        const tiers = {};
        const levels = {};
        const tierKeys = Object.keys(levelTierData.tiers);
        tierKeys.forEach(key => {
            const tier = levelTierData.tiers[key];
            const belongingLevels = [];
            for (var i = tier.levels.start; i <= tier.levels.end; i++) {
                if (i <= endLevel) {
                    const initialAchievements = i === tier.levels.start ? tier.initialAchievements : {};
                    const experiences = initialAchievements.experience
                        ? [...Array(initialAchievements.experience.nr).keys()].reduce((acc, _) => {
                              acc[foundry.utils.randomID()] = {
                                  name: '',
                                  modifier: initialAchievements.experience.modifier
                              };
                              return acc;
                          }, {})
                        : {};

                    const domainCards = [...Array(tier.domainCardByLevel).keys()].reduce((acc, _) => {
                        const id = foundry.utils.randomID();
                        acc[id] = { uuid: null, itemUuid: null, level: i };
                        return acc;
                    }, {});

                    levels[i] = DhLevelupLevel.initializeData(pcLevelData.levelups[i], tier.maxSelections[i], {
                        ...initialAchievements,
                        experiences,
                        domainCards
                    });
                }

                belongingLevels.push(i);
            }

            /* Improve. Temporary handling for Companion new experiences */
            Object.keys(tier.extraAchievements ?? {}).forEach(key => {
                const level = Number(key);
                if (level >= startLevel && level <= endLevel) {
                    const levelExtras = tier.extraAchievements[level];
                    if (levelExtras.experience) {
                        levels[level].achievements.experiences[foundry.utils.randomID()] = {
                            name: '',
                            modifier: levelExtras.experience.modifier
                        };
                    }
                }
            });

            tiers[key] = {
                name: tier.name,
                belongingLevels: belongingLevels,
                options: Object.keys(tier.options).reduce((acc, key) => {
                    acc[key] = tier.options[key].toObject?.() ?? tier.options[key];
                    return acc;
                }, {})
            };
        });

        return {
            tiers,
            levels,
            startLevel,
            currentLevel,
            endLevel
        };
    }

    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            tiers: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField({ required: true }),
                    belongingLevels: new fields.ArrayField(new fields.NumberField({ required: true, integer: true })),
                    options: new fields.TypedObjectField(
                        new fields.SchemaField({
                            label: new fields.StringField({ required: true }),
                            checkboxSelections: new fields.NumberField({ required: true, integer: true }),
                            minCost: new fields.NumberField({ required: true, integer: true }),
                            type: new fields.StringField({ required: true, choices: LevelOptionType }),
                            value: new fields.NumberField({ integer: true }),
                            amount: new fields.NumberField({ integer: true })
                        })
                    )
                })
            ),
            levels: new fields.TypedObjectField(new fields.EmbeddedDataField(DhLevelupLevel)),
            startLevel: new fields.NumberField({ required: true, integer: true }),
            currentLevel: new fields.NumberField({ required: true, integer: true }),
            endLevel: new fields.NumberField({ required: true, integer: true })
        };
    }

    #levelFinished(levelKey) {
        const allSelectionsMade = this.levels[levelKey].nrSelections.available === 0;
        const allChoicesMade = Object.keys(this.levels[levelKey].choices).every(choiceKey => {
            const choice = this.levels[levelKey].choices[choiceKey];
            return Object.values(choice).every(checkbox => {
                switch (choiceKey) {
                    case 'trait':
                    case 'experience':
                    case 'domainCard':
                    case 'subclass':
                    case 'vicious':
                        return checkbox.data.length === (checkbox.amount ?? 1);
                    case 'multiclass':
                        const classSelected = checkbox.data.length === 1;
                        const domainSelected = checkbox.secondaryData.domain;
                        const subclassSelected = checkbox.secondaryData.subclass;
                        return classSelected && domainSelected && subclassSelected;
                    default:
                        return true;
                }
            });
        });
        const experiencesSelected = !this.levels[levelKey].achievements.experiences
            ? true
            : Object.values(this.levels[levelKey].achievements.experiences).every(exp => exp.name);
        const domainCardsSelected = Object.values(this.levels[levelKey].achievements.domainCards)
            .filter(x => x.level <= this.endLevel)
            .every(card => card.uuid);
        const allAchievementsSelected = experiencesSelected && domainCardsSelected;

        return allSelectionsMade && allChoicesMade && allAchievementsSelected;
    }

    get currentLevelFinished() {
        return this.#levelFinished(this.currentLevel);
    }

    get allLevelsFinished() {
        return Object.keys(this.levels)
            .filter(level => Number(level) >= this.startLevel)
            .every(this.#levelFinished.bind(this));
    }

    get unmarkedTraits() {
        const possibleLevels = Object.values(this.tiers).reduce((acc, tier) => {
            if (tier.belongingLevels.includes(this.currentLevel)) acc = tier.belongingLevels;
            return acc;
        }, []);

        return Object.keys(this.levels)
            .filter(key => possibleLevels.some(x => x === Number(key)))
            .reduce(
                (acc, levelKey) => {
                    const level = this.levels[levelKey];
                    Object.values(level.choices).forEach(choice =>
                        Object.values(choice).forEach(checkbox => {
                            if (
                                checkbox.type === 'trait' &&
                                checkbox.data.length > 0 &&
                                Number(levelKey) !== this.currentLevel
                            ) {
                                checkbox.data.forEach(data => delete acc[data]);
                            }
                        })
                    );

                    return acc;
                },
                { ...abilities }
            );
    }

    get classUpgradeChoices() {
        let subclasses = [];
        let multiclass = null;
        Object.keys(this.levels).forEach(levelKey => {
            const level = this.levels[levelKey];
            Object.values(level.choices).forEach(choice => {
                Object.values(choice).forEach(checkbox => {
                    if (checkbox.type === 'multiclass') {
                        multiclass = {
                            class: checkbox.data.length > 0 ? checkbox.data[0] : null,
                            domain: checkbox.secondaryData.domain ?? null,
                            subclass: checkbox.secondaryData.subclass ?? null,
                            tier: checkbox.tier,
                            level: levelKey
                        };
                    }
                    if (checkbox.type === 'subclass') {
                        subclasses.push({
                            tier: checkbox.tier,
                            level: levelKey
                        });
                    }
                });
            });
        });
        return { subclasses, multiclass };
    }

    get tiersForRendering() {
        const tierKeys = Object.keys(this.tiers);
        const selections = Object.keys(this.levels).reduce(
            (acc, key) => {
                const level = this.levels[key];
                Object.keys(level.choices).forEach(optionKey => {
                    const choice = level.choices[optionKey];
                    Object.keys(choice).forEach(checkboxNr => {
                        const checkbox = choice[checkboxNr];
                        if (!acc[checkbox.tier][optionKey]) acc[checkbox.tier][optionKey] = {};
                        Object.keys(choice).forEach(checkboxNr => {
                            acc[checkbox.tier][optionKey][checkboxNr] = { ...checkbox, level: Number(key) };
                        });
                    });
                });

                return acc;
            },
            tierKeys.reduce((acc, key) => {
                acc[key] = {};
                return acc;
            }, {})
        );

        const { multiclass, subclasses } = this.classUpgradeChoices;
        return tierKeys.map((tierKey, tierIndex) => {
            const tier = this.tiers[tierKey];
            const multiclassInTier = multiclass?.tier === Number(tierKey);
            const subclassInTier = subclasses.some(x => x.tier === Number(tierKey));

            return {
                name: game.i18n.localize(tier.name),
                active: this.currentLevel >= Math.min(...tier.belongingLevels),
                groups: Object.keys(tier.options).map(optionKey => {
                    const option = tier.options[optionKey];

                    const checkboxes = [...Array(option.checkboxSelections).keys()].flatMap(index => {
                        const checkboxNr = index + 1;
                        const checkboxData = selections[tierKey]?.[optionKey]?.[checkboxNr];
                        const checkbox = { ...option, checkboxNr, tier: tierKey };

                        if (checkboxData) {
                            checkbox.level = checkboxData.level;
                            checkbox.selected = true;
                            checkbox.disabled = checkbox.level !== this.currentLevel;
                        }

                        if (optionKey === 'multiclass') {
                            if ((multiclass && !multiclassInTier) || subclassInTier) {
                                checkbox.disabled = true;
                            }
                        }

                        if (optionKey === 'subclass' && multiclassInTier) {
                            checkbox.disabled = true;
                        }

                        return checkbox;
                    });

                    let label = game.i18n.localize(option.label);
                    if (optionKey === 'domainCard') {
                        const maxLevel = tier.belongingLevels[tier.belongingLevels.length - 1];
                        label = game.i18n.format(option.label, { maxLevel });
                    }

                    return {
                        label: label,
                        checkboxGroups: chunkify(checkboxes, option.minCost, chunkedBoxes => {
                            const anySelected = chunkedBoxes.some(x => x.selected);
                            const anyDisabled = chunkedBoxes.some(x => x.disabled);
                            return {
                                multi: option.minCost > 1,
                                checkboxes: chunkedBoxes.map(x => ({
                                    ...x,
                                    selected: anySelected,
                                    disabled: anyDisabled
                                }))
                            };
                        })
                    };
                })
            };
        });
    }
}

class DhLevelupLevel extends foundry.abstract.DataModel {
    static initializeData(levelData = { selections: [] }, maxSelections, achievements) {
        return {
            maxSelections: maxSelections,
            achievements: {
                experiences: levelData.achievements?.experiences ?? achievements.experiences ?? {},
                domainCards: levelData.achievements?.domainCards
                    ? levelData.achievements.domainCards.reduce((acc, card, index) => {
                          acc[index] = { ...card };
                          return acc;
                      }, {})
                    : (achievements.domainCards ?? {}),
                proficiency: levelData.achievements?.proficiency ?? achievements.proficiency ?? null
            },
            choices: levelData.selections.reduce((acc, data) => {
                if (!acc[data.optionKey]) acc[data.optionKey] = {};
                acc[data.optionKey][data.checkboxNr] = { ...data };

                return acc;
            }, {})
        };
    }

    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            maxSelections: new fields.NumberField({ required: true, integer: true }),
            achievements: new fields.SchemaField({
                experiences: new fields.TypedObjectField(
                    new fields.SchemaField({
                        name: new fields.StringField({ required: true }),
                        modifier: new fields.NumberField({ required: true, integer: true })
                    })
                ),
                domainCards: new fields.TypedObjectField(
                    new fields.SchemaField({
                        uuid: new fields.StringField({ required: true, nullable: true, initial: null }),
                        itemUuid: new fields.StringField({ required: true }),
                        level: new fields.NumberField({ required: true, integer: true })
                    })
                ),
                proficiency: new fields.NumberField({ integer: true })
            }),
            choices: new fields.TypedObjectField(
                new fields.TypedObjectField(
                    new fields.SchemaField({
                        tier: new fields.NumberField({ required: true, integer: true }),
                        minCost: new fields.NumberField({ required: true, integer: true }),
                        amount: new fields.NumberField({ integer: true }),
                        value: new fields.StringField(),
                        data: new fields.ArrayField(new fields.StringField()),
                        secondaryData: new fields.TypedObjectField(new fields.StringField()),
                        type: new fields.StringField({ required: true })
                    })
                )
            )
        };
    }

    get nrSelections() {
        const selections = Object.keys(this.choices).reduce((acc, choiceKey) => {
            const choice = this.choices[choiceKey];
            acc += Object.values(choice).reduce((acc, x) => acc + x.minCost, 0);

            return acc;
        }, 0);

        return {
            selections: selections,
            available: this.maxSelections - selections
        };
    }
}

class DhCompanionLevelUp extends DhlevelUp {
    constructor(actor) {
        super(actor);

        this.levelTiers = this.addBonusChoices(defaultCompanionTier);
        const playerLevelupData = actor.system.levelData;
        this.levelup = new DhLevelup(DhLevelup.initializeData(this.levelTiers, playerLevelupData));
    }

    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        const currentLevel = this.levelup.levels[this.levelup.currentLevel];
        switch (partId) {
            case 'selections':
                const advancementChoices = Object.keys(currentLevel.choices).reduce((acc, choiceKey) => {
                    Object.keys(currentLevel.choices[choiceKey]).forEach(checkboxNr => {
                        const checkbox = currentLevel.choices[choiceKey][checkboxNr];
                        const data = {
                            ...checkbox,
                            path: `levels.${this.levelup.currentLevel}.choices.${choiceKey}.${checkboxNr}`,
                            level: this.levelup.currentLevel
                        };

                        if (!acc[choiceKey]) acc[choiceKey] = [];
                        acc[choiceKey].push(data);
                    });

                    return acc;
                }, {});

                const experienceIncreases = Object.values(advancementChoices.experience ?? {});
                const experienceIncreaseValues = experienceIncreases
                    .filter(exp => exp.data.length > 0)
                    .flatMap(exp => exp.data);
                context.experienceIncreases = {
                    values: experienceIncreaseValues,
                    active: experienceIncreases.length > 0,
                    progress: {
                        selected: experienceIncreaseValues.length,
                        max: experienceIncreases.reduce((acc, exp) => acc + exp.amount, 0)
                    }
                };

                context.newExperiences = Object.keys(currentLevel.achievements.experiences).map(key => {
                    const experience = currentLevel.achievements.experiences[key];
                    return {
                        ...experience,
                        level: this.levelup.currentLevel,
                        key: key
                    };
                });

                context.vicious = advancementChoices.vicious ? Object.values(advancementChoices.vicious) : null;
                context.viciousChoices = {
                    damage: game.i18n.localize('DAGGERHEART.APPLICATIONS.Levelup.selections.viciousDamage'),
                    range: game.i18n.localize('DAGGERHEART.APPLICATIONS.Levelup.selections.viciousRange')
                };

                break;
            case 'summary':
                const levelKeys = Object.keys(this.levelup.levels);
                const actorDamageDice = this.actor.system.attack.damage.parts[0].value.dice;
                const actorRange = this.actor.system.attack.range;

                let achievementExperiences = [];
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    achievementExperiences = level.achievements.experiences
                        ? Object.values(level.achievements.experiences).reduce((acc, experience) => {
                              if (experience.name) acc.push(experience);
                              return acc;
                          }, [])
                        : [];
                }
                context.achievements = {
                    experiences: {
                        values: achievementExperiences,
                        shown: achievementExperiences.length > 0
                    }
                };

                context.achievements = context.achievements.experiences.shown ? context.achievements : undefined;

                const advancement = {};
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    for (var choiceKey of Object.keys(level.choices)) {
                        const choice = level.choices[choiceKey];
                        for (var checkbox of Object.values(choice)) {
                            switch (choiceKey) {
                                case 'stress':
                                case 'evasion':
                                    advancement[choiceKey] = advancement[choiceKey]
                                        ? advancement[choiceKey] + Number(checkbox.value)
                                        : Number(checkbox.value);
                                    break;
                                case 'experience':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                    const data = checkbox.data.map(data => {
                                        const experience = Object.keys(this.actor.system.experiences).find(
                                            x => x === data
                                        );
                                        return this.actor.system.experiences[experience]?.name ?? '';
                                    });
                                    advancement[choiceKey].push({ data: data, value: checkbox.value });
                                    break;
                                case 'vicious':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = { damage: null, range: null };
                                    const isDamage = checkbox.data[0] === 'damage';
                                    const options = isDamage ? diceTypes : range;
                                    const keys = Object.keys(options);
                                    const actorKey = keys.indexOf(isDamage ? actorDamageDice : actorRange);
                                    const currentIndex = advancement[choiceKey][checkbox.data[0]]
                                        ? keys.indexOf(advancement[choiceKey][checkbox.data[0]])
                                        : actorKey;
                                    advancement[choiceKey][checkbox.data[0]] =
                                        options[keys[Math.min(currentIndex + 1, keys.length - 1)]];
                                default:
                                    if (!advancement.simple) advancement.simple = {};
                                    advancement.simple[choiceKey] = game.i18n.localize(
                                        LevelOptionType[checkbox.type].label
                                    );
                                    break;
                            }
                        }
                    }
                }

                context.advancements = {
                    statistics: {
                        stress: {
                            old: this.actor.system.resources.stress.max,
                            new: this.actor.system.resources.stress.max + (advancement.stress ?? 0)
                        },
                        evasion: {
                            old: this.actor.system.evasion,
                            new: this.actor.system.evasion + (advancement.evasion ?? 0)
                        }
                    },
                    experiences:
                        advancement.experience?.flatMap(x => x.data.map(data => ({ name: data, modifier: x.value }))) ??
                        [],
                    vicious: {
                        damage: advancement.vicious?.damage
                            ? {
                                  old: actorDamageDice,
                                  new: advancement.vicious.damage
                              }
                            : null,
                        range: advancement.vicious?.range
                            ? {
                                  old: game.i18n.localize(`DAGGERHEART.CONFIG.Range.${actorRange}.name`),
                                  new: game.i18n.localize(advancement.vicious.range.label)
                              }
                            : null
                    },
                    simple: advancement.simple ?? {}
                };

                context.advancements.statistics.stress.shown =
                    context.advancements.statistics.stress.new > context.advancements.statistics.stress.old;
                context.advancements.statistics.evasion.shown =
                    context.advancements.statistics.evasion.new > context.advancements.statistics.evasion.old;
                context.advancements.statistics.shown =
                    context.advancements.statistics.stress.shown || context.advancements.statistics.evasion.shown;
        }

        return context;
    }
}

class DhpActor extends Actor {
    parties = new Set();

    #scrollTextQueue = [];
    #scrollTextInterval;

    /**
     * Return the first Actor active owner.
     */
    get owner() {
        const user =
            this.hasPlayerOwner && game.users.players.find(u => this.testUserPermission(u, 'OWNER') && u.active);
        if (!user) return game.users.activeGM;
        return user;
    }

    /**
     * Whether this actor is an NPC.
     * @returns {boolean}
     */
    get isNPC() {
        return this.system.metadata.isNPC;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    static migrateData(source) {
        if (source.system?.attack && !source.system.attack.type) source.system.attack.type = 'attack';
        return super.migrateData(source);
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static getDefaultArtwork(actorData) {
        const { type } = actorData;
        const Model = CONFIG.Actor.dataModels[type];
        const img = Model.DEFAULT_ICON ?? this.DEFAULT_ICON;
        return {
            img,
            texture: {
                src: img
            }
        };
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    getEmbeddedDocument(embeddedName, id, options) {
        let doc;
        switch (embeddedName) {
            case 'Action':
                doc = this.system.actions?.get(id);
                if (!doc && this.system.attack?.id === id) doc = this.system.attack;
                break;
            default:
                return super.getEmbeddedDocument(embeddedName, id, options);
        }
        if (options?.strict && !doc) {
            throw new Error(`The key ${id} does not exist in the ${embeddedName} Collection`);
        }
        return doc;
    }

    /**@inheritdoc */
    async _preCreate(data, options, user) {
        if ((await super._preCreate(data, options, user)) === false) return false;

        // Configure prototype token settings
        const prototypeToken = {};
        if (['character', 'companion', 'party'].includes(this.type))
            Object.assign(prototypeToken, {
                sight: { enabled: true },
                actorLink: true,
                disposition: CONST.TOKEN_DISPOSITIONS.FRIENDLY
            });
        this.updateSource({ prototypeToken });
    }

    _onUpdate(changes, options, userId) {
        super._onUpdate(changes, options, userId);
        for (const party of this.parties) {
            party.render();
        }
    }

    _onDelete(options, userId) {
        super._onDelete(options, userId);
        for (const party of this.parties) {
            party.render();
        }
    }

    async updateLevel(newLevel) {
        if (!['character', 'companion'].includes(this.type) || newLevel === this.system.levelData.level.changed) return;

        if (newLevel > this.system.levelData.level.current) {
            const maxLevel = Object.values(
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers
            ).reduce((acc, tier) => Math.max(acc, tier.levels.end), 0);
            if (newLevel > maxLevel) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.tooHighLevel'));
            }

            await this.update({ 'system.levelData.level.changed': Math.min(newLevel, maxLevel) });
        } else {
            const levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

            const usedLevel = Math.max(newLevel, 1);
            if (newLevel < 1) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.tooLowLevel'));
            }

            const updatedLevelups = Object.keys(this.system.levelData.levelups).reduce((acc, level) => {
                if (Number(level) > usedLevel) acc[`-=${level}`] = null;

                return acc;
            }, {});

            if (levelupAuto) {
                const features = [];
                const domainCards = [];
                const experiences = [];
                const subclassFeatureState = { class: null, multiclass: null };
                let multiclass = null;
                Object.keys(this.system.levelData.levelups)
                    .filter(x => x > usedLevel)
                    .forEach(levelKey => {
                        const level = this.system.levelData.levelups[levelKey];
                        const achievementCards = level.achievements.domainCards.map(x => x.itemUuid);
                        const advancementCards = level.selections
                            .filter(x => x.type === 'domainCard')
                            .map(x => x.itemUuid);
                        domainCards.push(...achievementCards, ...advancementCards);
                        experiences.push(...Object.keys(level.achievements.experiences));
                        features.push(...level.selections.flatMap(x => x.features));

                        const subclass = level.selections.find(x => x.type === 'subclass');
                        if (subclass) {
                            const path = subclass.secondaryData.isMulticlass === 'true' ? 'multiclass' : 'class';
                            const subclassState = Number(subclass.secondaryData.featureState) - 1;
                            subclassFeatureState[path] = subclassFeatureState[path]
                                ? Math.min(subclassState, subclassFeatureState[path])
                                : subclassState;
                        }

                        multiclass = level.selections.find(x => x.type === 'multiclass');
                    });

                for (let feature of features) {
                    if (feature.onPartner && !this.system.partner) continue;

                    const document = feature.onPartner ? this.system.partner : this;
                    document.items.get(feature.id)?.delete();
                }

                if (experiences.length > 0) {
                    const getUpdate = () => ({
                        'system.experiences': experiences.reduce((acc, key) => {
                            acc[`-=${key}`] = null;
                            return acc;
                        }, {})
                    });
                    this.update(getUpdate());
                }

                if (subclassFeatureState.class) {
                    this.system.class.subclass.update({ 'system.featureState': subclassFeatureState.class });
                }

                if (subclassFeatureState.multiclass) {
                    this.system.multiclass.subclass.update({ 'system.featureState': subclassFeatureState.multiclass });
                }

                if (multiclass) {
                    const multiclassItem = this.items.find(x => x.uuid === multiclass.itemUuid);
                    const multiclassFeatures = this.items.filter(
                        x => x.system.originItemType === 'class' && x.system.multiclassOrigin
                    );
                    const subclassFeatures = this.items.filter(
                        x => x.system.originItemType === 'subclass' && x.system.multiclassOrigin
                    );

                    this.deleteEmbeddedDocuments(
                        'Item',
                        [multiclassItem, ...multiclassFeatures, ...subclassFeatures].map(x => x.id)
                    );

                    this.update({
                        'system.multiclass': {
                            value: null,
                            subclass: null
                        }
                    });
                }

                for (let domainCard of domainCards) {
                    const itemCard = this.items.find(x => x.uuid === domainCard);
                    itemCard?.delete();
                }
            }

            await this.update({
                system: {
                    levelData: {
                        level: {
                            current: usedLevel,
                            changed: usedLevel
                        },
                        levelups: updatedLevelups
                    }
                }
            });
            this.sheet.render();
        }
    }

    async levelUp(levelupData) {
        const levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

        const levelups = {};
        for (var levelKey of Object.keys(levelupData)) {
            const level = levelupData[levelKey];

            if (levelupAuto) {
                for (var experienceKey in level.achievements.experiences) {
                    const experience = level.achievements.experiences[experienceKey];
                    await this.update({
                        [`system.experiences.${experienceKey}`]: {
                            name: experience.name,
                            value: experience.modifier,
                            core: true
                        }
                    });
                }
            }

            let multiclass = null;
            const featureAdditions = [];
            const domainCards = [];
            const subclassFeatureState = { class: null, multiclass: null };
            const selections = [];
            for (var optionKey of Object.keys(level.choices)) {
                const selection = level.choices[optionKey];
                for (var checkboxNr of Object.keys(selection)) {
                    const checkbox = selection[checkboxNr];

                    const tierOption = LevelOptionType[checkbox.type];
                    if (tierOption.features?.length > 0) {
                        featureAdditions.push({
                            checkbox: {
                                ...checkbox,
                                level: Number(levelKey),
                                optionKey: optionKey,
                                checkboxNr: Number(checkboxNr)
                            },
                            features: tierOption.features
                        });
                    } else if (checkbox.type === 'multiclass') {
                        multiclass = {
                            ...checkbox,
                            level: Number(levelKey),
                            optionKey: optionKey,
                            checkboxNr: Number(checkboxNr)
                        };
                    } else if (checkbox.type === 'domainCard') {
                        domainCards.push({
                            ...checkbox,
                            level: Number(levelKey),
                            optionKey: optionKey,
                            checkboxNr: Number(checkboxNr)
                        });
                    } else {
                        if (checkbox.type === 'subclass') {
                            const path = checkbox.secondaryData.isMulticlass === 'true' ? 'multiclass' : 'class';
                            subclassFeatureState[path] = Math.max(
                                Number(checkbox.secondaryData.featureState),
                                subclassFeatureState[path]
                            );
                        }

                        selections.push({
                            ...checkbox,
                            level: Number(levelKey),
                            optionKey: optionKey,
                            checkboxNr: Number(checkboxNr)
                        });
                    }
                }
            }

            for (var addition of featureAdditions) {
                if (levelupAuto) {
                    for (var featureData of addition.features) {
                        const feature = new DHFeature({
                            ...featureData,
                            description: game.i18n.localize(featureData.description)
                        });

                        const document = featureData.toPartner && this.system.partner ? this.system.partner : this;
                        const embeddedItem = await document.createEmbeddedDocuments('Item', [
                            {
                                ...featureData,
                                name: game.i18n.localize(featureData.name),
                                type: 'feature',
                                system: feature
                            }
                        ]);
                        const newFeature = {
                            onPartner: Boolean(featureData.toPartner && this.system.partner),
                            id: embeddedItem[0].id
                        };
                        addition.checkbox.features = !addition.checkbox.features
                            ? [newFeature]
                            : [...addition.checkbox.features, newFeature];
                    }
                }

                selections.push(addition.checkbox);
            }

            if (multiclass) {
                if (levelupAuto) {
                    const subclassItem = await foundry.utils.fromUuid(multiclass.secondaryData.subclass);
                    const subclassData = subclassItem.toObject();
                    const multiclassItem = await foundry.utils.fromUuid(multiclass.data[0]);
                    const multiclassData = multiclassItem.toObject();

                    const embeddedItem = await this.createEmbeddedDocuments('Item', [
                        {
                            ...multiclassData,
                            uuid: multiclassItem.uuid,
                            _stats: multiclassItem._stats,
                            system: {
                                ...multiclassData.system,
                                features: multiclassData.system.features.filter(x => x.type !== 'hope'),
                                domains: [multiclass.secondaryData.domain],
                                isMulticlass: true
                            }
                        }
                    ]);

                    await this.createEmbeddedDocuments('Item', [
                        {
                            ...subclassData,
                            uuid: subclassItem.uuid,
                            _stats: subclassItem._stats,
                            system: {
                                ...subclassData.system,
                                isMulticlass: true
                            }
                        }
                    ]);
                    selections.push({ ...multiclass, itemUuid: embeddedItem[0].uuid });
                } else {
                    selections.push({ ...multiclass });
                }
            }

            for (var domainCard of domainCards) {
                if (levelupAuto) {
                    const cardItem = await foundry.utils.fromUuid(domainCard.data[0]);
                    const cardData = cardItem.toObject();
                    const embeddedItem = await this.createEmbeddedDocuments('Item', [
                        {
                            ...cardData,
                            uuid: cardItem.uuid,
                            _stats: cardItem._stats,
                            system: {
                                ...cardData.system,
                                inVault: true
                            }
                        }
                    ]);
                    selections.push({ ...domainCard, itemUuid: embeddedItem[0].uuid });
                } else {
                    selections.push({ ...domainCard });
                }
            }

            const achievementDomainCards = [];
            if (levelupAuto) {
                for (var card of Object.values(level.achievements.domainCards)) {
                    const cardItem = await foundry.utils.fromUuid(card.uuid);
                    const cardData = cardItem.toObject();
                    const embeddedItem = await this.createEmbeddedDocuments('Item', [
                        {
                            ...cardData,
                            uuid: cardItem.uuid,
                            _stats: cardItem._stats,
                            system: {
                                ...cardData.system,
                                inVault: true
                            }
                        }
                    ]);
                    card.itemUuid = embeddedItem[0].uuid;
                    achievementDomainCards.push(card);
                }
            }

            if (subclassFeatureState.class) {
                await this.system.class.subclass.update({ 'system.featureState': subclassFeatureState.class });
            }

            if (subclassFeatureState.multiclass) {
                await this.system.multiclass.subclass.update({
                    'system.featureState': subclassFeatureState.multiclass
                });
            }

            levelups[levelKey] = {
                achievements: {
                    ...level.achievements,
                    domainCards: achievementDomainCards
                },
                selections: selections
            };
        }

        const levelChange = this.system.levelData.level.changed - this.system.levelData.level.current;
        await this.update({
            system: {
                levelData: {
                    level: {
                        current: this.system.levelData.level.changed
                    },
                    levelups: levelups
                }
            }
        });
        this.sheet.render();

        if (this.system.companion && !this.system.companion.system.levelData.canLevelUp) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.ACTORS.Character.companionLevelup.confirmTitle')
                },
                content: game.i18n.format('DAGGERHEART.ACTORS.Character.companionLevelup.confirmText', {
                    name: this.system.companion.name,
                    levelChange: levelChange
                })
            });

            if (!confirmed) return;

            await this.system.companion.updateLevel(this.system.companion.system.levelData.level.current + levelChange);
            new DhCompanionLevelUp(this.system.companion).render({ force: true });
        }
    }

    /**
     * @param {object} config
     * @param {Event} config.event
     * @param {string} config.title
     * @param {object} config.roll
     * @param {number} config.roll.modifier
     * @param {boolean} [config.roll.simple=false]
     * @param {string} [config.roll.type]
     * @param {number} [config.roll.difficulty]
     * @param {boolean} [config.hasDamage]
     * @param {boolean} [config.hasEffect]
     * @param {object} [config.chatMessage]
     * @param {string} config.chatMessage.template
     * @param {boolean} [config.chatMessage.mute]
     * @param {object} [config.targets]
     * @param {object} [config.costs]
     */
    async diceRoll(config) {
        config.source = { ...(config.source ?? {}), actor: this.uuid };
        config.data = this.getRollData();
        const rollClass = config.roll.lite ? CONFIG.Dice.daggerheart['DHRoll'] : this.rollClass;
        return await rollClass.build(config);
    }

    get rollClass() {
        return CONFIG.Dice.daggerheart[['character', 'companion'].includes(this.type) ? 'DualityRoll' : 'D20Roll'];
    }

    get baseSaveDifficulty() {
        return this.system.difficulty ?? 10;
    }

    /** @inheritDoc */
    async toggleStatusEffect(statusId, { active, overlay = false } = {}) {
        const status = CONFIG.statusEffects.find(e => e.id === statusId);
        if (!status) throw new Error(`Invalid status ID "${statusId}" provided to Actor#toggleStatusEffect`);
        const existing = [];

        // Find the effect with the static _id of the status effect
        if (status._id) {
            const effect = this.effects.get(status._id);
            if (effect) existing.push(effect.id);
        }

        // If no static _id, find all effects that have this status
        else {
            for (const effect of this.effects) {
                if (effect.statuses.has(status.id)) existing.push(effect.id);
            }
        }

        // Remove the existing effects unless the status effect is forced active
        if (existing.length) {
            if (active) return true;
            await this.deleteEmbeddedDocuments('ActiveEffect', existing);
            return false;
        }

        // Create a new effect unless the status effect is forced inactive
        if (!active && active !== undefined) return;

        const ActiveEffect = getDocumentClass('ActiveEffect');
        const effect = await ActiveEffect.fromStatusEffect(statusId);
        if (overlay) effect.updateSource({ 'flags.core.overlay': true });
        return ActiveEffect.implementation.create(effect, { parent: this, keepId: true });
    }

    /**@inheritdoc */
    getRollData() {
        const rollData = super.getRollData();
        rollData.name = this.name;
        rollData.system = this.system.getRollData();
        rollData.prof = this.system.proficiency ?? 1;
        rollData.cast = this.system.spellcastModifier ?? 1;
        return rollData;
    }

    #canReduceDamage(hpDamage, type) {
        const { stressDamageReduction, disabledArmor } = this.system.rules.damageReduction;
        if (disabledArmor) return false;

        const availableStress = this.system.resources.stress.max - this.system.resources.stress.value;

        const canUseArmor =
            this.system.armor &&
            this.system.armor.system.marks.value < this.system.armorScore &&
            type.every(t => this.system.armorApplicableDamageTypes[t] === true);
        const canUseStress = Object.keys(stressDamageReduction).reduce((acc, x) => {
            const rule = stressDamageReduction[x];
            if (damageKeyToNumber(x) <= hpDamage) return acc || (rule.enabled && availableStress >= rule.cost);
            return acc;
        }, false);

        return canUseArmor || canUseStress;
    }

    async takeDamage(damages, isDirect = false) {
        if (Hooks.call(`${CONFIG.DH.id}.preTakeDamage`, this, damages) === false) return null;

        if (this.type === 'companion') {
            await this.modifyResource([{ value: 1, key: 'stress' }]);
            return;
        }

        const updates = [];

        Object.entries(damages).forEach(([key, damage]) => {
            damage.parts.forEach(part => {
                if (part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id)
                    part.total = this.calculateDamage(part.total, part.damageTypes);
                const update = updates.find(u => u.key === key);
                if (update) {
                    update.value += part.total;
                    update.damageTypes.add(...new Set(part.damageTypes));
                } else updates.push({ value: part.total, key, damageTypes: new Set(part.damageTypes) });
            });
        });

        if (Hooks.call(`${CONFIG.DH.id}.postCalculateDamage`, this, damages) === false) return null;

        if (!updates.length) return;

        const hpDamage = updates.find(u => u.key === CONFIG.DH.GENERAL.healingTypes.hitPoints.id);
        if (hpDamage) {
            hpDamage.value = this.convertDamageToThreshold(hpDamage.value);
            if (
                this.type === 'character' &&
                !isDirect &&
                this.system.armor &&
                this.#canReduceDamage(hpDamage.value, hpDamage.damageTypes)
            ) {
                const armorSlotResult = await this.owner.query(
                    'armorSlot',
                    {
                        actorId: this.uuid,
                        damage: hpDamage.value,
                        type: [...hpDamage.damageTypes]
                    },
                    {
                        timeout: 30000
                    }
                );
                if (armorSlotResult) {
                    const { modifiedDamage, armorSpent, stressSpent } = armorSlotResult;
                    updates.find(u => u.key === 'hitPoints').value = modifiedDamage;
                    if (armorSpent) {
                        const armorUpdate = updates.find(u => u.key === 'armor');
                        if (armorUpdate) armorUpdate.value += armorSpent;
                        else updates.push({ value: armorSpent, key: 'armor' });
                    }
                    if (stressSpent) {
                        const stressUpdate = updates.find(u => u.key === 'stress');
                        if (stressUpdate) stressUpdate.value += stressSpent;
                        else updates.push({ value: stressSpent, key: 'stress' });
                    }
                }
            }
        }

        updates.forEach(
            u =>
                (u.value =
                    u.key === 'fear' || this.system?.resources?.[u.key]?.isReversed === false ? u.value * -1 : u.value)
        );

        await this.modifyResource(updates);

        if (Hooks.call(`${CONFIG.DH.id}.postTakeDamage`, this, updates) === false) return null;

        return updates;
    }

    calculateDamage(baseDamage, type) {
        if (this.canResist(type, 'immunity')) return 0;
        if (this.canResist(type, 'resistance')) baseDamage = Math.ceil(baseDamage / 2);

        const flatReduction = this.getDamageTypeReduction(type);
        const damage = Math.max(baseDamage - (flatReduction ?? 0), 0);

        return damage;
    }

    canResist(type, resistance) {
        if (!type?.length) return false;
        return type.every(t => this.system.resistance[t]?.[resistance] === true);
    }

    getDamageTypeReduction(type) {
        if (!type?.length) return 0;
        const reduction = Object.entries(this.system.resistance).reduce(
            (a, [index, value]) => (type.includes(index) ? Math.min(value.reduction, a) : a),
            Infinity
        );
        return reduction === Infinity ? 0 : reduction;
    }

    async takeHealing(healings) {
        if (Hooks.call(`${CONFIG.DH.id}.preTakeHealing`, this, healings) === false) return null;

        const updates = [];
        Object.entries(healings).forEach(([key, healing]) => {
            healing.parts.forEach(part => {
                const update = updates.find(u => u.key === key);
                if (update) update.value += part.total;
                else updates.push({ value: part.total, key });
            });
        });

        updates.forEach(
            u =>
                (u.value = !(u.key === 'fear' || this.system?.resources?.[u.key]?.isReversed === false)
                    ? u.value * -1
                    : u.value)
        );

        await this.modifyResource(updates);

        if (Hooks.call(`${CONFIG.DH.id}.postTakeHealing`, this, updates) === false) return null;

        return updates;
    }

    async modifyResource(resources) {
        if (!resources?.length) return;

        if (resources.find(r => r.key === 'stress')) this.convertStressDamageToHP(resources);
        let updates = {
            actor: { target: this, resources: {} },
            armor: { target: this.system.armor, resources: {} },
            items: {}
        };

        resources.forEach(r => {
            if (r.itemId) {
                const { path, value } = game.system.api.fields.ActionFields.CostField.getItemIdCostUpdate(r);

                if (
                    r.key === 'quantity' &&
                    r.target.type === 'consumable' &&
                    value === 0 &&
                    r.target.system.destroyOnEmpty
                ) {
                    r.target.delete();
                } else {
                    updates.items[r.key] = {
                        target: r.target,
                        resources: { [path]: value }
                    };
                }
            } else {
                switch (r.key) {
                    case 'fear':
                        ui.resources.updateFear(
                            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear) + r.value
                        );
                        break;
                    case 'armor':
                        if (this.system.armor?.system?.marks) {
                            updates.armor.resources['system.marks.value'] = Math.max(
                                Math.min(this.system.armor.system.marks.value + r.value, this.system.armorScore),
                                0
                            );
                        }
                        break;
                    default:
                        if (this.system.resources?.[r.key]) {
                            updates.actor.resources[`system.resources.${r.key}.value`] = Math.max(
                                Math.min(
                                    this.system.resources[r.key].value + r.value,
                                    this.system.resources[r.key].max
                                ),
                                0
                            );
                        }
                        break;
                }
            }
        });

        Object.keys(updates).forEach(async key => {
            const u = updates[key];
            if (key === 'items') {
                Object.values(u).forEach(async item => {
                    await emitAsGM(
                        GMUpdateEvent.UpdateDocument,
                        item.target.update.bind(item.target),
                        item.resources,
                        item.target.uuid
                    );
                });
            } else {
                if (Object.keys(u.resources).length > 0) {
                    await emitAsGM(
                        GMUpdateEvent.UpdateDocument,
                        u.target.update.bind(u.target),
                        u.resources,
                        u.target.uuid
                    );
                }
            }
        });
    }

    convertDamageToThreshold(damage) {
        return damage >= this.system.damageThresholds.severe ? 3 : damage >= this.system.damageThresholds.major ? 2 : 1;
    }

    convertStressDamageToHP(resources) {
        const stressDamage = resources.find(r => r.key === 'stress'),
            newValue = this.system.resources.stress.value + stressDamage.value;
        if (newValue <= this.system.resources.stress.max) return;
        const hpDamage = resources.find(r => r.key === 'hitPoints');
        if (hpDamage) hpDamage.value++;
        else
            resources.push({
                key: 'hitPoints',
                value: 1
            });
    }

    async toggleDefeated(defeatedState) {
        const settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).defeated;
        const { unconscious, defeated, dead } = CONFIG.DH.GENERAL.conditions();
        const defeatedConditions = new Set([unconscious.id, defeated.id, dead.id]);
        if (!defeatedState) {
            for (let defeatedId of defeatedConditions) {
                await this.toggleStatusEffect(defeatedId, { overlay: settings.overlay, active: defeatedState });
            }
        } else {
            const noDefeatedConditions = this.statuses.intersection(defeatedConditions).size === 0;
            if (noDefeatedConditions) {
                const condition = settings[`${this.type}Default`];
                await this.toggleStatusEffect(condition, { overlay: settings.overlay, active: defeatedState });
            }
        }
    }

    queueScrollText(scrollingTextData) {
        this.#scrollTextQueue.push(...scrollingTextData.map(data => () => createScrollText(this, data)));
        if (!this.#scrollTextInterval) {
            const scrollFunc = this.#scrollTextQueue.pop();
            scrollFunc?.();

            const intervalFunc = () => {
                const scrollFunc = this.#scrollTextQueue.pop();
                scrollFunc?.();
                if (this.#scrollTextQueue.length === 0) {
                    clearInterval(this.#scrollTextInterval);
                    this.#scrollTextInterval = null;
                }
            };

            this.#scrollTextInterval = setInterval(intervalFunc.bind(this), 600);
        }
    }

    /** @inheritdoc */
    async importFromJSON(json) {
        if (!this.type === 'character') return await super.importFromJSON(json);

        if (!CONST.WORLD_DOCUMENT_TYPES.includes(this.documentName)) {
            throw new Error('Only world Documents may be imported');
        }

        const parsedJSON = JSON.parse(json);
        if (foundry.utils.isNewerVersion('1.1.0', parsedJSON._stats.systemVersion)) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.ACTORS.Character.InvalidOldCharacterImportTitle')
                },
                content: game.i18n.localize('DAGGERHEART.ACTORS.Character.InvalidOldCharacterImportText')
            });
            if (!confirmed) return;
        }

        return await super.importFromJSON(json);
    }

    /**
     * Generate an array of localized tag.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [];
        if (this.system._getTags) tags.push(...this.system._getTags());
        return tags;
    }

    /** Get active effects */
    getActiveEffects() {
        const statusMap = new Map(foundry.CONFIG.statusEffects.map(status => [status.id, status]));
        return this.effects
            .filter(x => !x.disabled)
            .reduce((acc, effect) => {
                acc.push(effect);

                const currentStatusActiveEffects = acc.filter(
                    x => x.statuses.size === 1 && x.name === game.i18n.localize(statusMap.get(x.statuses.first()).name)
                );

                for (var status of effect.statuses) {
                    if (!currentStatusActiveEffects.find(x => x.statuses.has(status))) {
                        const statusData = statusMap.get(status);
                        if (statusData) {
                            acc.push({
                                condition: status,
                                appliedBy: game.i18n.localize(effect.name),
                                name: game.i18n.localize(statusData.name),
                                statuses: new Set([status]),
                                img: statusData.icon ?? statusData.img,
                                description: game.i18n.localize(statusData.description),
                                tint: effect.tint
                            });
                        }
                    }
                }

                return acc;
            }, []);
    }

    /* Temporarily copying the foundry method to add a fix to a bug with scenes 
       https://discord.com/channels/170995199584108546/1296292044011995136/1446693077443149856
    */
    getDependentTokens({ scenes, linked = false } = {}) {
        if (this.isToken && !scenes) return [this.token];
        if (scenes) scenes = Array.isArray(scenes) ? scenes : [scenes];
        else scenes = Array.from(this._dependentTokens.keys());

        /* Code to filter out nonexistant scenes */
        scenes = scenes.filter(scene => game.scenes.some(x => x.id === scene.id));

        if (this.isToken) {
            const parent = this.token.parent;
            return scenes.includes(parent) ? [this.token] : [];
        }

        const allTokens = [];
        for (const scene of scenes) {
            if (!scene) continue;
            const tokens = this._dependentTokens.get(scene);
            for (const token of tokens ?? []) {
                if (!linked || token.actorLink) allTokens.push(token);
            }
        }

        return allTokens;
    }
}

const { ApplicationV2: ApplicationV2$e, HandlebarsApplicationMixin: HandlebarsApplicationMixin$e } = foundry.applications.api;

class ActionSelectionDialog extends HandlebarsApplicationMixin$e(ApplicationV2$e) {
    constructor(item, event, options = {}) {
        super(options);
        this.#item = item;
        this.#event = event;
    }

    /* -------------------------------------------- */

    /** @override */
    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dh-style', 'dialog'],
        actions: {
            choose: ActionSelectionDialog.#onChooseAction
        },
        position: {
            width: 400
        }
    };

    /* -------------------------------------------- */

    static PARTS = {
        actions: {
            template: 'systems/daggerheart/templates/dialogs/actionSelect.hbs'
        }
    };

    #item;

    get item() {
        return this.#item;
    }

    #event;

    get event() {
        return this.#event;
    }

    #action;

    get action() {
        return this.#action ?? null;
    }

    /* -------------------------------------------- */

    /** @override */
    get title() {
        return game.i18n.localize('DAGGERHEART.CONFIG.SelectAction.selectAction');
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    async _prepareContext(options) {
        const actions = this.#item.system.actionsList.map(action => ({
                ...action.toObject(),
                id: action.id,
                img: action.baseAction ? action.parent.parent.img : action.img
            })),
            itemName = this.#item.name;
        return {
            ...(await super._prepareContext(options)),
            actions,
            itemName
        };
    }

    static async #onChooseAction(event, button) {
        const { actionId } = button.dataset;
        this.#action = this.#item.system.actionsList.find(a => a._id === actionId);
        Object.defineProperty(this.#event, 'shiftKey', {
            get() {
                return event.shiftKey;
            }
        });
        this.close();
    }

    static create(item, event, options) {
        return new Promise(resolve => {
            const dialog = new this(item, event, options);
            dialog.addEventListener('close', () => resolve(dialog.action), { once: true });
            dialog.render({ force: true });
        });
    }
}

/**
 * Override and extend the basic Item implementation.
 * @extends {foundry.documents.Item}
 */
class DHItem extends foundry.documents.Item {
    /** @inheritDoc */
    prepareEmbeddedDocuments() {
        super.prepareEmbeddedDocuments();
        for (const action of this.system.actions ?? []) action.prepareData();
    }

    /** @inheritDoc */
    getEmbeddedDocument(embeddedName, id, options) {
        let doc;
        switch (embeddedName) {
            case 'Action':
                doc = this.system.actions?.get(id);
                if (!doc && this.system.attack?.id === id) doc = this.system.attack;
                break;
            default:
                return super.getEmbeddedDocument(embeddedName, id, options);
        }
        if (options?.strict && !doc) {
            throw new Error(`The key ${id} does not exist in the ${embeddedName} Collection`);
        }
        return doc;
    }

    static async createDocuments(sources, operation) {
        // Ensure that items being created are valid to the actor its being added to
        const actor = operation.parent;
        sources = actor?.system?.isItemValid ? sources.filter((s) => actor.system.isItemValid(s)) : sources;
        return super.createDocuments(sources, operation);
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    static migrateData(source) {
        if (source.system?.attack && !source.system.attack.type) source.system.attack.type = 'attack';
        return super.migrateData(source);
    }

    /**
     * @inheritdoc
     * @param {object} options - Options which modify the getRollData method.
     * @returns
     */
    getRollData(options = {}) {
        let data;
        if (this.system.getRollData) data = this.system.getRollData(options);
        else {
            const actorRollData = this.actor?.getRollData(options) ?? {};
            data = { ...actorRollData, item: { ...this.system } };
        }

        if (data?.item) {
            data.item.flags = { ...this.flags };
            data.item.name = this.name;
        }
        return data;
    }

    /**
     * Determine if this item is classified as an inventory item based on its metadata.
     * @returns {boolean} Returns `true` if the item is an inventory item.
     */
    get isInventoryItem() {
        return this.system.metadata.isInventoryItem ?? false;
    }

    /** @inheritdoc */
    static async createDialog(data = {}, createOptions = {}, options = {}) {
        const { folders, types, template, context = {}, ...dialogOptions } = options;

        if (types?.length === 0) {
            throw new Error('The array of sub-types to restrict to must not be empty.');
        }

        const documentTypes = this.TYPES.filter(type => type !== 'base' && (!types || types.includes(type))).map(
            type => {
                const labelKey = CONFIG.Item?.typeLabels?.[type];
                const label = labelKey && game.i18n.has(labelKey) ? game.i18n.localize(labelKey) : type;

                const isInventoryItem = CONFIG.Item.dataModels[type]?.metadata?.isInventoryItem;
                const group =
                    isInventoryItem === true
                        ? 'Inventory Items' //TODO localize
                        : isInventoryItem === false
                          ? 'Character Items' //TODO localize
                          : 'Other'; //TODO localize

                return { value: type, label, group };
            }
        );

        if (!documentTypes.length) {
            throw new Error('No document types were permitted to be created.'); //TODO localize
        }

        const sortedTypes = documentTypes.sort((a, b) => a.label.localeCompare(b.label, game.i18n.lang));

        return await super.createDialog(data, createOptions, {
            folders,
            types,
            template,
            context: { types: sortedTypes, ...context },
            ...dialogOptions
        });
    }

    /* -------------------------------------------- */

    /**
     * Generate an array of localized tag.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [];
        if (this.system._getTags) tags.push(...this.system._getTags());
        return tags;
    }

    /**
     * Generate a localized label array for this item.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        if (this.system._getLabels) labels.push(...this.system._getLabels());
        return labels;
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static getDefaultArtwork(itemData) {
        const { type } = itemData;
        const Model = CONFIG.Item.dataModels[type];
        const img = Model.DEFAULT_ICON ?? this.DEFAULT_ICON;
        return { img };
    }

    /* -------------------------------------------- */

    async use(event) {
        const actions = new Set(this.system.actionsList);
        if (actions?.size) {
            let action = actions.first();
            if (actions.size > 1 && !event?.shiftKey) {
                // Actions Choice Dialog
                action = await ActionSelectionDialog.create(this, event);
            }
            if (action) return action.use(event);
        }
    }

    /**
     * Create a new ChatMessage to display this documents data
     * @param {String} origin - uuid of a document. TODO: This needs to be reviewed.
     */
    async toChat(origin) {
        /**@type {foundry.documents.ChatMessage} */
        const cls = getDocumentClass('ChatMessage');
        const item = await foundry.utils.fromUuid(origin);

        const systemData = {
            origin: origin,
            img: this.img,
            item: {
                name: this.name,
                img: this.img,
                tags: this._getTags()
            },
            actions: item.system.actionsList,
            description: this.system.description
        };

        const msg = {
            type: 'abilityUse',
            user: game.user.id,
            actor: item.parent,
            speaker: cls.getSpeaker(),
            system: systemData,
            title: game.i18n.localize('DAGGERHEART.ACTIONS.Config.displayInChat'),
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/ability-use.hbs',
                systemData
            ),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);
    }
}

class Party extends DHBaseActorSheet {
    constructor(options) {
        super(options);

        this.refreshSelections = DaggerheartMenu.defaultRefreshSelections();
    }

    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['party'],
        position: {
            width: 550,
            height: 900
        },
        window: {
            resizable: true
        },
        actions: {
            deletePartyMember: Party.#deletePartyMember,
            deleteItem: Party.#deleteItem,
            toggleHope: Party.#toggleHope,
            toggleHitPoints: Party.#toggleHitPoints,
            toggleStress: Party.#toggleStress,
            toggleArmorSlot: Party.#toggleArmorSlot,
            tempBrowser: Party.#tempBrowser,
            refeshActions: Party.#refeshActions,
            triggerRest: Party.#triggerRest,
            tagTeamRoll: Party.#tagTeamRoll,
            groupRoll: Party.#groupRoll,
            selectRefreshable: DaggerheartMenu.selectRefreshable,
            refreshActors: DaggerheartMenu.refreshActors
        },
        dragDrop: [{ dragSelector: '[data-item-id][draggable="true"]', dropSelector: null }]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/actors/party/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        partyMembers: { template: 'systems/daggerheart/templates/sheets/actors/party/party-members.hbs' },
        resources: {
            template: 'systems/daggerheart/templates/sheets/actors/party/resources.hbs',
            scrollable: ['']
        },
        /* NOT YET IMPLEMENTED */
        // projects: {
        //     template: 'systems/daggerheart/templates/sheets/actors/party/projects.hbs',
        //     scrollable: ['']
        // },
        inventory: {
            template: 'systems/daggerheart/templates/sheets/actors/party/inventory.hbs',
            scrollable: ['.tab.inventory .items-section']
        },
        notes: { template: 'systems/daggerheart/templates/sheets/actors/party/notes.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [
                { id: 'partyMembers' },
                { id: 'resources' },
                /* NOT YET IMPLEMENTED */
                // { id: 'projects' },
                { id: 'inventory' },
                { id: 'notes' }
            ],
            initial: 'partyMembers',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    static ALLOWED_ACTOR_TYPES = ['character', 'companion', 'adversary'];
    static DICE_ROLL_ACTOR_TYPES = ['character'];

    async _onRender(context, options) {
        await super._onRender(context, options);
        this._createFilterMenus();
        this._createSearchFilter();
    }

    /* -------------------------------------------- */
    /*  Prepare Context                             */
    /* -------------------------------------------- */

    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'header':
                await this._prepareHeaderContext(context, options);
                break;
            case 'notes':
                await this._prepareNotesContext(context, options);
                break;
        }
        return context;
    }

    /**
     * Prepare render context for the Header part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareHeaderContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        context.description = await TextEditor.implementation.enrichHTML(system.description, {
            secrets: this.document.isOwner,
            relativeTo: this.document
        });
    }

    /**
     * Prepare render context for the Biography part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareNotesContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        const paths = {
            notes: 'notes'
        };

        for (const [key, path] of Object.entries(paths)) {
            const value = foundry.utils.getProperty(system, path);
            context[key] = {
                field: system.schema.getField(path),
                value,
                enriched: await TextEditor.implementation.enrichHTML(value, {
                    secrets: this.document.isOwner,
                    relativeTo: this.document
                })
            };
        }
    }

    /**
     * Toggles a hope resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleHope(_, target) {
        const hopeValue = Number.parseInt(target.dataset.value);
        const actor = await foundry.utils.fromUuid(target.dataset.actorId);
        const newValue = actor.system.resources.hope.value >= hopeValue ? hopeValue - 1 : hopeValue;
        await actor.update({ 'system.resources.hope.value': newValue });
        this.render();
    }

    /**
     * Toggles a hp resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleHitPoints(_, target) {
        const hitPointsValue = Number.parseInt(target.dataset.value);
        const actor = await foundry.utils.fromUuid(target.dataset.actorId);
        const newValue = actor.system.resources.hitPoints.value >= hitPointsValue ? hitPointsValue - 1 : hitPointsValue;
        await actor.update({ 'system.resources.hitPoints.value': newValue });
        this.render();
    }

    /**
     * Toggles a stress resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleStress(_, target) {
        const stressValue = Number.parseInt(target.dataset.value);
        const actor = await foundry.utils.fromUuid(target.dataset.actorId);
        const newValue = actor.system.resources.stress.value >= stressValue ? stressValue - 1 : stressValue;
        await actor.update({ 'system.resources.stress.value': newValue });
        this.render();
    }

    /**
     * Toggles a armor slot resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleArmorSlot(_, target, element) {
        const armorItem = await foundry.utils.fromUuid(target.dataset.itemUuid);
        const armorValue = Number.parseInt(target.dataset.value);
        const newValue = armorItem.system.marks.value >= armorValue ? armorValue - 1 : armorValue;
        await armorItem.update({ 'system.marks.value': newValue });
        this.render();
    }

    /**
     * Opens Compedium Browser
     */
    static async #tempBrowser(_, target) {
        new ItemBrowser().render({ force: true });
    }

    static async #refeshActions() {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: 'New Section',
                icon: 'fa-solid fa-campground'
            },
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/sidebar/daggerheart-menu/main.hbs',
                {
                    refreshables: DaggerheartMenu.defaultRefreshSelections()
                }
            ),
            classes: ['daggerheart', 'dialog', 'dh-style', 'tab', 'sidebar-tab', 'daggerheartMenu-sidebar']
        });

        if (!confirmed) return;
    }

    static async #triggerRest(_, button) {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.localize(`DAGGERHEART.APPLICATIONS.Downtime.${button.dataset.type}.title`),
                icon: button.dataset.type === 'shortRest' ? 'fa-solid fa-utensils' : 'fa-solid fa-bed'
            },
            content: 'This will trigger a dialog to players make their downtime moves, are you sure?',
            classes: ['daggerheart', 'dialog', 'dh-style']
        });

        if (!confirmed) return;

        this.document.system.partyMembers.forEach(actor => {
            game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.DowntimeTrigger,
                data: {
                    actorId: actor.uuid,
                    downtimeType: button.dataset.type
                }
            });
        });
    }

    static async downtimeMoveQuery({ actorId, downtimeType }) {
        const actor = await foundry.utils.fromUuid(actorId);
        if (!actor || !actor?.isOwner) reject();
        new game.system.api.applications.dialogs.Downtime(actor, downtimeType === 'shortRest').render({
            force: true
        });
    }

    static async #tagTeamRoll() {
        new game.system.api.applications.dialogs.TagTeamDialog(
            this.document.system.partyMembers.filter(x => Party.DICE_ROLL_ACTOR_TYPES.includes(x.type))
        ).render({
            force: true
        });
    }

    static async #groupRoll(_params) {
        new GroupRollDialog(
            this.document.system.partyMembers.filter(x => Party.DICE_ROLL_ACTOR_TYPES.includes(x.type))
        ).render({ force: true });
    }

    /**
     * Get the set of ContextMenu options for Consumable and Loot.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {CharacterSheet}
     * @protected
     */
    static #getItemContextOptions() {
        return this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true });
    }
    /* -------------------------------------------- */
    /*  Filter Tracking                             */
    /* -------------------------------------------- */

    /**
     * The currently active search filter.
     * @type {foundry.applications.ux.SearchFilter}
     */
    #search = {};

    /**
     * The currently active search filter.
     * @type {FilterMenu}
     */
    #menu = {};

    /**
     * Tracks which item IDs are currently displayed, organized by filter type and section.
     * @type {{
     *   inventory: {
     *     search: Set<string>,
     *     menu: Set<string>
     *   },
     *   loadout: {
     *     search: Set<string>,
     *     menu: Set<string>
     *   },
     * }}
     */
    #filteredItems = {
        inventory: {
            search: new Set(),
            menu: new Set()
        },
        loadout: {
            search: new Set(),
            menu: new Set()
        }
    };

    /* -------------------------------------------- */
    /*  Search Inputs                               */
    /* -------------------------------------------- */

    /**
     * Create and initialize search filter instances for the inventory and loadout sections.
     *
     * Sets up two {@link foundry.applications.ux.SearchFilter} instances:
     * - One for the inventory, which filters items in the inventory grid.
     * - One for the loadout, which filters items in the loadout/card grid.
     * @private
     */
    _createSearchFilter() {
        //Filters could be a application option if needed
        const filters = [
            {
                key: 'inventory',
                input: 'input[type="search"].search-inventory',
                content: '[data-application-part="inventory"] .items-section',
                callback: this._onSearchFilterInventory.bind(this)
            }
        ];

        for (const { key, input, content, callback } of filters) {
            const filter = new foundry.applications.ux.SearchFilter({
                inputSelector: input,
                contentSelector: content,
                callback
            });
            filter.bind(this.element);
            this.#search[key] = filter;
        }
    }

    /**
     * Handle invetory items search and filtering.
     * @param {KeyboardEvent} event  The keyboard input event.
     * @param {string} query         The input search string.
     * @param {RegExp} rgx           The regular expression query that should be matched against.
     * @param {HTMLElement} html     The container to filter items from.
     * @protected
     */
    async _onSearchFilterInventory(_event, query, rgx, html) {
        this.#filteredItems.inventory.search.clear();

        for (const li of html.querySelectorAll('.inventory-item')) {
            const item = await getDocFromElement(li);
            const matchesSearch = !query || foundry.applications.ux.SearchFilter.testQuery(rgx, item.name);
            if (matchesSearch) this.#filteredItems.inventory.search.add(item.id);
            const { menu } = this.#filteredItems.inventory;
            li.hidden = !(menu.has(item.id) && matchesSearch);
        }
    }

    /* -------------------------------------------- */
    /*  Filter Menus                                */
    /* -------------------------------------------- */

    _createFilterMenus() {
        //Menus could be a application option if needed
        const menus = [
            {
                key: 'inventory',
                container: '[data-application-part="inventory"]',
                content: '.items-section',
                callback: this._onMenuFilterInventory.bind(this),
                target: '.filter-button',
                filters: FilterMenu.invetoryFilters
            }
        ];

        menus.forEach(m => {
            const container = this.element.querySelector(m.container);
            this.#menu[m.key] = new FilterMenu(container, m.target, m.filters, m.callback, {
                contentSelector: m.content
            });
        });
    }

    /**
     * Callback when filters change
     * @param {PointerEvent} event
     * @param {HTMLElement} html
     * @param {import('../ux/filter-menu.mjs').FilterItem[]} filters
     */
    async _onMenuFilterInventory(_event, html, filters) {
        this.#filteredItems.inventory.menu.clear();

        for (const li of html.querySelectorAll('.inventory-item')) {
            const item = await getDocFromElement(li);

            const matchesMenu =
                filters.length === 0 || filters.some(f => foundry.applications.ux.SearchFilter.evaluateFilter(item, f));
            if (matchesMenu) this.#filteredItems.inventory.menu.add(item.id);

            const { search } = this.#filteredItems.inventory;
            li.hidden = !(search.has(item.id) && matchesMenu);
        }
    }

    /* -------------------------------------------- */

    async _onDropActor(event, document) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        if (document instanceof DhpActor && Party.ALLOWED_ACTOR_TYPES.includes(document.type)) {
            const currentMembers = this.document.system.partyMembers.map(x => x.uuid);
            if (currentMembers.includes(data.uuid)) {
                return ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.duplicateCharacter'));
            }

            await this.document.update({ 'system.partyMembers': [...currentMembers, document.uuid] });
        } else {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.onlyCharactersInPartySheet'));
        }

        return null;
    }

    static async #deletePartyMember(event, target) {
        const doc = await getDocFromElement(target.closest('.inventory-item'));

        if (!event.shiftKey) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                        type: game.i18n.localize('TYPES.Actor.adversary'),
                        name: doc.name
                    })
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: doc.name })
            });

            if (!confirmed) return;
        }

        const currentMembers = this.document.system.partyMembers.map(x => x.uuid);
        const newMemberdList = currentMembers.filter(uuid => uuid !== doc.uuid);
        await this.document.update({ 'system.partyMembers': newMemberdList });
    }

    static async #deleteItem(event, target) {
        const doc = await getDocFromElement(target.closest('.inventory-item'));
        if (!event.shiftKey) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                        type: game.i18n.localize('TYPES.Actor.party'),
                        name: doc.name
                    })
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: doc.name })
            });

            if (!confirmed) return;
        }

        this.document.deleteEmbeddedDocuments('Item', [doc.id]);
    }
}

function handleSocketEvent({ action = null, data = {} } = {}) {
    switch (action) {
        case socketEvent.GMUpdate:
            Hooks.callAll(socketEvent.GMUpdate, data);
            break;
        case socketEvent.DhpFearUpdate:
            Hooks.callAll(socketEvent.DhpFearUpdate);
            break;
        case socketEvent.Refresh:
            Hooks.call(socketEvent.Refresh, data);
            break;
        case socketEvent.DowntimeTrigger:
            Party.downtimeMoveQuery(data);
            break;
    }
}

const socketEvent = {
    GMUpdate: 'DhGMUpdate',
    Refresh: 'DhRefresh',
    DhpFearUpdate: 'DhFearUpdate',
    DowntimeTrigger: 'DowntimeTrigger'
};

const GMUpdateEvent = {
    UpdateDocument: 'DhGMUpdateDocument',
    UpdateEffect: 'DhGMUpdateEffect',
    UpdateSetting: 'DhGMUpdateSetting',
    UpdateFear: 'DhGMUpdateFear',
    UpdateCountdowns: 'DhGMUpdateCountdowns',
    UpdateSaveMessage: 'DhGMUpdateSaveMessage'
};

const RefreshType = {
    Countdown: 'DhCoundownRefresh',
    TagTeamRoll: 'DhTagTeamRollRefresh',
    EffectsDisplay: 'DhEffectsDisplayRefresh'
};

const registerSocketHooks = () => {
    Hooks.on(socketEvent.GMUpdate, async data => {
        if (game.user.isGM) {
            const document = data.uuid ? await fromUuid(data.uuid) : null;
            switch (data.action) {
                case GMUpdateEvent.UpdateDocument:
                    if (document && data.update) await document.update(data.update);
                    break;
                case GMUpdateEvent.UpdateEffect:
                    if (document && data.update)
                        await game.system.api.fields.ActionFields.EffectsField.applyEffects.call(document, data.update);
                    break;
                case GMUpdateEvent.UpdateSetting:
                    await game.settings.set(CONFIG.DH.id, data.uuid, data.update);
                    break;
                case GMUpdateEvent.UpdateFear:
                    await game.settings.set(
                        CONFIG.DH.id,
                        CONFIG.DH.SETTINGS.gameSettings.Resources.Fear,
                        Math.max(
                            0,
                            Math.min(
                                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear,
                                data.update
                            )
                        )
                    );
                    break;
                case GMUpdateEvent.UpdateCountdowns:
                    await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, data.update);
                    Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.Countdown });
                    break;
                case GMUpdateEvent.UpdateSaveMessage:
                    const action = await fromUuid(data.update.action),
                        message = game.messages.get(data.update.message);
                    if (!action || !message) return;
                    action.updateSaveMessage(data.update.result, message, data.update.token);
                    break;
            }

            if (data.refresh) {
                await game.socket.emit(`system.${CONFIG.DH.id}`, {
                    action: socketEvent.Refresh,
                    data: data.refresh
                });
                Hooks.call(socketEvent.Refresh, data.refresh);
            }
        }
    });
};

const registerUserQueries = () => {
    CONFIG.queries.armorSlot = DamageReductionDialog.armorSlotQuery;
    CONFIG.queries.reactionRoll = game.system.api.fields.ActionFields.SaveField.rollSaveQuery;
};

const emitAsGM = async (eventName, callback, update, uuid = null, refresh = null) => {
    if (!game.user.isGM) {
        return await game.socket.emit(`system.${CONFIG.DH.id}`, {
            action: socketEvent.GMUpdate,
            data: {
                action: eventName,
                uuid,
                update,
                refresh
            }
        });
    } else return callback(update);
};

const { ApplicationV2: ApplicationV2$d, HandlebarsApplicationMixin: HandlebarsApplicationMixin$d } = foundry.applications.api;

class RerollDamageDialog extends HandlebarsApplicationMixin$d(ApplicationV2$d) {
    constructor(message, options = {}) {
        super(options);

        this.message = message;
        this.damage = Object.keys(message.system.damage).reduce((acc, typeKey) => {
            const type = message.system.damage[typeKey];
            acc[typeKey] = Object.keys(type.parts).reduce((acc, partKey) => {
                const part = type.parts[partKey];
                acc[partKey] = Object.keys(part.dice).reduce((acc, diceKey) => {
                    const dice = part.dice[diceKey];
                    const activeResults = dice.results.filter(x => x.active);
                    acc[diceKey] = {
                        dice: dice.dice,
                        selectedResults: activeResults.length,
                        maxSelected: activeResults.length,
                        results: activeResults.map(x => ({ ...x, selected: true }))
                    };

                    return acc;
                }, {});

                return acc;
            }, {});

            return acc;
        }, {});
    }

    static DEFAULT_OPTIONS = {
        id: 'reroll-dialog',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'reroll-dialog'],
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            toggleResult: RerollDamageDialog.#toggleResult,
            selectRoll: RerollDamageDialog.#selectRoll,
            doReroll: RerollDamageDialog.#doReroll,
            save: RerollDamageDialog.#save
        }
    };

    /** @override */
    static PARTS = {
        main: {
            id: 'main',
            template: 'systems/daggerheart/templates/dialogs/rerollDialog/damage/main.hbs'
        },
        footer: {
            id: 'footer',
            template: 'systems/daggerheart/templates/dialogs/rerollDialog/footer.hbs'
        }
    };

    get title() {
        return game.i18n.localize('DAGGERHEART.APPLICATIONS.RerollDialog.damageTitle');
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.to-reroll-input').forEach(element => {
            element.addEventListener('change', this.toggleDice.bind(this));
        });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.damage = this.damage;
        context.disabledReroll = !this.getRerollDice().length;
        context.saveDisabled = !this.isSelectionDone();

        return context;
    }

    static async #save() {
        const update = {
            'system.damage': Object.keys(this.damage).reduce((acc, typeKey) => {
                const type = this.damage[typeKey];
                let typeTotal = 0;
                const messageType = this.message.system.damage[typeKey];
                const parts = Object.keys(type).map(partKey => {
                    const part = type[partKey];
                    const messagePart = messageType.parts[partKey];
                    let partTotal = messagePart.modifierTotal;
                    const dice = Object.keys(part).map(diceKey => {
                        const dice = part[diceKey];
                        const total = dice.results.reduce((acc, result) => {
                            if (result.active) acc += result.result;
                            return acc;
                        }, 0);
                        partTotal += total;
                        const messageDice = messagePart.dice[diceKey];
                        return {
                            ...messageDice,
                            total: total,
                            results: dice.results.map(x => ({
                                ...x,
                                hasRerolls: dice.results.length > 1
                            }))
                        };
                    });

                    typeTotal += partTotal;
                    return {
                        ...messagePart,
                        total: partTotal,
                        dice: dice
                    };
                });

                acc[typeKey] = {
                    ...messageType,
                    total: typeTotal,
                    parts: parts
                };

                return acc;
            }, {})
        };
        await this.message.update(update);

        Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.TagTeamRoll });
        await game.socket.emit(`system.${CONFIG.DH.id}`, {
            action: socketEvent.Refresh,
            data: {
                refreshType: RefreshType.TagTeamRoll
            }
        });

        await this.close();
    }

    getRerollDice() {
        const rerollDice = [];
        Object.keys(this.damage).forEach(typeKey => {
            const type = this.damage[typeKey];
            Object.keys(type).forEach(partKey => {
                const part = type[partKey];
                Object.keys(part).forEach(diceKey => {
                    const dice = part[diceKey];
                    Object.keys(dice.results).forEach(resultKey => {
                        const result = dice.results[resultKey];
                        if (result.toReroll) {
                            rerollDice.push({
                                ...result,
                                dice: dice.dice,
                                type: typeKey,
                                part: partKey,
                                dice: diceKey,
                                result: resultKey
                            });
                        }
                    });
                });
            });
        });

        return rerollDice;
    }

    isSelectionDone() {
        const diceFinishedData = [];
        Object.keys(this.damage).forEach(typeKey => {
            const type = this.damage[typeKey];
            Object.keys(type).forEach(partKey => {
                const part = type[partKey];
                Object.keys(part).forEach(diceKey => {
                    const dice = part[diceKey];
                    const selected = dice.results.reduce((acc, result) => acc + (result.active ? 1 : 0), 0);
                    diceFinishedData.push(selected === dice.maxSelected);
                });
            });
        });

        return diceFinishedData.every(x => x);
    }

    toggleDice(event) {
        const target = event.target;
        const { type, part, dice } = target.dataset;
        const toggleDice = this.damage[type][part][dice];

        const existingDiceRerolls = this.getRerollDice().filter(
            x => x.type === type && x.part === part && x.dice === dice
        );

        const allRerolled = existingDiceRerolls.length === toggleDice.results.filter(x => x.active).length;

        toggleDice.toReroll = !allRerolled;
        toggleDice.results.forEach(result => {
            if (result.active) {
                result.toReroll = !allRerolled;
            }
        });

        this.render();
    }

    static #toggleResult(event) {
        event.stopPropagation();

        const target = event.target.closest('.to-reroll-result');
        const { type, part, dice, result } = target.dataset;
        const toggleDice = this.damage[type][part][dice];
        const toggleResult = toggleDice.results[result];
        toggleResult.toReroll = !toggleResult.toReroll;

        const existingDiceRerolls = this.getRerollDice().filter(
            x => x.type === type && x.part === part && x.dice === dice
        );

        const allToReroll = existingDiceRerolls.length === toggleDice.results.filter(x => x.active).length;
        toggleDice.toReroll = allToReroll;

        this.render();
    }

    static async #selectRoll(_, button) {
        const { type, part, dice, result } = button.dataset;

        const diceVal = this.damage[type][part][dice];
        const diceResult = diceVal.results[result];
        if (!diceResult.active && diceVal.results.filter(x => x.active).length === diceVal.maxSelected) {
            return ui.notifications.warn(
                game.i18n.localize('DAGGERHEART.APPLICATIONS.RerollDialog.deselectDiceNotification')
            );
        }

        if (diceResult.active) {
            diceVal.toReroll = false;
            diceResult.toReroll = false;
        }

        diceVal.selectedResults += diceResult.active ? -1 : 1;
        diceResult.active = !diceResult.active;

        this.render();
    }

    static async #doReroll() {
        const toReroll = this.getRerollDice().map(x => {
            const { type, part, dice, result } = x;
            const diceData = this.damage[type][part][dice].results[result];
            return {
                ...diceData,
                dice: this.damage[type][part][dice].dice,
                typeKey: type,
                partKey: part,
                diceKey: dice,
                resultsIndex: result
            };
        });

        const roll = await new Roll(toReroll.map(x => `1${x.dice}`).join(' + ')).evaluate();

        if (game.modules.get('dice-so-nice')?.active) {
            const diceSoNiceRoll = {
                _evaluated: true,
                dice: roll.dice,
                options: { appearance: {} }
            };

            await game.dice3d.showForRoll(diceSoNiceRoll, game.user, true);
        }

        toReroll.forEach((data, index) => {
            const { typeKey, partKey, diceKey, resultsIndex } = data;
            const rerolledDice = roll.dice[index];

            const dice = this.damage[typeKey][partKey][diceKey];
            dice.toReroll = false;
            dice.results[resultsIndex].active = false;
            dice.results[resultsIndex].discarded = true;
            dice.results[resultsIndex].toReroll = false;
            dice.results.splice(dice.results.length, 0, {
                ...rerolledDice.results[0],
                toReroll: false,
                selected: true
            });
        });

        this.render();
    }
}

const { ApplicationV2: ApplicationV2$c, HandlebarsApplicationMixin: HandlebarsApplicationMixin$c } = foundry.applications.api;

class ResourceDiceDialog extends HandlebarsApplicationMixin$c(ApplicationV2$c) {
    constructor(item, actor, options = {}) {
        super(options);

        this.item = item;
        this.actor = actor;
        this.diceStates = foundry.utils.deepClone(item.system.resource.diceStates);
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'resource-dice'],
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            rerollDice: this.rerollDice,
            save: this.save
        },
        form: {
            handler: this.updateResourceDice,
            submitOnChange: true,
            submitOnClose: false
        }
    };

    /** @override */
    static PARTS = {
        resourceDice: {
            id: 'resourceDice',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/resourceDice.hbs'
        }
    };

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.ResourceDice.title', { name: this.item.name });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.item = this.item;
        context.actor = this.actor;
        context.diceStates = this.diceStates;

        return context;
    }

    static async updateResourceDice(event, _, formData) {
        const { diceStates } = foundry.utils.expandObject(formData.object);
        this.diceStates = Object.keys(diceStates).reduce((acc, key) => {
            const resourceState = this.item.system.resource.diceStates[key];
            acc[key] = { ...diceStates[key], used: Boolean(resourceState?.used) };
            return acc;
        }, {});

        this.render();
    }

    static async save() {
        this.rollValues = Object.values(this.diceStates);
        this.close();
    }

    static async rerollDice() {
        const max = itemAbleRollParse(this.item.system.resource.max, this.actor, this.item);
        const diceFormula = `${max}${this.item.system.resource.dieFaces}`;
        const roll = await new Roll(diceFormula).evaluate();
        if (game.modules.get('dice-so-nice')?.active) await game.dice3d.showForRoll(roll, game.user, true);
        this.rollValues = roll.terms[0].results.map(x => ({ value: x.result, used: false }));
        this.resetUsed = true;

        const cls = getDocumentClass('ChatMessage');
        const msg = {
            user: game.user.id,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/resource-roll.hbs',
                {
                    user: this.actor.name,
                    name: this.item.name
                }
            )
        };

        cls.create(msg);
        this.close();
    }

    static async create(item, actor, options = {}) {
        return new Promise(resolve => {
            const app = new this(item, actor, options);
            app.addEventListener('close', () => resolve(app.rollValues), { once: true });
            app.render({ force: true });
        });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$b, ApplicationV2: ApplicationV2$b } = foundry.applications.api;

class TagTeamDialog extends HandlebarsApplicationMixin$b(ApplicationV2$b) {
    constructor(party) {
        super();

        this.data = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
        this.party = party;

        this.setupHooks = Hooks.on(socketEvent.Refresh, ({ refreshType }) => {
            if (refreshType === RefreshType.TagTeamRoll) {
                this.data = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
                this.render();
            }
        });
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.APPLICATIONS.TagTeamSelect.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'dh-style', 'dialog', 'tag-team-dialog'],
        position: { width: 550, height: 'auto' },
        actions: {
            removeMember: TagTeamDialog.#removeMember,
            unlinkMessage: TagTeamDialog.#unlinkMessage,
            selectMessage: TagTeamDialog.#selectMessage,
            createTagTeam: TagTeamDialog.#createTagTeam
        },
        form: { handler: this.updateData, submitOnChange: true, closeOnSubmit: false }
    };

    static PARTS = {
        application: {
            id: 'tag-team-dialog',
            template: 'systems/daggerheart/templates/dialogs/tagTeamDialog.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.hopeCost = this.hopeCost;
        context.data = this.data;

        context.memberOptions = this.party.filter(c => !this.data.members[c.id]);
        context.selectedCharacterOptions = this.party.filter(c => this.data.members[c.id]);

        context.members = Object.keys(this.data.members).map(id => {
            const roll = this.data.members[id].messageId ? game.messages.get(this.data.members[id].messageId) : null;

            context.usesDamage =
                context.usesDamage === undefined
                    ? roll?.system.hasDamage
                    : context.usesDamage && roll?.system.hasDamage;
            return {
                character: this.party.find(x => x.id === id),
                selected: this.data.members[id].selected,
                roll: roll,
                damageValues: roll
                    ? Object.keys(roll.system.damage).map(key => ({
                          key: key,
                          name: game.i18n.localize(CONFIG.DH.GENERAL.healingTypes[key].label),
                          total: roll.system.damage[key].total
                      }))
                    : null
            };
        });

        const initiatorChar = this.party.find(x => x.id === this.data.initiator.id);
        context.initiator = {
            character: initiatorChar,
            cost: this.data.initiator.cost
        };

        const selectedMember = Object.values(context.members).find(x => x.selected);
        const selectedIsCritical = selectedMember?.roll?.system?.isCritical;
        context.selectedData = {
            result: selectedMember
                ? `${selectedMember.roll.system.roll.total} ${selectedMember.roll.system.roll.result.label}`
                : null,
            damageValues: null
        };

        for (const member of Object.values(context.members)) {
            if (!member.roll) continue;
            if (context.usesDamage) {
                if (!context.selectedData.damageValues) context.selectedData.damageValues = {};
                for (let damage of member.damageValues) {
                    const damageTotal = member.roll.system.isCritical
                        ? damage.total
                        : selectedIsCritical
                          ? damage.total + (await getCritDamageBonus(member.roll.system.damage[damage.key].formula))
                          : damage.total;
                    if (context.selectedData.damageValues[damage.key]) {
                        context.selectedData.damageValues[damage.key].total += damageTotal;
                    } else {
                        context.selectedData.damageValues[damage.key] = {
                            ...foundry.utils.deepClone(damage),
                            total: damageTotal
                        };
                    }
                }
            }
        }

        context.showResult = Object.values(context.members).reduce((enabled, member) => {
            if (!member.roll) return enabled;
            if (context.usesDamage) {
                enabled = enabled === null ? member.damageValues.length > 0 : enabled && member.damageValues.length > 0;
            } else {
                enabled = enabled === null ? Boolean(member.roll) : enabled && Boolean(member.roll);
            }

            return enabled;
        }, null);

        context.createDisabled =
            !context.selectedData.result ||
            !this.data.initiator.id ||
            Object.keys(this.data.members).length === 0 ||
            Object.values(context.members).some(x =>
                context.usesDamage ? !x.damageValues || x.damageValues.length === 0 : !x.roll
            );

        return context;
    }

    async updateSource(update) {
        await this.data.updateSource(update);

        if (game.user.isGM) {
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll, this.data.toObject());
            Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.TagTeamRoll });
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.Refresh,
                data: {
                    refreshType: RefreshType.TagTeamRoll
                }
            });
        } else {
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateSetting,
                    uuid: CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll,
                    update: this.data.toObject(),
                    refresh: { refreshType: RefreshType.TagTeamRoll }
                }
            });
        }
    }

    static async updateData(_event, _element, formData) {
        const { selectedAddMember, initiator } = foundry.utils.expandObject(formData.object);
        const update = { initiator: initiator };
        if (selectedAddMember) {
            const member = await foundry.utils.fromUuid(selectedAddMember);
            update[`members.${member.id}`] = { messageId: null };
        }

        await this.updateSource(update);
        this.render();
    }

    static async #removeMember(_, button) {
        const update = { [`members.-=${button.dataset.characterId}`]: null };
        if (this.data.initiator.id === button.dataset.characterId) {
            update.iniator = { id: null };
        }

        await this.updateSource(update);
    }

    static async #unlinkMessage(_, button) {
        await this.updateSource({ [`members.${button.id}.messageId`]: null });
    }

    static async #selectMessage(_, button) {
        const member = this.data.members[button.id];
        const currentSelected = Object.keys(this.data.members).find(key => this.data.members[key].selected);
        const curretSelectedUpdate =
            currentSelected && currentSelected !== button.id ? { [`${currentSelected}`]: { selected: false } } : {};
        await this.updateSource({
            members: {
                [`${button.id}`]: { selected: !member.selected },
                ...curretSelectedUpdate
            }
        });
    }

    static async #createTagTeam() {
        const mainRollId = Object.keys(this.data.members).find(key => this.data.members[key].selected);
        const mainRoll = game.messages.get(this.data.members[mainRollId].messageId);

        if (this.data.initiator.cost) {
            const initiator = this.party.find(x => x.id === this.data.initiator.id);
            if (initiator.system.resources.hope.value < this.data.initiator.cost) {
                return ui.notifications.warn(
                    game.i18n.localize('DAGGERHEART.APPLICATIONS.TagTeamSelect.insufficientHope')
                );
            }
        }

        const secondaryRolls = Object.keys(this.data.members)
            .filter(key => key !== mainRollId)
            .map(key => game.messages.get(this.data.members[key].messageId));

        const systemData = foundry.utils.deepClone(mainRoll).system.toObject();
        const criticalRoll = systemData.roll.isCritical;
        for (let roll of secondaryRolls) {
            if (roll.system.hasDamage) {
                for (let key in roll.system.damage) {
                    var damage = roll.system.damage[key];
                    const damageTotal =
                        !roll.system.isCritical && criticalRoll
                            ? (await getCritDamageBonus(damage.formula)) + damage.total
                            : damage.total;
                    if (systemData.damage[key]) {
                        const updatedDamageParts = damage.parts;
                        if (!roll.system.isCritical && criticalRoll) {
                            for (let part of updatedDamageParts) {
                                const criticalDamage = await getCritDamageBonus(part.formula);
                                if (criticalDamage) {
                                    damage.formula = `${damage.formula} + ${criticalDamage}`;
                                    part.formula = `${part.formula} + ${criticalDamage}`;
                                    part.modifierTotal = part.modifierTotal + criticalDamage;
                                    part.total += criticalDamage;
                                    part.roll = new Roll(part.formula);
                                }
                            }
                        }

                        systemData.damage[key].formula = `${systemData.damage[key].formula} + ${damage.formula}`;
                        systemData.damage[key].total += damageTotal;
                        systemData.damage[key].parts = [...systemData.damage[key].parts, ...updatedDamageParts];
                    } else {
                        systemData.damage[key] = { ...damage, total: damageTotal, parts: updatedDamageParts };
                    }
                }
            }
        }

        systemData.title = game.i18n.localize('DAGGERHEART.APPLICATIONS.TagTeamSelect.chatMessageRollTitle');
        const cls = getDocumentClass('ChatMessage'),
            msgData = {
                type: 'dualityRoll',
                user: game.user.id,
                title: game.i18n.localize('DAGGERHEART.APPLICATIONS.TagTeamSelect.title'),
                speaker: cls.getSpeaker({ actor: this.party.find(x => x.id === mainRollId) }),
                system: systemData,
                rolls: mainRoll.rolls,
                sound: null,
                flags: { core: { RollTable: true } }
            };

        await cls.create(msgData);

        const fearUpdate = { key: 'fear', value: null, total: null, enabled: true };
        for (let memberId of Object.keys(this.data.members)) {
            const resourceUpdates = [];
            const rollGivesHope = systemData.roll.isCritical || systemData.roll.result.duality === 1;
            if (memberId === this.data.initiator.id) {
                const value = this.data.initiator.cost
                    ? rollGivesHope
                        ? 1 - this.data.initiator.cost
                        : -this.data.initiator.cost
                    : 1;
                resourceUpdates.push({ key: 'hope', value: value, total: -value, enabled: true });
            } else if (rollGivesHope) {
                resourceUpdates.push({ key: 'hope', value: 1, total: -1, enabled: true });
            }
            if (systemData.roll.isCritical) resourceUpdates.push({ key: 'stress', value: -1, total: 1, enabled: true });
            if (systemData.roll.result.duality === -1) {
                fearUpdate.value = fearUpdate.value === null ? 1 : fearUpdate.value + 1;
                fearUpdate.total = fearUpdate.total === null ? -1 : fearUpdate.total - 1;
            }

            this.party.find(x => x.id === memberId).modifyResource(resourceUpdates);
        }

        if (fearUpdate.value) {
            this.party.find(x => x.id === mainRollId).modifyResource([fearUpdate]);
        }

        /* Improve by fetching default from schema */
        const update = { members: [], initiator: { id: null, cost: 3 } };
        if (game.user.isGM) {
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll, update);
            Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.TagTeamRoll });
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.Refresh,
                data: {
                    refreshType: RefreshType.TagTeamRoll
                }
            });
        } else {
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateSetting,
                    uuid: CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll,
                    update: update,
                    refresh: { refreshType: RefreshType.TagTeamRoll }
                }
            });
        }
    }

    static async assignRoll(char, message) {
        const settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
        const character = settings.members[char.id];
        if (!character) return;

        await settings.updateSource({ [`members.${char.id}.messageId`]: message.id });

        if (game.user.isGM) {
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll, settings);
            Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.TagTeamRoll });
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.Refresh,
                data: {
                    refreshType: RefreshType.TagTeamRoll
                }
            });
        } else {
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateSetting,
                    uuid: CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll,
                    update: settings,
                    refresh: { refreshType: RefreshType.TagTeamRoll }
                }
            });
        }
    }

    async close(options = {}) {
        Hooks.off(socketEvent.Refresh, this.setupHooks);
        await super.close(options);
    }
}

var _module$h = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActionSelectionDialog: ActionSelectionDialog,
    AttributionDialog: AttributionDialog,
    BeastformDialog: BeastformDialog,
    DamageDialog: DamageDialog,
    DamageReductionDialog: DamageReductionDialog,
    DeathMove: DhpDeathMove,
    Downtime: DhpDowntime,
    GroupRollDialog: GroupRollDialog,
    ImageSelectDialog: ImageSelectDialog,
    ItemTransferDialog: ItemTransferDialog,
    MulticlassChoiceDialog: MulticlassChoiceDialog,
    OwnershipSelection: OwnershipSelection,
    RerollDamageDialog: RerollDamageDialog,
    ResourceDiceDialog: ResourceDiceDialog,
    TagTeamDialog: TagTeamDialog,
    d20RollDialog: D20RollDialog
});

class DHTokenHUD extends foundry.applications.hud.TokenHUD {
    static DEFAULT_OPTIONS = {
        classes: ['daggerheart'],
        actions: {
            combat: DHTokenHUD.#onToggleCombat,
            togglePartyTokens: DHTokenHUD.#togglePartyTokens
        }
    };

    /** @override */
    static PARTS = {
        hud: {
            root: true,
            template: 'systems/daggerheart/templates/hud/tokenHUD.hbs'
        }
    };

    static #nonCombatTypes = ['environment', 'companion', 'party'];

    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.partyOnCanvas =
            this.actor.type === 'party' &&
            this.actor.system.partyMembers.some(member => member.getActiveTokens().length > 0);
        context.icons.toggleParty = 'systems/daggerheart/assets/icons/arrow-dunk.png';
        context.actorType = this.actor.type;
        context.usesEffects = this.actor.type !== 'party';
        context.canToggleCombat = DHTokenHUD.#nonCombatTypes.includes(this.actor.type)
            ? false
            : context.canToggleCombat;

        context.systemStatusEffects = Object.keys(context.statusEffects).reduce((acc, key) => {
            const effect = context.statusEffects[key];
            if (effect.systemEffect) {
                const disabled = !effect.isActive && this.actor.system.rules?.conditionImmunities?.[key];
                acc[key] = { ...effect, disabled };
            }

            return acc;
        }, {});

        const useGeneric = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.appearance
        ).showGenericStatusEffects;
        context.genericStatusEffects = useGeneric
            ? Object.keys(context.statusEffects).reduce((acc, key) => {
                  const effect = context.statusEffects[key];
                  if (!effect.systemEffect) acc[key] = effect;

                  return acc;
              }, {})
            : null;

        return context;
    }

    static async #onToggleCombat() {
        const tokens = canvas.tokens.controlled
            .filter(t => !t.actor || !DHTokenHUD.#nonCombatTypes.includes(t.actor.type))
            .map(t => t.document);
        if (!this.object.controlled) tokens.push(this.document);

        try {
            if (this.document.inCombat) await TokenDocument.implementation.deleteCombatants(tokens);
            else await TokenDocument.implementation.createCombatants(tokens);
        } catch (err) {
            ui.notifications.warn(err.message);
        }
    }

    static async #togglePartyTokens(_, button) {
        const icon = button.querySelector('img');
        icon.classList.toggle('flipped');
        button.dataset.tooltip = game.i18n.localize(
            icon.classList.contains('flipped')
                ? 'DAGGERHEART.APPLICATIONS.HUD.tokenHUD.retrievePartyTokens'
                : 'DAGGERHEART.APPLICATIONS.HUD.tokenHUD.depositPartyTokens'
        );

        const animationDuration = 500;
        const activeTokens = this.actor.system.partyMembers.flatMap(member => member.getActiveTokens());
        const { x: actorX, y: actorY } = this.document;
        if (activeTokens.length > 0) {
            for (let token of activeTokens) {
                await token.document.update(
                    { x: actorX, y: actorY, alpha: 0 },
                    { animation: { duration: animationDuration } }
                );
                setTimeout(() => token.document.delete(), animationDuration);
            }
        } else {
            const activeScene = game.scenes.find(x => x.id === game.user.viewedScene);
            const partyTokenData = [];
            for (let member of this.actor.system.partyMembers) {
                const data = await member.getTokenDocument();
                partyTokenData.push(data.toObject());
            }
            const newTokens = await activeScene.createEmbeddedDocuments(
                'Token',
                partyTokenData.map(tokenData => ({
                    ...tokenData,
                    alpha: 0,
                    x: actorX,
                    y: actorY
                }))
            );

            const { sizeX, sizeY } = activeScene.grid;
            const nrRandomPositions = Math.ceil(newTokens.length / 8) * 8;
            /* This is an overcomplicated mess, but I'm stupid */
            const positions = shuffleArray(
                [...Array(nrRandomPositions).keys()].map((_, index) => {
                    const nonZeroIndex = index + 1;
                    const indexFloor = Math.floor(index / 8);
                    const distanceCoefficient = indexFloor + 1;
                    const side = 3 + indexFloor * 2;
                    const sideMiddle = Math.ceil(side / 2);
                    const inbetween = 1 + indexFloor * 2;
                    const inbetweenMiddle = Math.ceil(inbetween / 2);

                    if (index < side) {
                        const distance =
                            nonZeroIndex === sideMiddle
                                ? 0
                                : nonZeroIndex < sideMiddle
                                  ? -nonZeroIndex
                                  : nonZeroIndex - sideMiddle;
                        return { x: actorX - sizeX * distance, y: actorY - sizeY * distanceCoefficient };
                    } else if (index < side + inbetween) {
                        const inbetweenIndex = nonZeroIndex - side;
                        const distance =
                            inbetweenIndex === inbetweenMiddle
                                ? 0
                                : inbetweenIndex < inbetweenMiddle
                                  ? -inbetweenIndex
                                  : inbetweenIndex - inbetweenMiddle;
                        return { x: actorX + sizeX * distanceCoefficient, y: actorY + sizeY * distance };
                    } else if (index < 2 * side + inbetween) {
                        const sideIndex = nonZeroIndex - side - inbetween;
                        const distance =
                            sideIndex === sideMiddle
                                ? 0
                                : sideIndex < sideMiddle
                                  ? sideIndex
                                  : -(sideIndex - sideMiddle);
                        return { x: actorX + sizeX * distance, y: actorY + sizeY * distanceCoefficient };
                    } else {
                        const inbetweenIndex = nonZeroIndex - 2 * side - inbetween;
                        const distance =
                            inbetweenIndex === inbetweenMiddle
                                ? 0
                                : inbetweenIndex < inbetweenMiddle
                                  ? inbetweenIndex
                                  : -(inbetweenIndex - inbetweenMiddle);
                        return { x: actorX - sizeX * distanceCoefficient, y: actorY + sizeY * distance };
                    }
                })
            );

            for (let token of newTokens) {
                const position = positions.pop();
                token.update(
                    { x: position.x, y: position.y, alpha: 1 },
                    { animation: { duration: animationDuration } }
                );
            }
        }
    }

    _getStatusEffectChoices() {
        // Include all HUD-enabled status effects
        const choices = {};
        for (const status of CONFIG.statusEffects) {
            if (
                status.hud === false ||
                (foundry.utils.getType(status.hud) === 'Object' &&
                    status.hud.actorTypes?.includes(this.document.actor.type) === false)
            ) {
                continue;
            }
            choices[status.id] = {
                _id: status._id,
                id: status.id,
                systemEffect: status.systemEffect,
                title: game.i18n.localize(status.name ?? /** @deprecated since v12 */ status.label),
                src: status.img ?? /** @deprecated since v12 */ status.icon,
                isActive: false,
                isOverlay: false
            };
        }

        // Update the status of effects which are active for the token actor
        const activeEffects = this.actor?.getActiveEffects() || [];
        for (const effect of activeEffects) {
            for (const statusId of effect.statuses) {
                const status = choices[statusId];
                status.instances = 1 + (status.instances ?? 0);
                status.locked = status.locked || effect.condition || status.instances > 1;
                if (!status) continue;
                if (status._id) {
                    if (status._id !== effect.id) continue;
                }
                status.isActive = true;
                if (effect.getFlag?.('core', 'overlay')) status.isOverlay = true;
            }
        }

        // Flag status CSS class
        for (const status of Object.values(choices)) {
            status.cssClass = [status.isActive ? 'active' : null, status.isOverlay ? 'overlay' : null].filterJoin(' ');
        }
        return choices;
    }
}

var _module$g = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHTokenHUD: DHTokenHUD
});

class DhCharacterLevelUp extends DhlevelUp {
    constructor(actor) {
        super(actor);

        this.levelTiers = this.addBonusChoices(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers)
        );
        const playerLevelupData = actor.system.levelData;
        this.levelup = new DhLevelup(DhLevelup.initializeData(this.levelTiers, playerLevelupData));
    }

    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        const currentLevel = this.levelup.levels[this.levelup.currentLevel];
        switch (partId) {
            case 'selections':
                const advancementChoices = Object.keys(currentLevel.choices).reduce((acc, choiceKey) => {
                    Object.keys(currentLevel.choices[choiceKey]).forEach(checkboxNr => {
                        const checkbox = currentLevel.choices[choiceKey][checkboxNr];
                        const data = {
                            ...checkbox,
                            path: `levels.${this.levelup.currentLevel}.choices.${choiceKey}.${checkboxNr}`,
                            level: this.levelup.currentLevel
                        };

                        if (!acc[choiceKey]) acc[choiceKey] = [];
                        acc[choiceKey].push(data);
                    });

                    return acc;
                }, {});

                const traits = Object.values(advancementChoices.trait ?? {});
                const traitValues = traits.filter(trait => trait.data.length > 0).flatMap(trait => trait.data);
                context.traits = {
                    values: traitValues,
                    active: traits.length > 0,
                    progress: {
                        selected: traitValues.length,
                        max: traits.reduce((acc, exp) => acc + exp.amount, 0)
                    }
                };

                const experienceIncreases = Object.values(advancementChoices.experience ?? {});
                const experienceIncreaseValues = experienceIncreases
                    .filter(exp => exp.data.length > 0)
                    .flatMap(exp => exp.data);
                context.experienceIncreases = {
                    values: experienceIncreaseValues,
                    active: experienceIncreases.length > 0,
                    progress: {
                        selected: experienceIncreaseValues.length,
                        max: experienceIncreases.reduce((acc, exp) => acc + exp.amount, 0)
                    }
                };

                context.newExperiences = Object.keys(currentLevel.achievements.experiences).map(key => {
                    const experience = currentLevel.achievements.experiences[key];
                    return {
                        ...experience,
                        level: this.levelup.currentLevel,
                        key: key
                    };
                });

                const allDomainCards = {
                    ...advancementChoices.domainCard,
                    ...currentLevel.achievements.domainCards
                };
                const allDomainCardKeys = Object.keys(allDomainCards);

                const classDomainsData = this.actor.system.class.value.system.domains.map(domain => ({
                    domain,
                    multiclass: false
                }));
                const multiclassDomainsData = (this.actor.system.multiclass?.value?.system?.domains ?? []).map(
                    domain => ({ domain, multiclass: true })
                );
                const domainsData = [...classDomainsData, ...multiclassDomainsData];
                const multiclassDomain = this.levelup.classUpgradeChoices?.multiclass?.domain;
                if (multiclassDomain) {
                    if (!domainsData.some(x => x.domain === multiclassDomain))
                        domainsData.push({ domain: multiclassDomain, multiclass: true });
                }

                context.domainCards = [];
                for (var key of allDomainCardKeys) {
                    const domainCard = allDomainCards[key];
                    if (domainCard.level > this.levelup.endLevel) continue;

                    const uuid = domainCard.data?.length > 0 ? domainCard.data[0] : domainCard.uuid;
                    const card = uuid ? await foundry.utils.fromUuid(uuid) : {};

                    context.domainCards.push({
                        ...(card.toObject?.() ?? card),
                        emptySubtexts: domainsData.map(domain => {
                            const levelBase = domain.multiclass
                                ? Math.ceil(this.levelup.currentLevel / 2)
                                : this.levelup.currentLevel;
                            const levelMax = domainCard.secondaryData?.limit
                                ? Math.min(domainCard.secondaryData.limit, levelBase)
                                : levelBase;

                            return game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.selections.emptyDomainCardHint', {
                                domain: game.i18n.localize(CONFIG.DH.DOMAIN.allDomains()[domain.domain].label),
                                level: levelMax
                            });
                        }),
                        path: domainCard.data
                            ? `${domainCard.path}.data`
                            : `levels.${domainCard.level}.achievements.domainCards.${key}.uuid`,
                        limit: domainCard.secondaryData?.limit ?? null,
                        compendium: 'domains'
                    });
                }

                const subclassSelections = advancementChoices.subclass?.flatMap(x => x.data) ?? [];
                const possibleSubclasses = [this.actor.system.class.subclass];
                if (this.actor.system.multiclass?.subclass) {
                    possibleSubclasses.push(this.actor.system.multiclass.subclass);
                }

                context.subclassCards = [];
                if (advancementChoices.subclass?.length > 0) {
                    const featureStateIncrease = Object.values(this.levelup.levels).reduce((acc, level) => {
                        acc += Object.values(level.choices).filter(choice => {
                            return Object.values(choice).every(checkbox => checkbox.type === 'subclass');
                        }).length;
                        return acc;
                    }, 0);

                    for (var subclass of possibleSubclasses) {
                        const choice =
                            advancementChoices.subclass.find(x => x.data[0] === subclass.uuid) ??
                            advancementChoices.subclass.find(x => x.data.length === 0);
                        const featureState = subclass.system.featureState + featureStateIncrease;
                        const data = await foundry.utils.fromUuid(subclass.uuid);
                        context.subclassCards.push({
                            ...data.toObject(),
                            path: choice?.path,
                            uuid: data.uuid,
                            selected: subclassSelections.includes(subclass.uuid),
                            featureState: featureState,
                            featureLabel: game.i18n.localize(subclassFeatureLabels[featureState]),
                            isMulticlass: subclass.system.isMulticlass ? 'true' : 'false'
                        });
                    }
                }

                const multiclasses = Object.values(advancementChoices.multiclass ?? {});
                if (multiclasses?.[0]) {
                    const data = multiclasses[0];
                    const multiclass = data.data.length > 0 ? await foundry.utils.fromUuid(data.data[0]) : {};

                    context.multiclass = {
                        ...data,
                        ...(multiclass.toObject?.() ?? multiclass),
                        type: 'multiclass',
                        uuid: multiclass.uuid,
                        domains:
                            multiclass?.system?.domains.map(key => {
                                const domain = CONFIG.DH.DOMAIN.allDomains()[key];
                                const alreadySelected = this.actor.system.class.value.system.domains.includes(key);

                                return {
                                    ...domain,
                                    selected: key === data.secondaryData.domain,
                                    disabled:
                                        (data.secondaryData.domain && key !== data.secondaryData.domain) ||
                                        alreadySelected
                                };
                            }) ?? [],
                        subclasses:
                            multiclass?.system?.subclasses.map(subclass => ({
                                ...subclass,
                                uuid: subclass.uuid,
                                selected: data.secondaryData.subclass === subclass.uuid,
                                disabled: data.secondaryData.subclass && data.secondaryData.subclass !== subclass.uuid
                            })) ?? [],
                        compendium: 'classes',
                        limit: 1
                    };
                }

                break;
            case 'summary':
                const { current: currentActorLevel, changed: changedActorLevel } = this.actor.system.levelData.level;
                const actorArmor = this.actor.system.armor;
                const levelKeys = Object.keys(this.levelup.levels);
                let achivementProficiency = 0;
                const achievementCards = [];
                let achievementExperiences = [];
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    achivementProficiency += level.achievements.proficiency ?? 0;
                    const cards = level.achievements.domainCards ? Object.values(level.achievements.domainCards) : null;
                    if (cards) {
                        for (var card of cards) {
                            const itemCard = await foundry.utils.fromUuid(card.uuid);
                            achievementCards.push(itemCard);
                        }
                    }

                    achievementExperiences = level.achievements.experiences
                        ? Object.values(level.achievements.experiences).reduce((acc, experience) => {
                              if (experience.name) acc.push(experience);
                              return acc;
                          }, [])
                        : [];
                }

                context.achievements = {
                    proficiency: {
                        old: this.actor.system.proficiency,
                        new: this.actor.system.proficiency + achivementProficiency,
                        shown: achivementProficiency > 0
                    },
                    damageThresholds: {
                        major: {
                            old: this.actor.system.damageThresholds.major,
                            new: this.actor.system.damageThresholds.major + changedActorLevel - currentActorLevel
                        },
                        severe: {
                            old: this.actor.system.damageThresholds.severe,
                            new:
                                this.actor.system.damageThresholds.severe +
                                (actorArmor
                                    ? changedActorLevel - currentActorLevel
                                    : (changedActorLevel - currentActorLevel) * 2)
                        },
                        unarmored: !actorArmor
                    },
                    domainCards: {
                        values: achievementCards,
                        shown: achievementCards.length > 0
                    },
                    experiences: {
                        values: achievementExperiences,
                        shown: achievementExperiences.length > 0
                    }
                };

                const advancement = {};
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    for (var choiceKey of Object.keys(level.choices)) {
                        const choice = level.choices[choiceKey];
                        for (var checkbox of Object.values(choice)) {
                            switch (choiceKey) {
                                case 'proficiency':
                                case 'hitPoint':
                                case 'stress':
                                case 'evasion':
                                    advancement[choiceKey] = advancement[choiceKey]
                                        ? advancement[choiceKey] + Number(checkbox.value)
                                        : Number(checkbox.value);
                                    break;
                                case 'trait':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = {};
                                    for (var traitKey of checkbox.data) {
                                        if (!advancement[choiceKey][traitKey]) advancement[choiceKey][traitKey] = 0;
                                        advancement[choiceKey][traitKey] += 1;
                                    }
                                    break;
                                case 'domainCard':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                    if (checkbox.data.length === 1) {
                                        const choiceItem = await foundry.utils.fromUuid(checkbox.data[0]);
                                        advancement[choiceKey].push(choiceItem.toObject());
                                    }
                                    break;
                                case 'experience':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                    const data = checkbox.data.map(data => {
                                        const experience = Object.keys(this.actor.system.experiences).find(
                                            x => x === data
                                        );
                                        return this.actor.system.experiences[experience]?.name ?? '';
                                    });
                                    advancement[choiceKey].push({ data: data, value: checkbox.value });
                                    break;
                                case 'subclass':
                                    if (checkbox.data[0]) {
                                        const subclassItem = await foundry.utils.fromUuid(checkbox.data[0]);
                                        if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                        advancement[choiceKey].push({
                                            ...subclassItem.toObject(),
                                            featureLabel: game.i18n.localize(
                                                subclassFeatureLabels[Number(checkbox.secondaryData.featureState)]
                                            )
                                        });
                                    }
                                    break;
                                case 'multiclass':
                                    const multiclassItem = await foundry.utils.fromUuid(checkbox.data[0]);
                                    const subclass = multiclassItem
                                        ? await foundry.utils.fromUuid(checkbox.secondaryData.subclass)
                                        : null;
                                    advancement[choiceKey] = multiclassItem
                                        ? {
                                              ...multiclassItem.toObject(),
                                              domain: checkbox.secondaryData.domain
                                                  ? game.i18n.localize(
                                                        CONFIG.DH.DOMAIN.allDomains()[checkbox.secondaryData.domain]
                                                            .label
                                                    )
                                                  : null,
                                              subclass: subclass ? subclass.name : null
                                          }
                                        : {};
                                    break;
                            }
                        }
                    }
                }

                context.advancements = {
                    statistics: {
                        proficiency: {
                            old: context.achievements.proficiency.new,
                            new: context.achievements.proficiency.new + (advancement.proficiency ?? 0)
                        },
                        hitPoints: {
                            old: this.actor.system.resources.hitPoints.max,
                            new: this.actor.system.resources.hitPoints.max + (advancement.hitPoint ?? 0)
                        },
                        stress: {
                            old: this.actor.system.resources.stress.max,
                            new: this.actor.system.resources.stress.max + (advancement.stress ?? 0)
                        },
                        evasion: {
                            old: this.actor.system.evasion,
                            new: this.actor.system.evasion + (advancement.evasion ?? 0)
                        }
                    },
                    traits: Object.keys(this.actor.system.traits).reduce((acc, traitKey) => {
                        if (advancement.trait?.[traitKey]) {
                            if (!acc) acc = {};
                            acc[traitKey] = {
                                label: game.i18n.localize(abilities[traitKey].label),
                                old: this.actor.system.traits[traitKey].value,
                                new: this.actor.system.traits[traitKey].value + advancement.trait[traitKey]
                            };
                        }
                        return acc;
                    }, null),
                    domainCards: advancement.domainCard ?? [],
                    experiences:
                        advancement.experience?.flatMap(x => x.data.map(data => ({ name: data, modifier: x.value }))) ??
                        [],
                    multiclass: advancement.multiclass,
                    subclass: advancement.subclass
                };

                context.advancements.statistics.proficiency.shown =
                    context.advancements.statistics.proficiency.new > context.advancements.statistics.proficiency.old;
                context.advancements.statistics.hitPoints.shown =
                    context.advancements.statistics.hitPoints.new > context.advancements.statistics.hitPoints.old;
                context.advancements.statistics.stress.shown =
                    context.advancements.statistics.stress.new > context.advancements.statistics.stress.old;
                context.advancements.statistics.evasion.shown =
                    context.advancements.statistics.evasion.new > context.advancements.statistics.evasion.old;
                context.advancements.statistics.shown =
                    context.advancements.statistics.proficiency.shown ||
                    context.advancements.statistics.hitPoints.shown ||
                    context.advancements.statistics.stress.shown ||
                    context.advancements.statistics.evasion.shown;

                break;
        }

        return context;
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$a, ApplicationV2: ApplicationV2$a } = foundry.applications.api;

class DhlevelUpViewMode extends HandlebarsApplicationMixin$a(ApplicationV2$a) {
    constructor(actor) {
        super({});

        this.actor = actor;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.viewModeTitle', { actor: this.actor.name });
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dialog', 'dh-style', 'levelup'],
        position: { width: 1000, height: 'auto' },
        window: {
            resizable: true,
            icon: 'fa-solid fa-arrow-turn-up'
        }
    };

    static PARTS = {
        main: { template: 'systems/daggerheart/templates/levelup/tabs/viewMode.hbs' }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);

        const { tiers } = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers);
        const tierKeys = Object.keys(tiers);
        const selections = Object.keys(this.actor.system.levelData.levelups).reduce(
            (acc, key) => {
                const level = this.actor.system.levelData.levelups[key];
                Object.keys(level.selections).forEach(optionKey => {
                    const choice = level.selections[optionKey];
                    if (!acc[choice.tier][choice.optionKey]) acc[choice.tier][choice.optionKey] = {};
                    acc[choice.tier][choice.optionKey][choice.checkboxNr] = choice;
                });

                return acc;
            },
            tierKeys.reduce((acc, key) => {
                acc[key] = {};
                return acc;
            }, {})
        );

        context.tiers = tierKeys.map((tierKey, tierIndex) => {
            const tier = tiers[tierKey];

            return {
                name: tier.name,
                active: true,
                groups: Object.keys(tier.options).map(optionKey => {
                    const option = tier.options[optionKey];

                    const checkboxes = [...Array(option.checkboxSelections).keys()].flatMap(index => {
                        const checkboxNr = index + 1;
                        const checkboxData = selections[tierKey]?.[optionKey]?.[checkboxNr];
                        const checkbox = { ...option, checkboxNr, tier: tierKey, disabled: true };

                        if (checkboxData) {
                            checkbox.level = checkboxData.level;
                            checkbox.selected = true;
                        }

                        return checkbox;
                    });

                    let label = game.i18n.localize(option.label);
                    return {
                        label: label,
                        checkboxGroups: chunkify(checkboxes, option.minCost, chunkedBoxes => {
                            const anySelected = chunkedBoxes.some(x => x.selected);
                            const anyDisabled = chunkedBoxes.some(x => x.disabled);
                            return {
                                multi: option.minCost > 1,
                                checkboxes: chunkedBoxes.map(x => ({
                                    ...x,
                                    selected: anySelected,
                                    disabled: anyDisabled
                                }))
                            };
                        })
                    };
                })
            };
        });

        return context;
    }
}

var _module$f = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CharacterLevelup: DhCharacterLevelUp,
    CompanionLevelup: DhCompanionLevelUp,
    Levelup: DhlevelUp,
    LevelupViewMode: DhlevelUpViewMode
});

class DhSceneConfigSettings extends foundry.applications.sheets.SceneConfig {
    // static DEFAULT_OPTIONS = {
    //     ...super.DEFAULT_OPTIONS,
    //     form: {
    //         handler: this.updateData,
    //         closeOnSubmit: true
    //     }
    // };

    static buildParts() {
        const { footer, tabs, ...parts } = super.PARTS;
        const tmpParts = {
            // tabs,
            tabs: { template: 'systems/daggerheart/templates/scene/tabs.hbs' },
            ...parts,
            dh: { template: 'systems/daggerheart/templates/scene/dh-config.hbs' },
            footer
        };
        return tmpParts;
    }

    static PARTS = DhSceneConfigSettings.buildParts();

    static buildTabs() {
        super.TABS.sheet.tabs.push({ id: 'dh', src: 'systems/daggerheart/assets/logos/FoundryBorneLogoWhite.svg' });
        return super.TABS;
    }

    static TABS = DhSceneConfigSettings.buildTabs();

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        switch (partId) {
            case 'dh':
                htmlElement.querySelector('#rangeMeasurementSetting')?.addEventListener('change', async event => {
                    const flagData = foundry.utils.mergeObject(this.document.flags.daggerheart, {
                        rangeMeasurement: { setting: event.target.value }
                    });
                    this.document.flags.daggerheart = flagData;
                    this.render();
                });
                break;
        }
    }

    /** @inheritDoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'dh':
                context.data = new game.system.api.data.scenes.DHScene(canvas.scene.flags.daggerheart);
                context.variantRules = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules);
                break;
        }

        return context;
    }

    // static async updateData(event, _, formData) {
    //     const data = foundry.utils.expandObject(formData.object);
    //     this.close(data);
    // }
}

var _module$e = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhSceneConfigSettings: DhSceneConfigSettings
});

class DhAppearance extends foundry.abstract.DataModel {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.SETTINGS.Appearance'];

    static defineSchema() {
        const { StringField, ColorField, BooleanField, SchemaField } = foundry.data.fields;

        // helper to create dice style schema
        const diceStyle = ({ fg, bg, outline, edge }) =>
            new SchemaField({
                foreground: new ColorField({ required: true, initial: fg }),
                background: new ColorField({ required: true, initial: bg }),
                outline: new ColorField({ required: true, initial: outline }),
                edge: new ColorField({ required: true, initial: edge }),
                texture: new StringField({ initial: 'astralsea', required: true, blank: false }),
                colorset: new StringField({ initial: 'inspired', required: true, blank: false }),
                material: new StringField({ initial: 'metal', required: true, blank: false }),
                system: new StringField({ initial: 'standard', required: true, blank: false }),
                font: new StringField({ initial: 'auto', required: true, blank: false })
            });

        return {
            useResourcePips: new BooleanField({ initial: false }),
            displayFear: new StringField({
                required: true,
                choices: CONFIG.DH.GENERAL.fearDisplay,
                initial: CONFIG.DH.GENERAL.fearDisplay.token.value
            }),
            displayCountdownUI: new BooleanField({ initial: true }),
            diceSoNice: new SchemaField({
                hope: diceStyle({ fg: '#ffffff', bg: '#ffe760', outline: '#000000', edge: '#ffffff' }),
                fear: diceStyle({ fg: '#000000', bg: '#0032b1', outline: '#ffffff', edge: '#000000' }),
                advantage: diceStyle({ fg: '#ffffff', bg: '#008000', outline: '#000000', edge: '#ffffff' }),
                disadvantage: diceStyle({ fg: '#000000', bg: '#b30000', outline: '#ffffff', edge: '#000000' })
            }),
            extendCharacterDescriptions: new BooleanField(),
            extendAdversaryDescriptions: new BooleanField(),
            extendEnvironmentDescriptions: new BooleanField(),
            extendItemDescriptions: new BooleanField(),
            expandRollMessage: new SchemaField({
                desc: new BooleanField(),
                roll: new BooleanField(),
                damage: new BooleanField(),
                target: new BooleanField()
            }),
            hideAttribution: new BooleanField(),
            showGenericStatusEffects: new BooleanField({ initial: true })
        };
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$9, ApplicationV2: ApplicationV2$9 } = foundry.applications.api;

/**
 * @import {ApplicationClickAction} from "@client/applications/_types.mjs"
 */

class DHAppearanceSettings extends HandlebarsApplicationMixin$9(ApplicationV2$9) {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-appearance-settings',
        classes: ['daggerheart', 'dialog', 'dh-style', 'setting'],
        position: { width: '600', height: 'auto' },
        window: {
            title: 'DAGGERHEART.SETTINGS.Menu.title',
            icon: 'fa-solid fa-gears'
        },
        actions: {
            reset: DHAppearanceSettings.#onReset,
            preview: DHAppearanceSettings.#onPreview
        },
        form: {
            closeOnSubmit: true,
            handler: DHAppearanceSettings.#onSubmit
        }
    };

    static PARTS = {
        header: { template: 'systems/daggerheart/templates/settings/appearance-settings/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        main: { template: 'systems/daggerheart/templates/settings/appearance-settings/main.hbs' },
        diceSoNice: { template: 'systems/daggerheart/templates/settings/appearance-settings/diceSoNice.hbs' },
        footer: { template: 'templates/generic/form-footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        general: {
            tabs: [
                { id: 'main', label: 'DAGGERHEART.GENERAL.Tabs.general' },
                { id: 'diceSoNice', label: 'DAGGERHEART.SETTINGS.Menu.appearance.diceSoNice.title' }
            ],
            initial: 'main'
        },
        diceSoNice: {
            tabs: [
                { id: 'hope', label: 'DAGGERHEART.GENERAL.hope' },
                { id: 'fear', label: 'DAGGERHEART.GENERAL.fear' },
                { id: 'advantage', label: 'DAGGERHEART.GENERAL.Advantage.full' },
                { id: 'disadvantage', label: 'DAGGERHEART.GENERAL.Disadvantage.full' }
            ],
            initial: 'hope'
        }
    };

    /**@type {DhAppearance}*/
    setting;

    static #localized = false;

    /** @inheritDoc */
    async _preFirstRender(_context, _options) {
        await super._preFirstRender(_context, _options);
        if (!DHAppearanceSettings.#localized) {
            foundry.helpers.Localization.localizeDataModel(this.setting.constructor);
            DHAppearanceSettings.#localized = true;
        }
    }

    /** @inheritdoc */
    _configureRenderParts(options) {
        const parts = super._configureRenderParts(options);
        if (!game.modules.get('dice-so-nice')?.active) {
            delete parts.diceSoNice;
            delete parts.tabs;
        }
        return parts;
    }

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        if (options.isFirstRender)
            this.setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance);

        context.setting = this.setting;
        context.fields = this.setting.schema.fields;

        context.tabs = this._prepareTabs('general');
        context.dsnTabs = this._prepareTabs('diceSoNice');

        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        const partContext = await super._preparePartContext(partId, context, options);
        if (partId in context.tabs) partContext.tab = partContext.tabs[partId];
        switch (partId) {
            case 'diceSoNice':
                await this.prepareDiceSoNiceContext(partContext);
                break;
            case 'footer':
                partContext.buttons = [
                    { type: 'button', action: 'reset', icon: 'fa-solid fa-arrow-rotate-left', label: 'Reset' },
                    { type: 'submit', icon: 'fa-solid fa-floppy-disk', label: 'Save Changes' }
                ];
                break;
        }
        return partContext;
    }

    /**
     * Prepare render context for the DSN part.
     * @param {ApplicationRenderContext} context
     * @returns {Promise<void>}
     * @protected
     */
    async prepareDiceSoNiceContext(context) {
        context.diceSoNiceTextures = Object.entries(game.dice3d.exports.TEXTURELIST).reduce(
            (acc, [k, v]) => ({
                ...acc,
                [k]: v.name
            }),
            {}
        );
        context.diceSoNiceColorsets = Object.values(game.dice3d.exports.COLORSETS).reduce(
            (acc, v) => ({
                ...acc,
                [v.id]: v.description
            }),
            {}
        );
        context.diceSoNiceMaterials = Object.keys(game.dice3d.DiceFactory.material_options).reduce(
            (acc, key) => ({
                ...acc,
                [key]: `DICESONICE.Material${key.capitalize()}`
            }),
            {}
        );
        context.diceSoNiceSystems = Object.fromEntries(
            [...game.dice3d.DiceFactory.systems].map(([k, v]) => [k, v.name])
        );
        context.diceSoNiceFonts = game.dice3d.exports.Utils.prepareFontList();

        foundry.utils.mergeObject(
            context.dsnTabs,
            ['hope', 'fear', 'advantage', 'disadvantage'].reduce(
                (acc, key) => ({
                    ...acc,
                    [key]: {
                        values: this.setting.diceSoNice[key],
                        fields: this.setting.schema.getField(`diceSoNice.${key}`).fields
                    }
                }),
                {}
            )
        );
    }

    /**
     * Submit the configuration form.
     * @this {DHAppearanceSettings}
     * @param {SubmitEvent} event
     * @param {HTMLFormElement} form
     * @param {foundry.applications.ux.FormDataExtended} formData
     * @returns {Promise<void>}
     */
    static async #onSubmit(event, form, formData) {
        const data = this.setting.schema.clean(foundry.utils.expandObject(formData.object));
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance, data);
    }

    /* -------------------------------------------- */

    /**
     * Submit the configuration form.
     * @this {DHAppearanceSettings}
     * @type {ApplicationClickAction}
     */
    static async #onPreview(_, target) {
        const formData = new foundry.applications.ux.FormDataExtended(target.closest('form'));
        const { diceSoNice } = foundry.utils.expandObject(formData.object);
        const { key } = target.dataset;
        const faces = ['advantage', 'disadvantage'].includes(key) ? 'd6' : 'd12';
        const preset = await getDiceSoNicePreset(diceSoNice[key], faces);
        const diceSoNiceRoll = await new foundry.dice.Roll(`1${faces}`).evaluate();
        diceSoNiceRoll.dice[0].options.appearance = preset.appearance;
        diceSoNiceRoll.dice[0].options.modelFile = preset.modelFile;
        await game.dice3d.showForRoll(diceSoNiceRoll, game.user, false);
    }

    /**
     * Reset the form back to default values.
     * @this {DHAppearanceSettings}
     * @type {ApplicationClickAction}
     */
    static async #onReset() {
        this.setting = new this.setting.constructor();
        this.render({ force: false });
    }
}

class DhAutomation extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            summaryMessages: new fields.SchemaField({
                damage: new fields.BooleanField({ initial: true, label: 'DAGGERHEART.GENERAL.damage' }),
                effects: new fields.BooleanField({ initial: true, label: 'DAGGERHEART.GENERAL.Effect.plural' })
            }),
            hopeFear: new fields.SchemaField({
                gm: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.hopeFear.gm.label'
                }),
                players: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.hopeFear.players.label'
                })
            }),
            countdownAutomation: new fields.BooleanField({
                required: true,
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.countdownAutomation.label'
            }),
            levelupAuto: new fields.BooleanField({
                required: true,
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.levelupAuto.label'
            }),
            actionPoints: new fields.BooleanField({
                required: true,
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.actionPoints.label'
            }),
            hordeDamage: new fields.BooleanField({
                required: true,
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.hordeDamage.label'
            }),
            effects: new fields.SchemaField({
                rangeDependent: new fields.BooleanField({
                    initial: true,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.effects.rangeDependent.label'
                })
            }),
            damageReductionRulesDefault: new fields.StringField({
                required: true,
                choices: CONFIG.DH.GENERAL.ruleChoice,
                initial: CONFIG.DH.GENERAL.ruleChoice.onWithToggle.id,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.damageReductionRulesDefault.label'
            }),
            resourceScrollTexts: new fields.BooleanField({
                required: true,
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.resourceScrollTexts.label'
            }),
            playerCanEditSheet: new fields.BooleanField({
                required: true,
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.playerCanEditSheet.label'
            }),
            defeated: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.enabled.label'
                }),
                overlay: new fields.BooleanField({
                    required: true,
                    initial: true,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.overlay.label'
                }),
                characterDefault: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.defeatedConditionChoices,
                    initial: CONFIG.DH.GENERAL.defeatedConditionChoices.unconscious.id,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.characterDefault.label'
                }),
                adversaryDefault: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.defeatedConditionChoices,
                    initial: CONFIG.DH.GENERAL.defeatedConditionChoices.dead.id,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.adversaryDefault.label'
                }),
                companionDefault: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.defeatedConditionChoices,
                    initial: CONFIG.DH.GENERAL.defeatedConditionChoices.defeated.id,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.companionDefault.label'
                }),
                deadIcon: new fields.FilePathField({
                    initial: 'icons/magic/death/grave-tombstone-glow-teal.webp',
                    categories: ['IMAGE'],
                    base64: false,
                    label: 'Dead'
                }),
                defeatedIcon: new fields.FilePathField({
                    initial: 'icons/magic/control/fear-fright-mask-orange.webp',
                    categories: ['IMAGE'],
                    base64: false,
                    label: 'Defeated'
                }),
                unconsciousIcon: new fields.FilePathField({
                    initial: 'icons/magic/control/sleep-bubble-purple.webp',
                    categories: ['IMAGE'],
                    base64: false,
                    label: 'Unconcious'
                })
            }),
            roll: new fields.SchemaField({
                roll: new fields.SchemaField({
                    gm: new fields.BooleanField({
                        required: true,
                        initial: false,
                        label: 'DAGGERHEART.GENERAL.gm'
                    }),
                    players: new fields.BooleanField({
                        required: true,
                        initial: false,
                        label: 'DAGGERHEART.GENERAL.player.plurial'
                    })
                }),
                damage: new fields.SchemaField({
                    gm: new fields.StringField({
                        required: true,
                        initial: 'never',
                        choices: CONFIG.DH.SETTINGS.actionAutomationChoices,
                        label: 'DAGGERHEART.GENERAL.gm'
                    }),
                    players: new fields.StringField({
                        required: true,
                        initial: 'never',
                        choices: CONFIG.DH.SETTINGS.actionAutomationChoices,
                        label: 'DAGGERHEART.GENERAL.player.plurial'
                    })
                }),
                save: new fields.SchemaField({
                    gm: new fields.StringField({
                        required: true,
                        initial: 'never',
                        choices: CONFIG.DH.SETTINGS.actionAutomationChoices,
                        label: 'DAGGERHEART.GENERAL.gm'
                    }),
                    players: new fields.StringField({
                        required: true,
                        initial: 'never',
                        choices: CONFIG.DH.SETTINGS.actionAutomationChoices,
                        label: 'DAGGERHEART.GENERAL.player.plurial'
                    })
                }),
                damageApply: new fields.SchemaField({
                    gm: new fields.BooleanField({
                        required: true,
                        initial: false,
                        label: 'DAGGERHEART.GENERAL.gm'
                    }),
                    players: new fields.BooleanField({
                        required: true,
                        initial: false,
                        label: 'DAGGERHEART.GENERAL.player.plurial'
                    })
                }),
                effect: new fields.SchemaField({
                    gm: new fields.BooleanField({
                        required: true,
                        initial: false,
                        label: 'DAGGERHEART.GENERAL.gm'
                    }),
                    players: new fields.BooleanField({
                        required: true,
                        initial: false,
                        label: 'DAGGERHEART.GENERAL.player.plurial'
                    })
                })
            })
        };
    }
}

const currencyField = (initial, label) =>
    new foundry.data.fields.SchemaField({
        enabled: new foundry.data.fields.BooleanField({ required: true, initial: true }),
        label: new foundry.data.fields.StringField({
            required: true,
            initial,
            label
        })
    });

class DhHomebrew extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            maxFear: new fields.NumberField({
                required: true,
                integer: true,
                min: 0,
                initial: 12,
                label: 'DAGGERHEART.SETTINGS.Homebrew.FIELDS.maxFear.label'
            }),
            maxLoadout: new fields.NumberField({
                required: true,
                integer: true,
                min: 0,
                initial: 5,
                label: 'DAGGERHEART.SETTINGS.Homebrew.FIELDS.maxLoadout.label'
            }),
            maxDomains: new fields.NumberField({
                required: true,
                integer: true,
                min: 1,
                initial: 2,
                label: 'DAGGERHEART.SETTINGS.Homebrew.FIELDS.maxDomains.label'
            }),
            traitArray: new fields.ArrayField(new fields.NumberField({ required: true, integer: true }), {
                initial: () => [2, 1, 1, 0, 0, -1]
            }),
            currency: new fields.SchemaField({
                title: new fields.StringField({
                    required: true,
                    initial: 'Gold',
                    label: 'DAGGERHEART.SETTINGS.Homebrew.currency.currencyName'
                }),
                coins: currencyField('Coins', 'DAGGERHEART.SETTINGS.Homebrew.currency.coinName'),
                handfuls: currencyField('Handfuls', 'DAGGERHEART.SETTINGS.Homebrew.currency.handfulName'),
                bags: currencyField('Bags', 'DAGGERHEART.SETTINGS.Homebrew.currency.bagName'),
                chests: currencyField('Chests', 'DAGGERHEART.SETTINGS.Homebrew.currency.chestName')
            }),
            restMoves: new fields.SchemaField({
                longRest: new fields.SchemaField({
                    nrChoices: new fields.NumberField({ required: true, integer: true, min: 1, initial: 2 }),
                    moves: new fields.TypedObjectField(
                        new fields.SchemaField({
                            name: new fields.StringField({ required: true }),
                            icon: new fields.StringField({ required: true }),
                            img: new fields.FilePathField({
                                initial: 'icons/magic/life/cross-worn-green.webp',
                                categories: ['IMAGE'],
                                base64: false
                            }),
                            description: new fields.HTMLField(),
                            actions: new ActionsField()
                        }),
                        { initial: defaultRestOptions.longRest() }
                    )
                }),
                shortRest: new fields.SchemaField({
                    nrChoices: new fields.NumberField({ required: true, integer: true, min: 1, initial: 2 }),
                    moves: new fields.TypedObjectField(
                        new fields.SchemaField({
                            name: new fields.StringField({ required: true }),
                            icon: new fields.StringField({ required: true }),
                            img: new fields.FilePathField({
                                initial: 'icons/magic/life/cross-worn-green.webp',
                                categories: ['IMAGE'],
                                base64: false
                            }),
                            description: new fields.HTMLField(),
                            actions: new ActionsField()
                        }),
                        { initial: defaultRestOptions.shortRest() }
                    )
                })
            }),
            domains: new fields.TypedObjectField(
                new fields.SchemaField({
                    id: new fields.StringField({ required: true }),
                    label: new fields.StringField({ required: true, initial: '', label: 'DAGGERHEART.GENERAL.label' }),
                    src: new fields.FilePathField({
                        categories: ['IMAGE'],
                        base64: false,
                        label: 'Image'
                    }),
                    description: new fields.HTMLField()
                })
            ),
            adversaryTypes: new fields.TypedObjectField(
                new fields.SchemaField({
                    id: new fields.StringField({ required: true }),
                    label: new fields.StringField({ required: true, label: 'DAGGERHEART.GENERAL.label' }),
                    description: new fields.StringField()
                })
            ),
            itemFeatures: new fields.SchemaField({
                weaponFeatures: new fields.TypedObjectField(
                    new fields.SchemaField({
                        name: new fields.StringField({ required: true }),
                        img: new fields.FilePathField({
                            initial: 'icons/magic/life/cross-worn-green.webp',
                            categories: ['IMAGE'],
                            base64: false
                        }),
                        description: new fields.HTMLField(),
                        actions: new ActionsField(),
                        effects: new fields.ArrayField(new fields.ObjectField())
                    })
                ),
                armorFeatures: new fields.TypedObjectField(
                    new fields.SchemaField({
                        name: new fields.StringField({ required: true }),
                        img: new fields.FilePathField({
                            initial: 'icons/magic/life/cross-worn-green.webp',
                            categories: ['IMAGE'],
                            base64: false
                        }),
                        description: new fields.HTMLField(),
                        actions: new ActionsField(),
                        effects: new fields.ArrayField(new fields.ObjectField())
                    })
                )
            })
        };
    }

    /** @inheritDoc */
    _initializeSource(source, options = {}) {
        source = super._initializeSource(source, options);
        source.currency.coins = {
            enabled: source.currency.coins.enabled ?? true,
            label: source.currency.coins.label || source.currency.coins
        };
        source.currency.handfuls = {
            enabled: source.currency.handfuls.enabled ?? true,
            label: source.currency.handfuls.label || source.currency.handfuls
        };
        source.currency.bags = {
            enabled: source.currency.bags.enabled ?? true,
            label: source.currency.bags.label || source.currency.bags
        };
        source.currency.chests = {
            enabled: source.currency.chests.enabled ?? true,
            label: source.currency.chests.label || source.currency.chests
        };
        return source;
    }
}

class DhVariantRules extends foundry.abstract.DataModel {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.SETTINGS.VariantRules'];

    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            actionTokens: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.VariantRules.FIELDS.actionTokens.enabled.label'
                }),
                tokens: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 3,
                    label: 'DAGGERHEART.SETTINGS.VariantRules.FIELDS.actionTokens.tokens.label'
                })
            }),
            rangeMeasurement: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: true,
                    label: 'DAGGERHEART.GENERAL.enabled'
                }),
                melee: new fields.NumberField({
                    required: true,
                    initial: 5,
                    label: 'DAGGERHEART.CONFIG.Range.melee.name'
                }),
                veryClose: new fields.NumberField({
                    required: true,
                    initial: 15,
                    label: 'DAGGERHEART.CONFIG.Range.veryClose.name'
                }),
                close: new fields.NumberField({
                    required: true,
                    initial: 30,
                    label: 'DAGGERHEART.CONFIG.Range.close.name'
                }),
                far: new fields.NumberField({ required: true, initial: 60, label: 'DAGGERHEART.CONFIG.Range.far.name' })
            })
        };
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$8, ApplicationV2: ApplicationV2$8 } = foundry.applications.api;

class DhAutomationSettings extends HandlebarsApplicationMixin$8(ApplicationV2$8) {
    constructor() {
        super({});

        this.settings = new DhAutomation(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).toObject()
        );
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Menu.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-automation-settings',
        classes: ['daggerheart', 'dh-style', 'dialog', 'setting'],
        position: { width: '600', height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            reset: this.reset,
            save: this.save
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        header: { template: 'systems/daggerheart/templates/settings/automation-settings/header.hbs' },
        general: { template: 'systems/daggerheart/templates/settings/automation-settings/general.hbs' },
        rules: { template: 'systems/daggerheart/templates/settings/automation-settings/rules.hbs' },
        roll: { template: 'systems/daggerheart/templates/settings/automation-settings/roll.hbs' },
        footer: { template: 'systems/daggerheart/templates/settings/automation-settings/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        main: {
            tabs: [{ id: 'general' }, { id: 'rules' }, { id: 'roll' }],
            initial: 'general',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.settingFields = this.settings;

        return context;
    }

    static async updateData(event, element, formData) {
        const updatedSettings = foundry.utils.expandObject(formData.object);

        await this.settings.updateSource(updatedSettings);
        this.render();
    }

    static async reset() {
        this.settings = new DhAutomation();
        this.render();
    }

    static async save() {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation, this.settings.toObject());
        this.close();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$7, ApplicationV2: ApplicationV2$7 } = foundry.applications.api;

class DhHomebrewSettings extends HandlebarsApplicationMixin$7(ApplicationV2$7) {
    constructor() {
        super({});

        this.settings = new DhHomebrew(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).toObject()
        );

        this.selected = this.#getDefaultAdversaryType();
    }

    #getDefaultAdversaryType = () => ({
        domain: null,
        adversaryType: null
    });

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Menu.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-homebrew-settings',
        classes: ['daggerheart', 'dh-style', 'dialog', 'setting', 'homebrew-settings'],
        position: { width: '600', height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            addItem: this.addItem,
            editItem: this.editItem,
            removeItem: this.removeItem,
            resetMoves: this.resetMoves,
            addDomain: this.addDomain,
            toggleSelectedDomain: this.toggleSelectedDomain,
            deleteDomain: this.deleteDomain,
            addAdversaryType: this.addAdversaryType,
            deleteAdversaryType: this.deleteAdversaryType,
            selectAdversaryType: this.selectAdversaryType,
            save: this.save,
            reset: this.reset
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        settings: { template: 'systems/daggerheart/templates/settings/homebrew-settings/settings.hbs' },
        domains: { template: 'systems/daggerheart/templates/settings/homebrew-settings/domains.hbs' },
        types: { template: 'systems/daggerheart/templates/settings/homebrew-settings/types.hbs' },
        itemTypes: { template: 'systems/daggerheart/templates/settings/homebrew-settings/itemFeatures.hbs' },
        downtime: { template: 'systems/daggerheart/templates/settings/homebrew-settings/downtime.hbs' },
        footer: { template: 'systems/daggerheart/templates/settings/homebrew-settings/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        main: {
            tabs: [{ id: 'settings' }, { id: 'domains' }, { id: 'types' }, { id: 'itemFeatures' }, { id: 'downtime' }],
            initial: 'settings',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    changeTab(tab, group, options) {
        super.changeTab(tab, group, options);
        this.selected = this.#getDefaultAdversaryType();

        this.render();
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.settingFields = this.settings;

        return context;
    }

    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        switch (partId) {
            case 'domains':
                const selectedDomain = this.selected.domain ? this.settings.domains[this.selected.domain] : null;
                const enrichedDescription = selectedDomain
                    ? await foundry.applications.ux.TextEditor.implementation.enrichHTML(selectedDomain.description)
                    : null;

                if (enrichedDescription !== null) context.selectedDomain = { ...selectedDomain, enrichedDescription };
                context.configDomains = CONFIG.DH.DOMAIN.domains;
                context.homebrewDomains = this.settings.domains;
                break;
            case 'types':
                context.selectedAdversaryType = this.selected.adversaryType
                    ? { id: this.selected.adversaryType, ...this.settings.adversaryTypes[this.selected.adversaryType] }
                    : null;
                break;
        }

        return context;
    }

    static async updateData(_event, _element, formData) {
        const updatedSettings = foundry.utils.expandObject(formData.object);

        await this.settings.updateSource({
            ...updatedSettings,
            traitArray: Object.values(updatedSettings.traitArray)
        });
        this.render();
    }

    static async addItem(_, target) {
        const { type } = target.dataset;
        if (['shortRest', 'longRest'].includes(type)) {
            await this.settings.updateSource({
                [`restMoves.${type}.moves.${foundry.utils.randomID()}`]: {
                    name: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.newDowntimeMove'),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    description: '',
                    actions: []
                }
            });
        } else if (['armorFeatures', 'weaponFeatures'].includes(type)) {
            await this.settings.updateSource({
                [`itemFeatures.${type}.${foundry.utils.randomID()}`]: {
                    name: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.newFeature'),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    description: '',
                    actions: [],
                    effects: []
                }
            });
        }

        this.render();
    }

    static async editItem(_, target) {
        const { type, id } = target.dataset;
        const isDowntime = ['shortRest', 'longRest'].includes(type);
        const path = isDowntime ? `restMoves.${type}.moves.${id}` : `itemFeatures.${type}.${id}`;
        const featureBase = isDowntime ? this.settings.restMoves[type].moves[id] : this.settings.itemFeatures[type][id];

        const configTitle = isDowntime
            ? game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.downtimeMove')
            : type === 'armorFeatures'
              ? game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.armorFeature')
              : game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.weaponFeature');

        const editedBase = await game.system.api.applications.sheetConfigs.SettingFeatureConfig.configure(
            configTitle,
            featureBase,
            path,
            this.settings,
            { hasIcon: isDowntime, hasEffects: !isDowntime }
        );
        if (!editedBase) return;

        await this.updateAction.bind(this)(editedBase, target.dataset.type, target.dataset.id);
    }

    async updateAction(data, type, id) {
        const isDowntime = ['shortRest', 'longRest'].includes(type);
        const path = isDowntime ? `restMoves.${type}.moves` : `itemFeatures.${type}`;
        await this.settings.updateSource({
            [`${path}.${id}`]: {
                actions: data.actions,
                name: data.name,
                icon: data.icon,
                img: data.img,
                description: data.description
            }
        });

        this.render();
    }

    static async removeItem(_, target) {
        const { type, id } = target.dataset;
        const isDowntime = ['shortRest', 'longRest'].includes(type);
        const path = isDowntime ? `restMoves.${type}.moves` : `itemFeatures.${type}`;
        await this.settings.updateSource({
            [`${path}.-=${id}`]: null
        });
        this.render();
    }

    static async resetMoves(_, target) {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.SETTINGS.Homebrew.resetMovesTitle', {
                    type: game.i18n.localize(
                        `DAGGERHEART.APPLICATIONS.Downtime.${target.dataset.type === 'shortRest' ? 'shortRest' : 'longRest'}.title`
                    )
                })
            },
            content: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.resetMovesText')
        });

        if (!confirmed) return;

        const fields = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).schema.fields;

        const removeUpdate = Object.keys(this.settings.restMoves[target.dataset.type].moves).reduce((acc, key) => {
            acc[`-=${key}`] = null;

            return acc;
        }, {});

        const updateBase =
            target.dataset.type === 'shortRest'
                ? fields.restMoves.fields.shortRest.fields
                : fields.restMoves.fields.longRest.fields;
        const update = {
            nrChoices: updateBase.nrChoices.initial,
            moves: Object.keys(updateBase.moves.initial).reduce((acc, key) => {
                const move = updateBase.moves.initial[key];
                acc[key] = {
                    ...move,
                    name: game.i18n.localize(move.name),
                    description: game.i18n.localize(move.description),
                    actions: move.actions.reduce((acc, key) => {
                        const action = move.actions[key];
                        acc[key] = {
                            ...action,
                            name: game.i18n.localize(action.name)
                        };
                        return acc;
                    }, {})
                };

                return acc;
            }, {})
        };

        await this.settings.updateSource({
            [`restMoves.${target.dataset.type}`]: {
                ...update,
                moves: {
                    ...removeUpdate,
                    ...update.moves
                }
            }
        });

        this.render();
    }

    static async addDomain(event) {
        event.preventDefault();
        const content = new foundry.data.fields.StringField({
            label: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.newDomainInputLabel'),
            hint: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.newDomainInputHint'),
            required: true
        }).toFormGroup({}, { name: 'domainName', localize: true }).outerHTML;

        async function callback(_, button) {
            const domainName = button.form.elements.domainName.value;
            if (!domainName) return;

            const newSlug = slugify(domainName);
            const existingDomains = [
                ...Object.values(this.settings.domains),
                ...Object.values(CONFIG.DH.DOMAIN.domains)
            ];
            if (existingDomains.find(x => slugify(game.i18n.localize(x.label)) === newSlug)) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.duplicateDomain'));
                return;
            }

            this.settings.updateSource({
                [`domains.${newSlug}`]: {
                    id: newSlug,
                    label: domainName,
                    src: 'icons/svg/portal.svg'
                }
            });

            this.selected.domain = newSlug;
            this.render();
        }

        foundry.applications.api.DialogV2.prompt({
            content: content,
            rejectClose: false,
            modal: true,
            ok: { callback: callback.bind(this) },
            window: {
                title: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.newDomainInputTitle')
            },
            position: { width: 400 }
        });
    }

    static toggleSelectedDomain(_, target) {
        this.selected.domain = this.selected.domain === target.id ? null : target.id;
        this.render();
    }

    static async deleteDomain() {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.deleteDomain')
            },
            content: game.i18n.format('DAGGERHEART.SETTINGS.Homebrew.domains.deleteDomainText', {
                name: this.settings.domains[this.selected.domain].label
            })
        });

        if (!confirmed) return;

        await this.settings.updateSource({
            [`domains.-=${this.selected.domain}`]: null
        });

        const currentSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew);
        if (currentSettings.domains[this.selected.domain]) {
            await currentSettings.updateSource({ [`domains.-=${this.selected.domain}`]: null });
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew, currentSettings);
        }

        const updateClasses = game.items.filter(x => x.type === 'class');
        for (let actor of game.actors) {
            updateClasses.push(...actor.items.filter(x => x.type === 'class'));
        }

        for (let c of updateClasses) {
            if (c.system.domains.includes(this.selected.domain)) {
                const newDomains =
                    c.system.domains.length === 1
                        ? [CONFIG.DH.DOMAIN.domains.arcana.id]
                        : c.system.domains.filter(x => x !== this.selected.domain);
                await c.update({ 'system.domains': newDomains });
            }
            c.sheet.render();
        }

        const updateDomainCards = game.items.filter(
            x => x.type === 'domainCard' && x.system.domain === this.selected.domain
        );
        for (let d of updateDomainCards) {
            await d.update({ 'system.domain': CONFIG.DH.DOMAIN.domains.arcana.id });
            d.sheet.render();
        }

        this.selected.domain = null;
        this.render();
    }

    static async addAdversaryType(_, target) {
        const newId = foundry.utils.randomID();
        await this.settings.updateSource({
            [`adversaryTypes.${newId}`]: {
                id: newId,
                label: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.adversaryType.newType')
            }
        });

        this.selected.adversaryType = newId;
        this.render();
    }

    static async deleteAdversaryType(_, target) {
        const { key } = target.dataset;
        await this.settings.updateSource({ [`adversaryTypes.-=${key}`]: null });

        this.selected.adversaryType = this.selected.adversaryType === key ? null : this.selected.adversaryType;
        this.render();
    }

    static async selectAdversaryType(_, target) {
        this.selected.adversaryType = this.selected.adversaryType === target.dataset.type ? null : target.dataset.type;
        this.render();
    }

    static async save() {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew, this.settings.toObject());
        this.close();
    }

    static async reset() {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.SETTINGS.ResetSettings.resetConfirmationTitle')
            },
            content: game.i18n.format('DAGGERHEART.SETTINGS.ResetSettings.resetConfirmationText', {
                settings: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.name')
            })
        });
        if (!confirmed) return;

        const resetSettings = new DhHomebrew();
        let localizedSettings = this.localizeObject(resetSettings.toObject());
        this.settings.updateSource(localizedSettings);
        this.render();
    }

    localizeObject(obj) {
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                if (typeof value === 'object' && value !== null) {
                    obj[key] = this.localizeObject(value);
                } else {
                    if (typeof value === 'string' && value.startsWith('DAGGERHEART.')) {
                        obj[key] = game.i18n.localize(value);
                    }
                }
            }
        }
        return obj;
    }

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
            v.cssClass = v.active ? 'active' : '';
        }

        return tabs;
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$6, ApplicationV2: ApplicationV2$6 } = foundry.applications.api;

class DHVariantRuleSettings extends HandlebarsApplicationMixin$6(ApplicationV2$6) {
    constructor() {
        super({});

        this.settings = new DhVariantRules(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).toObject()
        );
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Menu.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-appearance-settings',
        classes: ['daggerheart', 'dialog', 'dh-style', 'setting'],
        position: { width: '600', height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            reset: this.reset,
            save: this.save
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        main: {
            template: 'systems/daggerheart/templates/settings/variant-rules.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.settingFields = this.settings;

        return context;
    }

    static async updateData(event, element, formData) {
        const updatedSettings = foundry.utils.expandObject(formData.object);

        await this.settings.updateSource(updatedSettings);
        this.render();
    }

    static async reset() {
        this.settings = new DhVariantRules();
        this.render();
    }

    static async save() {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules, this.settings.toObject());
        this.close();
    }
}

var _module$d = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhAppearanceSettings: DHAppearanceSettings,
    DhAutomationSettings: DhAutomationSettings,
    DhHomebrewSettings: DhHomebrewSettings,
    DhVariantRuleSettings: DHVariantRuleSettings
});

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class AdversarySheet extends DHBaseActorSheet {
    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['adversary'],
        position: { width: 660, height: 766 },
        window: { resizable: true },
        actions: {
            toggleHitPoints: AdversarySheet.#toggleHitPoints,
            toggleStress: AdversarySheet.#toggleStress,
            reactionRoll: AdversarySheet.#reactionRoll,
            toggleResourceDice: AdversarySheet.#toggleResourceDice,
            handleResourceDice: AdversarySheet.#handleResourceDice
        },
        window: {
            resizable: true,
            controls: [
                {
                    icon: 'fa-solid fa-signature',
                    label: 'DAGGERHEART.UI.Tooltip.configureAttribution',
                    action: 'editAttribution'
                }
            ]
        },
        dragDrop: [{ dragSelector: '[data-item-id][draggable="true"]', dropSelector: null }]
    };

    static PARTS = {
        limited: {
            template: 'systems/daggerheart/templates/sheets/actors/adversary/limited.hbs',
            scrollable: ['.limited-container']
        },
        sidebar: {
            template: 'systems/daggerheart/templates/sheets/actors/adversary/sidebar.hbs',
            scrollable: ['.shortcut-items-section']
        },
        header: { template: 'systems/daggerheart/templates/sheets/actors/adversary/header.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/actors/adversary/features.hbs',
            scrollable: ['.feature-section']
        },
        notes: {
            template: 'systems/daggerheart/templates/sheets/actors/adversary/notes.hbs'
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/actors/adversary/effects.hbs',
            scrollable: ['.effects-sections']
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'features' }, { id: 'effects' }, { id: 'notes' }],
            initial: 'features',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**  @inheritdoc */
    _initializeApplicationOptions(options) {
        const applicationOptions = super._initializeApplicationOptions(options);

        if (applicationOptions.document.testUserPermission(game.user, 'LIMITED', { exact: true })) {
            applicationOptions.position.width = 360;
            applicationOptions.position.height = 'auto';
        }

        return applicationOptions;
    }

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.systemFields.attack.fields = this.document.system.attack.schema.fields;

        context.resources = Object.keys(this.document.system.resources).reduce((acc, key) => {
            acc[key] = this.document.system.resources[key];
            return acc;
        }, {});
        const maxResource = Math.max(context.resources.hitPoints.max, context.resources.stress.max);
        context.resources.hitPoints.emptyPips =
            context.resources.hitPoints.max < maxResource ? maxResource - context.resources.hitPoints.max : 0;
        context.resources.stress.emptyPips =
            context.resources.stress.max < maxResource ? maxResource - context.resources.stress.max : 0;

        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'header':
            case 'limited':
                await this._prepareHeaderContext(context, options);

                const adversaryTypes = CONFIG.DH.ACTOR.allAdversaryTypes();
                context.adversaryType = game.i18n.localize(adversaryTypes[this.document.system.type].label);
                break;
            case 'notes':
                await this._prepareNotesContext(context, options);
                break;
        }
        return context;
    }

    /**@inheritdoc */
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.inventory-item-resource').forEach(element => {
            element.addEventListener('change', this.updateItemResource.bind(this));
            element.addEventListener('click', e => e.stopPropagation());
        });
    }

    /**
     * Prepare render context for the Biography part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareNotesContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        const paths = {
            notes: 'notes'
        };

        for (const [key, path] of Object.entries(paths)) {
            const value = foundry.utils.getProperty(system, path);
            context[key] = {
                field: system.schema.getField(path),
                value,
                enriched: await TextEditor.implementation.enrichHTML(value, {
                    secrets: this.document.isOwner,
                    relativeTo: this.document
                })
            };
        }
    }

    /**
     * Prepare render context for the Header part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareHeaderContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        context.description = await TextEditor.implementation.enrichHTML(system.description, {
            secrets: this.document.isOwner,
            relativeTo: this.document
        });
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Toggles hitpoint resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleHitPoints(_, button) {
        const hitPointsValue = Number.parseInt(button.dataset.value);
        const newValue =
            this.document.system.resources.hitPoints.value >= hitPointsValue ? hitPointsValue - 1 : hitPointsValue;
        await this.document.update({ 'system.resources.hitPoints.value': newValue });
    }

    /**
     * Toggles stress resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleStress(_, button) {
        const StressValue = Number.parseInt(button.dataset.value);
        const newValue = this.document.system.resources.stress.value >= StressValue ? StressValue - 1 : StressValue;
        await this.document.update({ 'system.resources.stress.value': newValue });
    }

    /**
     * Performs a reaction roll for an Adversary.
     * @type {ApplicationClickAction}
     */
    static #reactionRoll(event) {
        const config = {
            event,
            title: `Reaction Roll: ${this.actor.name}`,
            headerTitle: 'Adversary Reaction Roll',
            roll: {
                type: 'trait'
            },
            actionType: 'reaction',
            hasRoll: true,
            data: this.actor.getRollData()
        };

        this.actor.diceRoll(config);
    }

    /**
     * Toggle the used state of a resource dice.
     * @type {ApplicationClickAction}
     */
    static async #toggleResourceDice(event, target) {
        const item = await getDocFromElement(target);

        const { dice } = event.target.closest('.item-resource').dataset;
        const diceState = item.system.resource.diceStates[dice];

        await item.update({
            [`system.resource.diceStates.${dice}.used`]: diceState ? !diceState.used : true
        });
    }

    /**
     * Handle the roll values of resource dice.
     * @type {ApplicationClickAction}
     */
    static async #handleResourceDice(_, target) {
        const item = await getDocFromElement(target);
        if (!item) return;

        const rollValues = await game.system.api.applications.dialogs.ResourceDiceDialog.create(item, this.document);
        if (!rollValues) return;

        await item.update({
            'system.resource.diceStates': rollValues.reduce((acc, state, index) => {
                acc[index] = { value: state.value, used: state.used };
                return acc;
            }, {})
        });
    }

    /* -------------------------------------------- */
    /*  Application Listener Actions                */
    /* -------------------------------------------- */

    async updateItemResource(event) {
        const item = await getDocFromElement(event.currentTarget);
        if (!item) return;

        const max = event.currentTarget.max ? Number(event.currentTarget.max) : null;
        const value = max ? Math.min(Number(event.currentTarget.value), max) : event.currentTarget.value;
        await item.update({ 'system.resource.value': value });
        this.render();
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class CharacterSheet extends DHBaseActorSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['character'],
        position: { width: 850, height: 800 },
        /* Foundry adds disabled to all buttons and inputs if editPermission is missing. This is not desired. */
        editPermission: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER,
        actions: {
            toggleVault: CharacterSheet.#toggleVault,
            rollAttribute: CharacterSheet.#rollAttribute,
            toggleHitPoints: CharacterSheet.#toggleHitPoints,
            toggleStress: CharacterSheet.#toggleStress,
            toggleArmor: CharacterSheet.#toggleArmor,
            toggleHope: CharacterSheet.#toggleHope,
            toggleLoadoutView: CharacterSheet.#toggleLoadoutView,
            openPack: CharacterSheet.#openPack,
            makeDeathMove: CharacterSheet.#makeDeathMove,
            levelManagement: CharacterSheet.#levelManagement,
            viewLevelups: CharacterSheet.#viewLevelups,
            toggleEquipItem: CharacterSheet.#toggleEquipItem,
            toggleResourceDice: CharacterSheet.#toggleResourceDice,
            handleResourceDice: CharacterSheet.#handleResourceDice,
            advanceResourceDie: CharacterSheet.#advanceResourceDie,
            cancelBeastform: CharacterSheet.#cancelBeastform,
            useDowntime: this.useDowntime
        },
        window: {
            resizable: true,
            controls: [
                {
                    icon: 'fa-solid fa-angles-up',
                    label: 'DAGGERHEART.ACTORS.Character.viewLevelups',
                    action: 'viewLevelups'
                }
            ]
        },
        dragDrop: [
            {
                dragSelector: '[data-item-id][draggable="true"]',
                dropSelector: null
            }
        ],
        contextMenus: [
            {
                handler: CharacterSheet.#getDomainCardContextOptions,
                selector: '[data-item-uuid][data-type="domainCard"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            },
            {
                handler: CharacterSheet.#getEquipamentContextOptions,
                selector: '[data-item-uuid][data-type="armor"], [data-item-uuid][data-type="weapon"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            },
            {
                handler: CharacterSheet.#getItemContextOptions,
                selector: '[data-item-uuid][data-type="consumable"], [data-item-uuid][data-type="loot"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            }
        ]
    };

    /**@override */
    static PARTS = {
        limited: {
            id: 'limited',
            scrollable: ['.limited-container'],
            template: 'systems/daggerheart/templates/sheets/actors/character/limited.hbs'
        },
        sidebar: {
            id: 'sidebar',
            scrollable: ['.shortcut-items-section'],
            template: 'systems/daggerheart/templates/sheets/actors/character/sidebar.hbs'
        },
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets/actors/character/header.hbs'
        },
        features: {
            id: 'features',
            scrollable: ['.features-sections'],
            template: 'systems/daggerheart/templates/sheets/actors/character/features.hbs'
        },
        loadout: {
            id: 'loadout',
            scrollable: ['.items-section'],
            template: 'systems/daggerheart/templates/sheets/actors/character/loadout.hbs'
        },
        inventory: {
            id: 'inventory',
            scrollable: ['.items-section'],
            template: 'systems/daggerheart/templates/sheets/actors/character/inventory.hbs'
        },
        biography: {
            id: 'biography',
            scrollable: ['.items-section'],
            template: 'systems/daggerheart/templates/sheets/actors/character/biography.hbs'
        },
        effects: {
            id: 'effects',
            scrollable: ['.effects-sections'],
            template: 'systems/daggerheart/templates/sheets/actors/character/effects.hbs'
        }
    };

    /* -------------------------------------------- */

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'features' }, { id: 'loadout' }, { id: 'inventory' }, { id: 'biography' }, { id: 'effects' }],
            initial: 'features',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.inventory-item-resource').forEach(element => {
            element.addEventListener('change', this.updateItemResource.bind(this));
            element.addEventListener('click', e => e.stopPropagation());
        });
        htmlElement.querySelectorAll('.inventory-item-quantity').forEach(element => {
            element.addEventListener('change', this.updateItemQuantity.bind(this));
            element.addEventListener('click', e => e.stopPropagation());
        });

        // Add listener for armor marks input
        htmlElement.querySelectorAll('.armor-marks-input').forEach(element => {
            element.addEventListener('change', this.updateArmorMarks.bind(this));
        });

        htmlElement.querySelectorAll('.item-resource.die').forEach(element => {
            element.addEventListener('contextmenu', this.lowerResourceDie.bind(this));
        });
    }

    /**  @inheritdoc */
    _initializeApplicationOptions(options) {
        const applicationOptions = super._initializeApplicationOptions(options);

        if (applicationOptions.document.testUserPermission(game.user, 'LIMITED', { exact: true })) {
            applicationOptions.position.width = 360;
            applicationOptions.position.height = 'auto';
        }

        return applicationOptions;
    }

    /** @inheritDoc */
    async _onRender(context, options) {
        await super._onRender(context, options);

        if (!this.document.testUserPermission(game.user, 'LIMITED', { exact: true })) {
            this.element
                .querySelector('.level-value')
                ?.addEventListener('change', event => this.document.updateLevel(Number(event.currentTarget.value)));

            const observer = this.document.testUserPermission(game.user, CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER, {
                exact: true
            });
            if (observer) {
                this.element.querySelector('.window-content').classList.add('viewMode');
            }

            this._createFilterMenus();
            this._createSearchFilter();
        }
    }

    /* -------------------------------------------- */
    /*  Prepare Context                             */
    /* -------------------------------------------- */

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);

        context.attributes = Object.keys(this.document.system.traits).reduce((acc, key) => {
            acc[key] = {
                ...this.document.system.traits[key],
                name: game.i18n.localize(CONFIG.DH.ACTOR.abilities[key].name),
                verbs: CONFIG.DH.ACTOR.abilities[key].verbs.map(x => game.i18n.localize(x))
            };

            return acc;
        }, {});

        context.resources = Object.keys(this.document.system.resources).reduce((acc, key) => {
            acc[key] = this.document.system.resources[key];
            return acc;
        }, {});
        const maxResource = Math.max(context.resources.hitPoints.max, context.resources.stress.max);
        context.resources.hitPoints.emptyPips =
            context.resources.hitPoints.max < maxResource ? maxResource - context.resources.hitPoints.max : 0;
        context.resources.stress.emptyPips =
            context.resources.stress.max < maxResource ? maxResource - context.resources.stress.max : 0;

        context.beastformActive = this.document.effects.find(x => x.type === 'beastform');

        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'header':
                const { playerCanEditSheet, levelupAuto } = game.settings.get(
                    CONFIG.DH.id,
                    CONFIG.DH.SETTINGS.gameSettings.Automation
                );
                context.showSettings = game.user.isGM || !levelupAuto || (levelupAuto && playerCanEditSheet);
                break;
            case 'loadout':
                await this._prepareLoadoutContext(context, options);
                break;
            case 'sidebar':
                await this._prepareSidebarContext(context, options);
                break;
            case 'biography':
                await this._prepareBiographyContext(context, options);
                break;
        }

        return context;
    }

    /**
     * Prepare render context for the Loadout part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareLoadoutContext(context, _options) {
        context.cardView = game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.displayDomainCardsAsCard);
    }

    /**
     * Prepare render context for the Sidebar part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareSidebarContext(context, _options) {
        context.isDeath = this.document.system.deathMoveViable;
    }

    /**
     * Prepare render context for the Biography part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareBiographyContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        const paths = {
            background: 'biography.background',
            connections: 'biography.connections'
        };

        for (const [key, path] of Object.entries(paths)) {
            const value = foundry.utils.getProperty(system, path);
            context[key] = {
                field: system.schema.getField(path),
                value,
                enriched: await TextEditor.implementation.enrichHTML(value, {
                    secrets: this.document.isOwner,
                    relativeTo: this.document
                })
            };
        }
    }

    /* -------------------------------------------- */
    /*  Context Menu                                */
    /* -------------------------------------------- */

    /**
     * Get the set of ContextMenu options for DomainCards.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {CharacterSheet}
     * @protected
     */
    static #getDomainCardContextOptions() {
        /**@type {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} */
        const options = [
            {
                name: 'toLoadout',
                icon: 'fa-solid fa-arrow-up',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && doc.system.inVault;
                },
                callback: async target => {
                    const doc = await getDocFromElement(target);
                    const actorLoadout = doc.actor.system.loadoutSlot;
                    if (actorLoadout.available) return doc.update({ 'system.inVault': false });
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.loadoutMaxReached'));
                }
            },
            {
                name: 'toVault',
                icon: 'fa-solid fa-arrow-down',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && !doc.system.inVault;
                },
                callback: async target => (await getDocFromElement(target)).update({ 'system.inVault': true })
            }
        ].map(option => ({
            ...option,
            name: `DAGGERHEART.APPLICATIONS.ContextMenu.${option.name}`,
            icon: `<i class="${option.icon}"></i>`
        }));

        return [...options, ...this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true })];
    }

    /**
     * Get the set of ContextMenu options for Armors and Weapons.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {CharacterSheet}
     * @protected
     */
    static #getEquipamentContextOptions() {
        const options = [
            {
                name: 'equip',
                icon: 'fa-solid fa-hands',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && !doc.system.equipped;
                },
                callback: (target, event) => CharacterSheet.#toggleEquipItem.call(this, event, target)
            },
            {
                name: 'unequip',
                icon: 'fa-solid fa-hands',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && doc.system.equipped;
                },
                callback: (target, event) => CharacterSheet.#toggleEquipItem.call(this, event, target)
            }
        ].map(option => ({
            ...option,
            name: `DAGGERHEART.APPLICATIONS.ContextMenu.${option.name}`,
            icon: `<i class="${option.icon}"></i>`
        }));

        return [...options, ...this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true })];
    }

    /**
     * Get the set of ContextMenu options for Consumable and Loot.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {CharacterSheet}
     * @protected
     */
    static #getItemContextOptions() {
        return this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true });
    }
    /* -------------------------------------------- */
    /*  Filter Tracking                             */
    /* -------------------------------------------- */

    /**
     * The currently active search filter.
     * @type {foundry.applications.ux.SearchFilter}
     */
    #search = {};

    /**
     * The currently active search filter.
     * @type {FilterMenu}
     */
    #menu = {};

    /**
     * Tracks which item IDs are currently displayed, organized by filter type and section.
     * @type {{
     *   inventory: {
     *     search: Set<string>,
     *     menu: Set<string>
     *   },
     *   loadout: {
     *     search: Set<string>,
     *     menu: Set<string>
     *   },
     * }}
     */
    #filteredItems = {
        inventory: {
            search: new Set(),
            menu: new Set()
        },
        loadout: {
            search: new Set(),
            menu: new Set()
        }
    };

    /* -------------------------------------------- */
    /*  Search Inputs                               */
    /* -------------------------------------------- */

    /**
     * Create and initialize search filter instances for the inventory and loadout sections.
     *
     * Sets up two {@link foundry.applications.ux.SearchFilter} instances:
     * - One for the inventory, which filters items in the inventory grid.
     * - One for the loadout, which filters items in the loadout/card grid.
     * @private
     */
    _createSearchFilter() {
        //Filters could be a application option if needed
        const filters = [
            {
                key: 'inventory',
                input: 'input[type="search"].search-inventory',
                content: '[data-application-part="inventory"] .items-section',
                callback: this._onSearchFilterInventory.bind(this)
            },
            {
                key: 'loadout',
                input: 'input[type="search"].search-loadout',
                content: '[data-application-part="loadout"] .items-section',
                callback: this._onSearchFilterCard.bind(this)
            }
        ];

        for (const { key, input, content, callback } of filters) {
            const filter = new foundry.applications.ux.SearchFilter({
                inputSelector: input,
                contentSelector: content,
                callback
            });
            filter.bind(this.element);
            this.#search[key] = filter;
        }
    }

    /**
     * Handle invetory items search and filtering.
     * @param {KeyboardEvent} event  The keyboard input event.
     * @param {string} query         The input search string.
     * @param {RegExp} rgx           The regular expression query that should be matched against.
     * @param {HTMLElement} html     The container to filter items from.
     * @protected
     */
    async _onSearchFilterInventory(_event, query, rgx, html) {
        this.#filteredItems.inventory.search.clear();

        for (const li of html.querySelectorAll('.inventory-item')) {
            const item = await getDocFromElement(li);
            const matchesSearch = !query || foundry.applications.ux.SearchFilter.testQuery(rgx, item.name);
            if (matchesSearch) this.#filteredItems.inventory.search.add(item.id);
            const { menu } = this.#filteredItems.inventory;
            li.hidden = !(menu.has(item.id) && matchesSearch);
        }
    }

    /**
     * Handle card items search and filtering.
     * @param {KeyboardEvent} event  The keyboard input event.
     * @param {string} query         The input search string.
     * @param {RegExp} rgx           The regular expression query that should be matched against.
     * @param {HTMLElement} html     The container to filter items from.
     * @protected
     */
    async _onSearchFilterCard(_event, query, rgx, html) {
        this.#filteredItems.loadout.search.clear();

        for (const li of html.querySelectorAll('.items-list .inventory-item, .card-list .card-item')) {
            const item = await getDocFromElement(li);
            const matchesSearch = !query || foundry.applications.ux.SearchFilter.testQuery(rgx, item.name);
            if (matchesSearch) this.#filteredItems.loadout.search.add(item.id);
            const { menu } = this.#filteredItems.loadout;
            li.hidden = !(menu.has(item.id) && matchesSearch);
        }
    }

    /* -------------------------------------------- */
    /*  Filter Menus                                */
    /* -------------------------------------------- */

    _createFilterMenus() {
        //Menus could be a application option if needed
        const menus = [
            {
                key: 'inventory',
                container: '[data-application-part="inventory"]',
                content: '.items-section',
                callback: this._onMenuFilterInventory.bind(this),
                target: '.filter-button',
                filters: FilterMenu.invetoryFilters
            },
            {
                key: 'loadout',
                container: '[data-application-part="loadout"]',
                content: '.items-section',
                callback: this._onMenuFilterLoadout.bind(this),
                target: '.filter-button',
                filters: FilterMenu.cardsFilters
            }
        ];

        menus.forEach(m => {
            const container = this.element.querySelector(m.container);
            this.#menu[m.key] = new FilterMenu(container, m.target, m.filters, m.callback, {
                contentSelector: m.content
            });
        });
    }

    /**
     * Callback when filters change
     * @param {PointerEvent} event
     * @param {HTMLElement} html
     * @param {import('../ux/filter-menu.mjs').FilterItem[]} filters
     */
    async _onMenuFilterInventory(_event, html, filters) {
        this.#filteredItems.inventory.menu.clear();

        for (const li of html.querySelectorAll('.inventory-item')) {
            const item = await getDocFromElement(li);

            const matchesMenu =
                filters.length === 0 || filters.some(f => foundry.applications.ux.SearchFilter.evaluateFilter(item, f));
            if (matchesMenu) this.#filteredItems.inventory.menu.add(item.id);

            const { search } = this.#filteredItems.inventory;
            li.hidden = !(search.has(item.id) && matchesMenu);
        }
    }

    /**
     * Callback when filters change
     * @param {PointerEvent} event
     * @param {HTMLElement} html
     * @param {import('../ux/filter-menu.mjs').FilterItem[]} filters
     */
    async _onMenuFilterLoadout(_event, html, filters) {
        this.#filteredItems.loadout.menu.clear();

        for (const li of html.querySelectorAll('.items-list .inventory-item, .card-list .card-item')) {
            const item = await getDocFromElement(li);

            const matchesMenu =
                filters.length === 0 || filters.some(f => foundry.applications.ux.SearchFilter.evaluateFilter(item, f));
            if (matchesMenu) this.#filteredItems.loadout.menu.add(item.id);

            const { search } = this.#filteredItems.loadout;
            li.hidden = !(search.has(item.id) && matchesMenu);
        }
    }

    /* -------------------------------------------- */
    /*  Application Listener Actions                */
    /* -------------------------------------------- */

    async updateItemResource(event) {
        const item = await getDocFromElement(event.currentTarget);
        if (!item) return;

        const max = event.currentTarget.max ? Number(event.currentTarget.max) : null;
        const value = max ? Math.min(Number(event.currentTarget.value), max) : event.currentTarget.value;
        await item.update({ 'system.resource.value': value });
        this.render();
    }

    async updateItemQuantity(event) {
        const item = await getDocFromElement(event.currentTarget);
        if (!item) return;

        await item.update({ 'system.quantity': event.currentTarget.value });
        this.render();
    }

    async updateArmorMarks(event) {
        const armor = this.document.system.armor;
        if (!armor) return;

        const maxMarks = this.document.system.armorScore;
        const value = Math.min(Math.max(Number(event.currentTarget.value), 0), maxMarks);
        await armor.update({ 'system.marks.value': value });
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Opens the character level management window.
     * If the character requires setup, opens the character creation interface.
     * If class or subclass is missing, shows an error notification.
     * @type {ApplicationClickAction}
     */
    static #levelManagement() {
        if (this.document.system.needsCharacterSetup)
            return new DhCharacterCreation(this.document).render({ force: true });

        const { value, subclass } = this.document.system.class;
        if (!value || !subclass)
            return ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.missingClassOrSubclass'));

        new DhCharacterLevelUp(this.document).render({ force: true });
    }

    /**
     * Opens the charater level management window in viewMode.
     */
    static #viewLevelups() {
        new DhlevelUpViewMode(this.document).render({ force: true });
    }

    /**
     * Opens the Death Move interface for the character.
     * @type {ApplicationClickAction}
     */
    static async #makeDeathMove() {
        await new DhpDeathMove(this.document).render({ force: true });
    }

    /**
     * Opens a compendium pack given its dataset key.
     * @type {ApplicationClickAction}
     */
    static async #openPack(_event, button) {
        const { key } = button.dataset;

        const presets = {
            folder: key,
            filter:
                key === 'subclasses'
                    ? {
                          'system.linkedClass.uuid': {
                              key: 'system.linkedClass.uuid',
                              value: this.document.system.class.value._stats.compendiumSource
                          }
                      }
                    : undefined,
            render: {
                noFolder: true
            }
        };

        ui.compendiumBrowser.open(presets);
    }

    /**
     * Rolls an attribute check based on the clicked button's dataset attribute.
     * @type {ApplicationClickAction}
     */
    static async #rollAttribute(event, button) {
        const abilityLabel = game.i18n.localize(abilities[button.dataset.attribute].label);
        const config = {
            event: event,
            title: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${this.actor.name}`,
            headerTitle: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: abilityLabel
            }),
            roll: {
                trait: button.dataset.attribute
            },
            hasRoll: true
        };
        const result = await this.document.diceRoll({
            ...config,
            actionType: 'action',
            headerTitle: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${this.actor.name}`,
            title: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: abilityLabel
            })
        });

        if (result) game.system.api.fields.ActionFields.CostField.execute.call(this, result);
    }

    //TODO: redo toggleEquipItem method

    /**
     * Toggles the equipped state of an item (armor or weapon).
     * @type {ApplicationClickAction}
     */
    static async #toggleEquipItem(_event, button) {
        const item = await getDocFromElement(button);
        if (!item) return;
        if (item.system.equipped) {
            await item.update({ 'system.equipped': false });
            return;
        }

        switch (item.type) {
            case 'armor':
                const currentArmor = this.document.system.armor;
                if (currentArmor) {
                    await currentArmor.update({ 'system.equipped': false });
                }

                await item.update({ 'system.equipped': true });
                break;
            case 'weapon':
                if (this.document.effects.find(x => !x.disabled && x.type === 'beastform')) {
                    return ui.notifications.warn(
                        game.i18n.localize('DAGGERHEART.UI.Notifications.beastformEquipWeapon')
                    );
                }

                await this.document.system.constructor.unequipBeforeEquip.bind(this.document.system)(item);

                await item.update({ 'system.equipped': true });
                break;
        }
    }

    /**
     * Toggles the current view of the character's loadout display.
     * @type {ApplicationClickAction}
     */
    static async #toggleLoadoutView(_, button) {
        const newAbilityView = button.dataset.value === 'true';
        await game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.displayDomainCardsAsCard, newAbilityView);
        this.render();
    }

    /**
     * Toggles hitpoint resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleHitPoints(_, button) {
        const hitPointsValue = Number.parseInt(button.dataset.value);
        const newValue =
            this.document.system.resources.hitPoints.value >= hitPointsValue ? hitPointsValue - 1 : hitPointsValue;
        await this.document.update({ 'system.resources.hitPoints.value': newValue });
    }

    /**
     * Toggles stress resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleStress(_, button) {
        const StressValue = Number.parseInt(button.dataset.value);
        const newValue = this.document.system.resources.stress.value >= StressValue ? StressValue - 1 : StressValue;
        await this.document.update({ 'system.resources.stress.value': newValue });
    }

    /**
     * Toggles ArmorScore resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleArmor(_, button, element) {
        const ArmorValue = Number.parseInt(button.dataset.value);
        const newValue = this.document.system.armor.system.marks.value >= ArmorValue ? ArmorValue - 1 : ArmorValue;
        await this.document.system.armor.update({ 'system.marks.value': newValue });
    }

    /**
     * Toggles a hope resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleHope(_, button) {
        const hopeValue = Number.parseInt(button.dataset.value);
        const newValue = this.document.system.resources.hope.value >= hopeValue ? hopeValue - 1 : hopeValue;
        await this.document.update({ 'system.resources.hope.value': newValue });
    }

    /**
     * Toggles whether an item is stored in the vault.
     * @type {ApplicationClickAction}
     */
    static async #toggleVault(_event, button) {
        const doc = await getDocFromElement(button);
        const { available } = this.document.system.loadoutSlot;
        if (doc.system.inVault && !available) {
            return ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.loadoutMaxReached'));
        }

        await doc?.update({ 'system.inVault': !doc.system.inVault });
    }

    /**
     * Toggle the used state of a resource dice.
     * @type {ApplicationClickAction}
     */
    static async #toggleResourceDice(event, target) {
        const item = await getDocFromElement(target);

        const { dice } = event.target.closest('.item-resource').dataset;
        const diceState = item.system.resource.diceStates[dice];

        await item.update({
            [`system.resource.diceStates.${dice}.used`]: diceState ? !diceState.used : true
        });
    }

    /**
     * Handle the roll values of resource dice.
     * @type {ApplicationClickAction}
     */
    static async #handleResourceDice(_, target) {
        const item = await getDocFromElement(target);
        if (!item) return;

        const rollValues = await game.system.api.applications.dialogs.ResourceDiceDialog.create(item, this.document);
        if (!rollValues) return;

        await item.update({
            'system.resource.diceStates': rollValues.reduce((acc, state, index) => {
                acc[index] = { value: state.value, used: state.used };
                return acc;
            }, {})
        });
    }

    /** */
    static #advanceResourceDie(_, target) {
        this.updateResourceDie(target, true);
    }

    lowerResourceDie(event) {
        event.preventDefault();
        event.stopPropagation();
        this.updateResourceDie(event.target, false);
    }

    async updateResourceDie(target, advance) {
        const item = await getDocFromElement(target);
        if (!item) return;

        const advancedValue = item.system.resource.value + (advance ? 1 : -1);
        await item.update({
            'system.resource.value': Math.min(advancedValue, Number(item.system.resource.dieFaces.split('d')[1]))
        });
    }

    /**
     *
     */
    static async #cancelBeastform(_, target) {
        const item = await getDocFromElement(target);
        if (!item) return;
        game.system.api.fields.ActionFields.BeastformField.handleActiveTransformations.call(item);
    }

    /**
     *  Open the downtime application.
     * @type {ApplicationClickAction}
     */
    static useDowntime(_, button) {
        new game.system.api.applications.dialogs.Downtime(this.document, button.dataset.type === 'shortRest').render({
            force: true
        });
    }

    async _onDropItem(event, item) {
        if (this.document.uuid === item.parent?.uuid) {
            return super._onDropItem(event, item);
        }

        if (item.type === 'beastform') {
            if (this.document.effects.find(x => x.type === 'beastform')) {
                return ui.notifications.warn(
                    game.i18n.localize('DAGGERHEART.UI.Notifications.beastformAlreadyApplied')
                );
            }

            const itemData = item.toObject();
            const data = await game.system.api.data.items.DHBeastform.getWildcardImage(this.document, itemData);
            if (!data?.selectedImage) {
                return;
            } else if (data) {
                if (data.usesDynamicToken) itemData.system.tokenRingImg = data.selectedImage;
                else itemData.system.tokenImg = data.selectedImage;
                return await this._onDropItemCreate(itemData);
            }
        }

        // If this is a type that gets deleted, delete it first (but still defer to super)
        const typesThatReplace = ['ancestry', 'community'];
        if (typesThatReplace.includes(item.type)) {
            await this.document.deleteEmbeddedDocuments(
                'Item',
                this.document.items.filter(x => x.type === item.type).map(x => x.id)
            );
        }

        return super._onDropItem(event, item);
    }

    async _onDropItemCreate(itemData, event) {
        itemData = itemData instanceof Array ? itemData : [itemData];
        return this.document.createEmbeddedDocuments('Item', itemData);
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DhCompanionSheet extends DHBaseActorSheet {
    static DEFAULT_OPTIONS = {
        classes: ['actor', 'companion'],
        position: { width: 340 },
        actions: {
            toggleStress: DhCompanionSheet.#toggleStress,
            actionRoll: DhCompanionSheet.#actionRoll,
            levelManagement: DhCompanionSheet.#levelManagement
        }
    };

    static PARTS = {
        limited: {
            template: 'systems/daggerheart/templates/sheets/actors/companion/limited.hbs',
            scrollable: ['.limited-container']
        },
        header: { template: 'systems/daggerheart/templates/sheets/actors/companion/header.hbs' },
        details: { template: 'systems/daggerheart/templates/sheets/actors/companion/details.hbs' },
        effects: {
            template: 'systems/daggerheart/templates/sheets/actors/companion/effects.hbs',
            scrollable: ['.effects-sections']
        }
    };

    /* -------------------------------------------- */

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'effects' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /** @inheritDoc */
    async _onRender(context, options) {
        await super._onRender(context, options);

        this.element
            .querySelector('.level-value')
            ?.addEventListener('change', event => this.document.updateLevel(Number(event.currentTarget.value)));
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Toggles stress resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleStress(_, button) {
        const StressValue = Number.parseInt(button.dataset.value);
        const newValue = this.document.system.resources.stress.value >= StressValue ? StressValue - 1 : StressValue;
        await this.document.update({ 'system.resources.stress.value': newValue });
    }

    /**
     *
     */
    static async #actionRoll(event) {
        const partner = this.actor.system.partner;
        const config = {
            event,
            title: `${game.i18n.localize('DAGGERHEART.GENERAL.Roll.action')}: ${this.actor.name}`,
            headerTitle: `Companion ${game.i18n.localize('DAGGERHEART.GENERAL.Roll.action')}`,
            roll: {
                trait: partner.system.spellcastModifierTrait?.key
            },
            hasRoll: true,
            data: partner.getRollData()
        };

        const result = await partner.diceRoll(config);
        this.consumeResource(result?.costs);
    }

    // Remove when Action Refactor part #2 done
    async consumeResource(costs) {
        if (!costs?.length) return;

        const partner = this.actor.system.partner;
        const usefulResources = {
            ...foundry.utils.deepClone(partner.system.resources),
            fear: {
                value: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear),
                max: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear,
                reversed: false
            }
        };
        const resources = game.system.api.fields.ActionFields.CostField.getRealCosts(costs).map(c => {
            const resource = usefulResources[c.key];
            return {
                key: c.key,
                value: (c.total ?? c.value) * (resource.isReversed ? 1 : -1),
                target: resource.target
            };
        });

        await partner.modifyResource(resources);
    }

    /**
     * Opens the companions level management window.
     * @type {ApplicationClickAction}
     */
    static #levelManagement() {
        new DhCompanionLevelUp(this.document).render({ force: true });
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DhpEnvironment extends DHBaseActorSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['environment'],
        position: {
            width: 500,
            height: 740
        },
        window: {
            resizable: true,
            controls: [
                {
                    icon: 'fa-solid fa-signature',
                    label: 'DAGGERHEART.UI.Tooltip.configureAttribution',
                    action: 'editAttribution'
                }
            ]
        },
        actions: {
            toggleResourceDice: DhpEnvironment.#toggleResourceDice,
            handleResourceDice: DhpEnvironment.#handleResourceDice
        },
        dragDrop: [{ dragSelector: '.inventory-item', dropSelector: null }]
    };

    /**@override */
    static PARTS = {
        limited: {
            template: 'systems/daggerheart/templates/sheets/actors/environment/limited.hbs',
            scrollable: ['.limited-container']
        },
        header: { template: 'systems/daggerheart/templates/sheets/actors/environment/header.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/actors/environment/features.hbs',
            scrollable: ['.feature-section']
        },
        potentialAdversaries: {
            template: 'systems/daggerheart/templates/sheets/actors/environment/potentialAdversaries.hbs',
            scrollable: ['.items-section']
        },
        notes: { template: 'systems/daggerheart/templates/sheets/actors/environment/notes.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'features' }, { id: 'potentialAdversaries' }, { id: 'notes' }],
            initial: 'features',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**  @inheritdoc */
    _initializeApplicationOptions(options) {
        const applicationOptions = super._initializeApplicationOptions(options);

        if (applicationOptions.document.testUserPermission(game.user, 'LIMITED', { exact: true })) {
            applicationOptions.position.width = 360;
            applicationOptions.position.height = 'auto';
        }

        return applicationOptions;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'header':
                await this._prepareHeaderContext(context, options);

                break;
            case 'notes':
                await this._prepareNotesContext(context, options);
                break;
        }
        return context;
    }

    /**
     * Prepare render context for the Biography part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareNotesContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        const paths = {
            notes: 'notes'
        };

        for (const [key, path] of Object.entries(paths)) {
            const value = foundry.utils.getProperty(system, path);
            context[key] = {
                field: system.schema.getField(path),
                value,
                enriched: await TextEditor.implementation.enrichHTML(value, {
                    secrets: this.document.isOwner,
                    relativeTo: this.document
                })
            };
        }
    }

    /**
     * Prepare render context for the Header part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareHeaderContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        context.description = await TextEditor.implementation.enrichHTML(system.description, {
            secrets: this.document.isOwner,
            relativeTo: this.document
        });
    }

    /* -------------------------------------------- */

    async _onDragStart(event) {
        const item = event.currentTarget.closest('.inventory-item[data-type=adversary]');
        if (item) {
            const adversaryData = { type: 'Actor', uuid: item.dataset.itemUuid };
            event.dataTransfer.setData('text/plain', JSON.stringify(adversaryData));
            event.dataTransfer.setDragImage(item, 60, 0);
        } else {
            return super._onDragStart(event);
        }
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Toggle the used state of a resource dice.
     * @type {ApplicationClickAction}
     */
    static async #toggleResourceDice(event, target) {
        const item = await getDocFromElement(target);

        const { dice } = event.target.closest('.item-resource').dataset;
        const diceState = item.system.resource.diceStates[dice];

        await item.update({
            [`system.resource.diceStates.${dice}.used`]: diceState ? !diceState.used : true
        });
    }

    /**
     * Handle the roll values of resource dice.
     * @type {ApplicationClickAction}
     */
    static async #handleResourceDice(_, target) {
        const item = await getDocFromElement(target);
        if (!item) return;

        const rollValues = await game.system.api.applications.dialogs.ResourceDiceDialog.create(item, this.document);
        if (!rollValues) return;

        await item.update({
            'system.resource.diceStates': rollValues.reduce((acc, state, index) => {
                acc[index] = { value: state.value, used: state.used };
                return acc;
            }, {})
        });
    }
}

var _module$c = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Adversary: AdversarySheet,
    Character: CharacterSheet,
    Companion: DhCompanionSheet,
    Environment: DhpEnvironment,
    Party: Party
});

const { ItemSheetV2 } = foundry.applications.sheets;

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

/**
 * A base item sheet extending {@link ItemSheetV2} via {@link DHApplicationMixin}
 */
class DHBaseItemSheet extends DHApplicationMixin(ItemSheetV2) {
    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['item'],
        position: { width: 600 },
        window: {
            resizable: true,
            controls: [
                {
                    icon: 'fa-solid fa-signature',
                    label: 'DAGGERHEART.UI.Tooltip.configureAttribution',
                    action: 'editAttribution'
                }
            ]
        },
        form: {
            submitOnChange: true
        },
        actions: {
            addFeature: DHBaseItemSheet.#addFeature,
            deleteFeature: DHBaseItemSheet.#deleteFeature,
            addResource: DHBaseItemSheet.#addResource,
            removeResource: DHBaseItemSheet.#removeResource
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.drop-section' },
            { dragSelector: '.feature-item', dropSelector: null },
            { dragSelector: '.inventory-item', dropSelector: null }
        ],
        contextMenus: [
            {
                handler: DHBaseItemSheet.#getFeatureContextOptions,
                selector: '[data-item-uuid][data-type="feature"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            }
        ]
    };

    /* -------------------------------------------- */

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'settings' }, { id: 'actions' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /* -------------------------------------------- */
    /*  Prepare Context                             */
    /* -------------------------------------------- */

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.showAttribution = !game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance)
            .hideAttribution;

        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        await super._preparePartContext(partId, context, options);
        const { TextEditor } = foundry.applications.ux;

        switch (partId) {
            case 'description':
                const value = foundry.utils.getProperty(this.document, 'system.description') ?? '';
                context.enrichedDescription = await TextEditor.enrichHTML(value, {
                    relativeTo: this.item,
                    rollData: this.item.getRollData(),
                    secrets: this.item.isOwner
                });
                break;
            case 'effects':
                await this._prepareEffectsContext(context, options);
                break;
            case 'features':
                context.isGM = game.user.isGM;
                break;
        }

        return context;
    }

    /**
     * Prepare render context for the Effect part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareEffectsContext(context, _options) {
        context.effects = {
            actives: [],
            inactives: []
        };

        for (const effect of this.item.effects) {
            const list = effect.active ? context.effects.actives : context.effects.inactives;
            list.push(effect);
        }
    }

    /* -------------------------------------------- */
    /*  Context Menu                                */
    /* -------------------------------------------- */

    /**
     * Get the set of ContextMenu options for Features.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {DHBaseItemSheet}
     * @protected
     */
    static #getFeatureContextOptions() {
        const options = this._getContextMenuCommonOptions({ usable: true, toChat: true, deletable: false });
        options.push({
            name: 'CONTROLS.CommonDelete',
            icon: '<i class="fa-solid fa-trash"></i>',
            callback: async target => {
                const feature = await getDocFromElement(target);
                if (!feature) return;
                const confirmed = await foundry.applications.api.DialogV2.confirm({
                    window: {
                        title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                            type: game.i18n.localize(`TYPES.Item.feature`),
                            name: feature.name
                        })
                    },
                    content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', {
                        name: feature.name
                    })
                });
                if (!confirmed) return;
                await this.document.update({
                    'system.features': this.document.system.toObject().features.filter(uuid => uuid !== feature.uuid)
                });
            }
        });
        return options;
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Add a new feature to the item, prompting the user for its type.
     * @type {ApplicationClickAction}
     */
    static async #addFeature(_, target) {
        const { type } = target.dataset;
        const cls = foundry.documents.Item.implementation;

        const multiclass = this.document.system.isMulticlass ? 'multiclass' : null;
        let systemData = {};
        if (this.document.parent?.type === 'character') {
            systemData = {
                originItemType: this.document.type,
                identifier: multiclass ?? type
            };
        }

        const item = await cls.create(
            {
                type: 'feature',
                name: cls.defaultName({ type: 'feature' }),
                system: systemData
            },
            { parent: this.document.parent?.type === 'character' ? this.document.parent : undefined }
        );
        await this.document.update({
            'system.features': [...this.document.system.features, { type, item }].map(x => ({
                ...x,
                item: x.item?.uuid
            }))
        });
    }

    /**
     * Remove a feature from the item.
     * @type {ApplicationClickAction}
     */
    static async #deleteFeature(_, element) {
        const target = element.closest('[data-item-uuid]');
        const feature = await getDocFromElement(target);

        if (!feature) {
            await this.document.update({
                'system.features': this.document.system.features
                    .filter(x => x.item)
                    .map(x => ({ ...x, item: x.item.uuid }))
            });
        } else {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                        type: game.i18n.localize('TYPES.Item.feature'),
                        name: feature.name
                    })
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: feature.name })
            });

            if (!confirmed) return;

            await this.document.update({
                'system.features': this.document.system.features
                    .filter(x => target.dataset.type !== x.type || x.item.uuid !== feature.uuid)
                    .map(x => ({ ...x, item: x.item.uuid }))
            });
        }
    }

    /**
     * Add a resource to the item.
     * @type {ApplicationClickAction}
     */
    static async #addResource() {
        await this.document.update({
            'system.resource': { type: 'simple', value: 0 }
        });
    }

    /**
     * Remove the resource from the item.
     * @type {ApplicationClickAction}
     */
    static async #removeResource() {
        await this.document.update({
            'system.resource': null
        });
    }

    /* -------------------------------------------- */
    /*  Application Drag/Drop                       */
    /* -------------------------------------------- */

    /**
     * On dragStart on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDragStart(event) {
        /* Can prolly be improved a lot, but I don't wanna >_< */
        const featureItem = event.currentTarget.closest('.feature-item');
        const inventoryItem = event.currentTarget.closest('.inventory-item');
        const lineItem = event.currentTarget.closest('.item-line');
        const dragItemData = featureItem ?? inventoryItem ?? lineItem;

        const dragItem = await foundry.utils.fromUuid(dragItemData.dataset.itemUuid);
        if (dragItem) {
            if (!dragItem) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.featureIsMissing'));
                return;
            }

            let dragData = {};
            if (dragItemData.dataset.type === 'effect')
                dragData = {
                    type: 'ActiveEffect',
                    fromInternal: this.document.uuid,
                    data: { ...dragItem, uuid: dragItem.uuid, id: dragItem.id }
                };
            else dragData = { type: 'Item', uuid: dragItem.uuid, id: dragItem.id, fromInternal: this.document.id };

            event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
            event.dataTransfer.setDragImage(dragItemData.querySelector('img'), 60, 0);
        }
    }

    /**
     * On drop on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDrop(event) {
        super._onDrop(event);

        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        if (data.fromInternal === this.document.id) return;

        const target = event.target.closest('fieldset.drop-section');
        let item = await fromUuid(data.uuid);
        if (item?.type === 'feature') {
            const cls = foundry.documents.Item.implementation;

            if (this.document.parent?.type === 'character') {
                const itemData = item.toObject();
                const multiclass = this.document.system.isMulticlass ? 'multiclass' : null;
                item = await cls.create(
                    {
                        ...itemData,
                        _stats: { compendiumSource: this.document.uuid },
                        system: {
                            ...itemData.system,
                            originItemType: this.document.type,
                            identifier: multiclass ?? target.dataset.type
                        }
                    },
                    { parent: this.document.parent }
                );
            }

            if (target.dataset.type) {
                await this.document.update(
                    {
                        'system.features': [...this.document.system.features, { type: target.dataset.type, item }].map(
                            x => ({
                                ...x,
                                item: x.item?.uuid
                            })
                        )
                    },
                    { parent: this.document.parent?.type === 'character' ? this.document.parent : undefined }
                );
            } else {
                await this.document.update(
                    {
                        'system.features': [...this.document.system.features, item].map(x => x.uuid)
                    },
                    { parent: this.document.parent?.type === 'character' ? this.document.parent : undefined }
                );
            }
        }
    }
}

class DHHeritageSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        position: { width: 450, height: 700 }
    };

    /**@override */
    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /** @override*/
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'features' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };
}

function ItemAttachmentSheet(Base) {
    return class extends Base {
        static DEFAULT_OPTIONS = {
            ...super.DEFAULT_OPTIONS,
            dragDrop: [
                ...(super.DEFAULT_OPTIONS.dragDrop || []),
                { dragSelector: null, dropSelector: '.attachments-section' }
            ],
            actions: {
                ...super.DEFAULT_OPTIONS.actions,
                removeAttachment: this.#removeAttachment
            }
        };

        static PARTS = {
            ...super.PARTS,
            attachments: {
                template: 'systems/daggerheart/templates/sheets/global/tabs/tab-attachments.hbs',
                scrollable: ['.attachments']
            }
        };

        static TABS = {
            ...super.TABS,
            primary: {
                ...super.TABS?.primary,
                tabs: [...(super.TABS?.primary?.tabs || []) /*{ id: 'attachments' }*/], // Disabled until fixed
                initial: super.TABS?.primary?.initial || 'description',
                labelPrefix: super.TABS?.primary?.labelPrefix || 'DAGGERHEART.GENERAL.Tabs'
            }
        };

        async _preparePartContext(partId, context) {
            await super._preparePartContext(partId, context);

            if (partId === 'attachments') {
                context.attachedItems = await prepareAttachmentContext(this.document);
            }

            return context;
        }

        async _onDrop(event) {
            const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);

            const attachmentsSection = event.target.closest('.attachments-section');
            if (!attachmentsSection) return super._onDrop(event);

            event.preventDefault();
            event.stopPropagation();

            const item = await Item.implementation.fromDropData(data);
            if (!item) return;

            // Call the data model's public method
            await this.document.system.addAttachment(item);
        }

        static async #removeAttachment(event, target) {
            // Call the data model's public method
            await this.document.system.removeAttachment(target.dataset.uuid);
        }

        async _preparePartContext(partId, context) {
            await super._preparePartContext(partId, context);

            if (partId === 'attachments') {
                // Keep this simple UI preparation in the mixin
                const attachedUUIDs = this.document.system.attached;
                context.attachedItems = await Promise.all(
                    attachedUUIDs.map(async uuid => {
                        const item = await fromUuid(uuid);
                        return {
                            uuid: uuid,
                            name: item?.name || 'Unknown Item',
                            img: item?.img || 'icons/svg/item-bag.svg'
                        };
                    })
                );
            }

            return context;
        }
    };
}

var _modules$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHApplicationMixin: DHApplicationMixin,
    DHBaseActorSettings: DHBaseActorSettings,
    DHBaseActorSheet: DHBaseActorSheet,
    DHBaseItemSheet: DHBaseItemSheet,
    DHHeritageSheet: DHHeritageSheet,
    DHItemAttachmentSheet: ItemAttachmentSheet
});

class AncestrySheet extends DHHeritageSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['ancestry']
    };

    /**@inheritdoc */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/ancestry/header.hbs' },
        ...super.PARTS,
        features: { template: 'systems/daggerheart/templates/sheets/items/ancestry/features.hbs' }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features.map(x => x.item);
    }

    /* -------------------------------------------- */
    /*  Application Drag/Drop                       */
    /* -------------------------------------------- */

    /**
     * On drop on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDrop(event) {
        const data = TextEditor.getDragEventData(event);
        if (data.type === 'ActiveEffect') return super._onDrop(event);

        const target = event.target.closest('fieldset.drop-section');
        const typeField =
            this.document.system[target.dataset.type === 'primary' ? 'primaryFeature' : 'secondaryFeature'];

        if (!typeField) {
            super._onDrop(event);
        }
    }
}

class ArmorSheet extends ItemAttachmentSheet(DHBaseItemSheet) {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['armor'],
        tagifyConfigs: [
            {
                selector: '.features-input',
                options: () => CONFIG.DH.ITEM.orderedArmorFeatures(),
                callback: ArmorSheet.#onFeatureSelect
            }
        ]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/armor/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/armor/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        },
        ...super.PARTS
    };

    /**@inheritdoc */
    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        switch (partId) {
            case 'settings':
                context.features = this.document.system.armorFeatures.map(x => x.value);
                break;
        }

        return context;
    }

    /**
     * Callback function used by `tagifyElement`.
     * @param {Array<Object>} selectedOptions - The currently selected tag objects.
     */
    static async #onFeatureSelect(selectedOptions) {
        await this.document.update({ 'system.armorFeatures': selectedOptions.map(x => ({ value: x.value })) });
    }
}

class BeastformSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['beastform']
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/beastform/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        settings: { template: 'systems/daggerheart/templates/sheets/items/beastform/settings.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-features.hbs',
            scrollable: ['.features']
        },
        advanced: { template: 'systems/daggerheart/templates/sheets/items/beastform/advanced.hbs' },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    static TABS = {
        primary: {
            tabs: [{ id: 'settings' }, { id: 'features' }, { id: 'advanced' }, { id: 'effects' }],
            initial: 'settings',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features;
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        const advantageOnInput = htmlElement.querySelector('.advantageon-input');
        if (advantageOnInput) {
            const tagifyElement = new Q(advantageOnInput, {
                tagTextProp: 'name',
                templates: {
                    tag(tagData) {
                        return `<tag
                                    contenteditable='false'
                                    spellcheck='false'
                                    tabIndex="${this.settings.a11y.focusableTags ? 0 : -1}"
                                    class="${this.settings.classNames.tag} ${tagData.class ? tagData.class : ''}"
                                    ${this.getAttributes(tagData)}> 
                            <x class="${this.settings.classNames.tagX}" role='button' aria-label='remove tag'></x>
                            <div>
                                <span class="${this.settings.classNames.tagText}">${tagData[this.settings.tagTextProp] || tagData.value}</span>
                                ${tagData.src ? `<img src="${tagData.src}"></i>` : ''}
                            </div>
                        </tag>`;
                    }
                }
            });
            tagifyElement.on('add', this.advantageOnAdd.bind(this));
            tagifyElement.on('remove', this.advantageOnRemove.bind(this));
        }
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        await super._preparePartContext(partId, context, options);

        switch (partId) {
            case 'settings':
                context.advantageOn = JSON.stringify(
                    Object.keys(context.document.system.advantageOn).map(key => ({
                        value: key,
                        name: context.document.system.advantageOn[key].value
                    }))
                );
                break;
            case 'effects':
                context.effects.actives = context.effects.actives.map(effect => {
                    const data = effect.toObject();
                    data.uuid = effect.uuid;
                    data.id = effect.id;
                    if (effect.type === 'beastform') data.mandatory = true;

                    return data;
                });
                break;
        }

        return context;
    }

    async advantageOnAdd(event) {
        await this.document.update({
            [`system.advantageOn.${foundry.utils.randomID()}`]: { value: event.detail.data.value }
        });
    }

    async advantageOnRemove(event) {
        await this.document.update({
            [`system.advantageOn.-=${event.detail.data.value}`]: null
        });
    }
}

const { TextEditor: TextEditor$1 } = foundry.applications.ux;

class ClassSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['class'],
        position: { width: 700 },
        actions: {
            removeItemFromCollection: ClassSheet.#removeItemFromCollection,
            removeSuggestedItem: ClassSheet.#removeSuggestedItem
        },
        tagifyConfigs: [
            {
                selector: '.domain-input',
                options: () => CONFIG.DH.DOMAIN.orderedDomains(),
                callback: ClassSheet.#onDomainSelect,
                tagifyOptions: {
                    maxTags: () => game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxDomains
                }
            }
        ],
        dragDrop: [
            { dragSelector: '.suggested-item', dropSelector: null },
            { dragSelector: null, dropSelector: '.take-section' },
            { dragSelector: null, dropSelector: '.choice-a-section' },
            { dragSelector: null, dropSelector: '.choice-b-section' },
            { dragSelector: null, dropSelector: '.primary-weapon-section' },
            { dragSelector: null, dropSelector: '.secondary-weapon-section' },
            { dragSelector: null, dropSelector: '.armor-section' },
            { dragSelector: null, dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/class/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/items/class/features.hbs',
            scrollable: ['.features']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/class/settings.hbs',
            scrollable: ['.settings']
        },
        questions: {
            template: 'systems/daggerheart/templates/sheets/items/class/questions.hbs',
            scrollable: ['.questions']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [
                { id: 'description' },
                { id: 'features' },
                { id: 'settings' },
                { id: 'questions' },
                { id: 'effects' }
            ],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features.map(x => x.item);
    }

    /**@inheritdoc */
    async _onFirstRender(context, options) {
        await super._onFirstRender(context, options);

        const paths = [
            'subclasses',
            'characterGuide.suggestedPrimaryWeapon',
            'characterGuide.suggestedSecondaryWeapon',
            'characterGuide.suggestedArmor',
            'inventory.take',
            'inventory.choiceA',
            'inventory.choiceB'
        ];

        for (let path of paths) {
            const docDatas = [].concat(foundry.utils.getProperty(this.document, `system.${path}`) ?? []);

            const docs = [];
            for (var docData of docDatas) {
                const doc = await foundry.utils.fromUuid(docData.uuid);
                docs.push(doc);
            }

            docs.filter(doc => doc).forEach(doc => (doc.apps[this.id] = this));
        }
    }

    /**@inheritdoc */
    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.domains = this.document.system.domains;
        return context;
    }

    /* -------------------------------------------- */

    /**
     * Callback function used by `tagifyElement`.
     * @param {Array<Object>} selectedOptions - The currently selected tag objects.
     */
    static async #onDomainSelect(selectedOptions) {
        await this.document.update({ 'system.domains': selectedOptions.map(x => x.value) });
    }

    /* -------------------------------------------- */

    async _onDrop(event) {
        event.stopPropagation();
        const data = TextEditor$1.getDragEventData(event);
        const item = await fromUuid(data.uuid);
        const itemType = data.type === 'ActiveEffect' ? data.type : item.type;
        const target = event.target.closest('fieldset.drop-section');
        if (itemType === 'subclass') {
            if (item.system.linkedClass) {
                return ui.notifications.warn(
                    game.i18n.format('DAGGERHEART.UI.Notifications.subclassAlreadyLinked', {
                        name: item.name,
                        class: this.document.name
                    })
                );
            }
            await item.update({ 'system.linkedClass': this.document.uuid });
            await this.document.update({
                'system.subclasses': [...this.document.system.subclasses.map(x => x.uuid), item.uuid]
            });
        } else if (['feature', 'ActiveEffect'].includes(itemType)) {
            super._onDrop(event);
        } else if (this.document.parent?.type !== 'character') {
            if (itemType === 'weapon') {
                if (target.classList.contains('primary-weapon-section')) {
                    if (!item.system.secondary)
                        await this.document.update({
                            'system.characterGuide.suggestedPrimaryWeapon': item.uuid
                        });
                } else if (target.classList.contains('secondary-weapon-section')) {
                    if (item.system.secondary)
                        await this.document.update({
                            'system.characterGuide.suggestedSecondaryWeapon': item.uuid
                        });
                }
            } else if (itemType === 'armor') {
                if (target.classList.contains('armor-section')) {
                    await this.document.update({
                        'system.characterGuide.suggestedArmor': item.uuid
                    });
                }
            } else if (target.classList.contains('choice-a-section')) {
                if (itemType === 'loot' || itemType === 'consumable') {
                    const filteredChoiceA = this.document.system.inventory.choiceA;
                    if (filteredChoiceA.length < 2)
                        await this.document.update({
                            'system.inventory.choiceA': [...filteredChoiceA.map(x => x.uuid), item.uuid]
                        });
                }
            } else if (itemType === 'loot') {
                if (target.classList.contains('take-section')) {
                    const filteredTake = this.document.system.inventory.take.filter(x => x);
                    if (filteredTake.length < 3)
                        await this.document.update({
                            'system.inventory.take': [...filteredTake.map(x => x.uuid), item.uuid]
                        });
                } else if (target.classList.contains('choice-b-section')) {
                    const filteredChoiceB = this.document.system.inventory.choiceB.filter(x => x);
                    if (filteredChoiceB.length < 2)
                        await this.document.update({
                            'system.inventory.choiceB': [...filteredChoiceB.map(x => x.uuid), item.uuid]
                        });
                }
            }
        }
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Removes an item from an class collection by UUID.
     * @param {PointerEvent} event - The originating click event
     * @param {HTMLElement} element - The capturing HTML element which defines the [data-action="removeItemFromCollection"]
     */
    static async #removeItemFromCollection(_event, element) {
        const { uuid, target } = element.dataset;
        const prop = foundry.utils.getProperty(this.document.system, target);

        if (target === 'subclasses') {
            const subclass = await foundry.utils.fromUuid(uuid);
            await subclass?.update({ 'system.linkedClass': null });
        }

        await this.document.update({ [`system.${target}`]: prop.filter(i => i && i.uuid !== uuid).map(x => x.uuid) });
    }

    /**
     * Removes an suggested item from the class.
     * @param {PointerEvent} _event - The originating click event
     * @param {HTMLElement} element - The capturing HTML element which defines the [data-action="removeSuggestedItem"]
     */
    static async #removeSuggestedItem(_event, element) {
        const { target } = element.dataset;
        await this.document.update({ [`system.characterGuide.${target}`]: null });
    }
}

class CommunitySheet extends DHHeritageSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['community']
    };

    /**@inheritdoc */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/community/header.hbs' },
        ...super.PARTS,
        features: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-features.hbs',
            scrollable: ['.feature']
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features;
    }
}

class ConsumableSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['consumable'],
        position: { width: 550 }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/consumable/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/consumable/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };
}

class DomainCardSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['domain-card'],
        position: { width: 450, height: 700 }
    };

    /** @override */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'actions' }, { id: 'settings' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/domainCard/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/domainCard/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.domain = CONFIG.DH.DOMAIN.allDomains()[this.document.system.domain];
        context.domainChoices = CONFIG.DH.DOMAIN.orderedDomains();

        return context;
    }
}

class FeatureSheet extends DHBaseItemSheet {
    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['feature'],
        actions: {}
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/feature/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        settings: { template: 'systems/daggerheart/templates/sheets/items/feature/settings.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /**@override */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'settings' }, { id: 'actions' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };
}

class LootSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['loot'],
        position: { width: 550 }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/loot/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/loot/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };
}

class SubclassSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['subclass'],
        position: { width: 600 },
        window: { resizable: true }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/subclass/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/items/subclass/features.hbs',
            scrollable: ['.features']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/subclass/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'features' }, { id: 'settings' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features.map(x => x.item);
    }
}

class WeaponSheet extends ItemAttachmentSheet(DHBaseItemSheet) {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['weapon'],
        tagifyConfigs: [
            {
                selector: '.features-input',
                options: () => CONFIG.DH.ITEM.orderedWeaponFeatures(),
                callback: WeaponSheet.#onFeatureSelect
            }
        ]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/weapon/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/weapon/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        },
        ...super.PARTS
    };

    /**@inheritdoc */
    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);
        switch (partId) {
            case 'settings':
                context.features = this.document.system.weaponFeatures.map(x => x.value);
                context.systemFields.attack.fields = this.document.system.attack.schema.fields;
                break;
        }
        return context;
    }

    /**
     * Callback function used by `tagifyElement`.
     * @param {Array<Object>} selectedOptions - The currently selected tag objects.
     */
    static async #onFeatureSelect(selectedOptions) {
        await this.document.update({ 'system.weaponFeatures': selectedOptions.map(x => ({ value: x.value })) });
    }
}

var _module$b = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Ancestry: AncestrySheet,
    Armor: ArmorSheet,
    Beastform: BeastformSheet,
    Class: ClassSheet,
    Community: CommunitySheet,
    Consumable: ConsumableSheet,
    DomainCard: DomainCardSheet,
    Feature: FeatureSheet,
    Loot: LootSheet,
    Subclass: SubclassSheet,
    Weapon: WeaponSheet
});

var _module$a = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actors: _module$c,
    api: _modules$1,
    items: _module$b
});

class DHActionSettingsConfig extends DHActionBaseConfig {
    constructor(action, effects, sheetUpdate) {
        super(action);

        this.effects = effects;
        this.sheetUpdate = sheetUpdate;
    }

    static DEFAULT_OPTIONS = {
        ...DHActionBaseConfig.DEFAULT_OPTIONS,
        actions: {
            ...DHActionBaseConfig.DEFAULT_OPTIONS.actions,
            addEffect: this.addEffect,
            removeEffect: this.removeEffect,
            editEffect: this.editEffect
        }
    };

    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.effects = this.effects;
        context.getEffectDetails = this.getEffectDetails.bind(this);

        return context;
    }

    getEffectDetails(id) {
        return this.effects.find(x => x.id === id);
    }

    static async addEffect(_event) {
        if (!this.action.effects) return;
        const effectData = game.system.api.data.activeEffects.BaseEffect.getDefaultObject();
        const data = this.action.toObject();

        this.sheetUpdate(data, effectData);
        this.effects = [...this.effects, effectData];
        data.effects.push({ _id: effectData.id });
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static removeEffect(event, button) {
        if (!this.action.effects) return;
        const index = button.dataset.index,
            effectId = this.action.effects[index]._id;
        this.constructor.removeElement.bind(this)(event, button);
        this.sheetUpdate(
            this.action.toObject(),
            this.effects.find(x => x.id === effectId),
            true
        );
    }

    static async editEffect(event) {
        const id = event.target.closest('[data-effect-id]')?.dataset?.effectId;
        const updatedEffect = await game.system.api.applications.sheetConfigs.SettingActiveEffectConfig.configure(
            this.getEffectDetails(id)
        );
        if (!updatedEffect) return;

        this.effects = await this.sheetUpdate(this.action.toObject(), { ...updatedEffect, id });
        this.render();
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHCharacterSettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['character-settings'],
        position: { width: 455, height: 'auto' },
        actions: {
            addExperience: DHCharacterSettings.#addExperience,
            removeExperience: DHCharacterSettings.#removeExperience
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/character-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/character-settings/details.hbs'
        },
        experiences: {
            id: 'experiences',
            template: 'systems/daggerheart/templates/sheets-settings/character-settings/experiences.hbs'
        }
    };

    /** @override */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'experiences' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

        return context;
    }

    /* -------------------------------------------- */

    /**
     * Adds a new experience entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addExperience() {
        const newExperience = {
            name: 'Experience',
            modifier: 0
        };
        await this.actor.update({ [`system.experiences.${foundry.utils.randomID()}`]: newExperience });
    }

    /**
     * Removes an experience entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeExperience(_, target) {
        const experience = this.actor.system.experiences[target.dataset.experience];
        const updates = {};

        const relinkAchievementData = [];
        const relinkSelectionData = [];
        Object.keys(this.actor.system.levelData.levelups).forEach(key => {
            const level = this.actor.system.levelData.levelups[key];

            const achievementIncludesExp = level.achievements.experiences[target.dataset.experience];
            if (achievementIncludesExp)
                relinkAchievementData.push({ levelKey: key, experience: target.dataset.experience });

            const selectionIndex = level.selections.findIndex(
                x => x.optionKey === 'experience' && x.data[0] === target.dataset.experience
            );
            if (selectionIndex !== -1)
                relinkSelectionData.push({ levelKey: key, selectionIndex, experience: target.dataset.experience });
        });

        if (relinkAchievementData.length > 0 || relinkSelectionData.length > 0) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.ACTORS.Character.experienceDataRemoveConfirmation.title')
                },
                content: game.i18n.localize('DAGGERHEART.ACTORS.Character.experienceDataRemoveConfirmation.text')
            });
            if (!confirmed) return;
        }

        if (relinkAchievementData.length > 0) {
            relinkAchievementData.forEach(data => {
                updates[`system.levelData.levelups.${data.levelKey}.achievements.experiences.-=${data.experience}`] =
                    null;
            });
        } else if (relinkSelectionData.length > 0) {
            relinkSelectionData.forEach(data => {
                updates[`system.levelData.levelups.${data.levelKey}.selections`] = this.actor.system.levelData.levelups[
                    data.levelKey
                ].selections.reduce((acc, selection, index) => {
                    if (
                        index === data.selectionIndex &&
                        selection.optionKey === 'experience' &&
                        selection.data.includes(data.experience)
                    ) {
                        acc.push({ ...selection, data: selection.data.filter(x => x !== data.experience) });
                    } else {
                        acc.push(selection);
                    }

                    return acc;
                }, []);
            });
        } else {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                        type: game.i18n.localize(`DAGGERHEART.GENERAL.Experience.single`),
                        name: experience.name
                    })
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: experience.name })
            });
            if (!confirmed) return;
        }

        await this.actor.update({
            ...updates,
            [`system.experiences.-=${target.dataset.experience}`]: null
        });
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHAdversarySettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['adversary-settings'],
        position: { width: 455, height: 'auto' },
        actions: {
            addExperience: DHAdversarySettings.#addExperience,
            removeExperience: DHAdversarySettings.#removeExperience
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/details.hbs'
        },
        attack: {
            id: 'attack',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/attack.hbs'
        },
        experiences: {
            id: 'experiences',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/experiences.hbs'
        },
        features: {
            id: 'features',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/features.hbs'
        }
    };

    /** @override */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'attack' }, { id: 'experiences' }, { id: 'features' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /* -------------------------------------------- */

    /**
     * Adds a new experience entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addExperience() {
        const newExperience = {
            name: 'Experience',
            modifier: 0
        };
        await this.actor.update({ [`system.experiences.${foundry.utils.randomID()}`]: newExperience });
    }

    /**
     * Removes an experience entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeExperience(_, target) {
        const experience = this.actor.system.experiences[target.dataset.experience];
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                    type: game.i18n.localize(`DAGGERHEART.GENERAL.Experience.single`),
                    name: experience.name
                })
            },
            content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: experience.name })
        });
        if (!confirmed) return;

        await this.actor.update({ [`system.experiences.-=${target.dataset.experience}`]: null });
    }

    async _onDragStart(event) {
        const featureItem = event.currentTarget.closest('.feature-item');

        if (featureItem) {
            const feature = this.actor.items.get(featureItem.id);
            const featureData = { type: 'Item', uuid: feature.uuid, fromInternal: true };
            event.dataTransfer.setData('text/plain', JSON.stringify(featureData));
            event.dataTransfer.setDragImage(featureItem.querySelector('img'), 60, 0);
        }
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        
        const item = await fromUuid(data.uuid);
        if (item?.type === 'feature') {
            if (data.fromInternal && item.parent?.uuid === this.actor.uuid) {
                return;
            }
            
            const itemData = item.toObject();
            delete itemData._id;
            
            await this.actor.createEmbeddedDocuments('Item', [itemData]);
        }
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHCompanionSettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['companion-settings'],
        position: { width: 455, height: 'auto' },
        actions: {
            addExperience: DHCompanionSettings.#addExperience,
            removeExperience: DHCompanionSettings.#removeExperience
        }
    };

    /**@inheritdoc */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/details.hbs'
        },
        experiences: {
            id: 'experiences',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/experiences.hbs'
        },
        attack: {
            id: 'attack',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/attack.hbs'
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'attack' }, { id: 'experiences' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    async _onRender(context, options) {
        await super._onRender(context, options);
        this.element.querySelector('.partner-value')?.addEventListener('change', this.onPartnerChange.bind(this));
    }

    /**@inheritdoc */
    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);

        context.playerCharacters = game.actors
            .filter(x => x.type === 'character' && (x.isOwner || this.document.system.partner?.uuid === x.uuid))
            .map(x => ({ key: x.uuid, name: x.name }));

        return context;
    }

    /**
     * Handles changes to the actor's partner selection.
     * @param {Event} event - The change event triggered by the partner input element.
     */
    async onPartnerChange(event) {
        const value = event.target.value;
        const partnerDocument = value ? await foundry.utils.fromUuid(value) : this.actor.system.partner;
        const partnerUpdate = { 'system.companion': value ? this.actor.uuid : null };

        if (!partnerDocument.isOwner) {
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateDocument,
                    uuid: partnerDocument.uuid,
                    update: partnerUpdate
                }
            });
        } else {
            await partnerDocument.update(partnerUpdate);
        }

        await this.actor.update({ 'system.partner': value });

        if (!value) await this.actor.updateLevel(1);
    }

    /**
     * Adds a new experience entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addExperience() {
        const newExperience = {
            name: 'Experience',
            modifier: 0
        };
        await this.actor.update({ [`system.experiences.${foundry.utils.randomID()}`]: newExperience });
    }

    /**
     * Removes an experience entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeExperience(_, target) {
        const experience = this.actor.system.experiences[target.dataset.experience];
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                    type: game.i18n.localize(`DAGGERHEART.GENERAL.Experience.single`),
                    name: experience.name
                })
            },
            content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: experience.name })
        });
        if (!confirmed) return;

        await this.actor.update({ [`system.experiences.-=${target.dataset.experience}`]: null });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$5, ApplicationV2: ApplicationV2$5 } = foundry.applications.api;

class SettingActiveEffectConfig extends HandlebarsApplicationMixin$5(ApplicationV2$5) {
    constructor(effect) {
        super({});

        this.effect = foundry.utils.deepClone(effect);
        const ignoredActorKeys = ['config', 'DhEnvironment'];
        this.changeChoices = Object.keys(game.system.api.models.actors).reduce((acc, key) => {
            if (!ignoredActorKeys.includes(key)) {
                const model = game.system.api.models.actors[key];
                const attributes = CONFIG.Token.documentClass.getTrackedAttributes(model);
                const group = game.i18n.localize(model.metadata.label);
                const choices = CONFIG.Token.documentClass
                    .getTrackedAttributeChoices(attributes, model)
                    .map(x => ({ ...x, group: group }));
                acc.push(...choices);
            }
            return acc;
        }, []);
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'sheet', 'dh-style', 'active-effect-config', 'standard-form'],
        tag: 'form',
        position: {
            width: 560
        },
        form: {
            submitOnChange: false,
            closeOnSubmit: false,
            handler: SettingActiveEffectConfig.#onSubmit
        },
        actions: {
            editImage: SettingActiveEffectConfig.#editImage,
            addChange: SettingActiveEffectConfig.#addChange,
            deleteChange: SettingActiveEffectConfig.#deleteChange
        }
    };

    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/activeEffect/header.hbs' },
        tabs: { template: 'templates/generic/tab-navigation.hbs' },
        details: { template: 'systems/daggerheart/templates/sheets/activeEffect/details.hbs', scrollable: [''] },
        settings: { template: 'systems/daggerheart/templates/sheets/activeEffect/settings.hbs' },
        changes: {
            template: 'systems/daggerheart/templates/sheets/activeEffect/changes.hbs',
            scrollable: ['ol[data-changes]']
        },
        footer: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-form-footer.hbs' }
    };

    static TABS = {
        sheet: {
            tabs: [
                { id: 'details', icon: 'fa-solid fa-book' },
                { id: 'settings', icon: 'fa-solid fa-bars', label: 'DAGGERHEART.GENERAL.Tabs.settings' },
                { id: 'changes', icon: 'fa-solid fa-gears' }
            ],
            initial: 'details',
            labelPrefix: 'EFFECT.TABS'
        }
    };

    /**@inheritdoc */
    async _onFirstRender(context, options) {
        await super._onFirstRender(context, options);
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.source = this.effect;
        context.fields = game.system.api.documents.DhActiveEffect.schema.fields;
        context.systemFields = game.system.api.data.activeEffects.BaseEffect._schema.fields;

        return context;
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        const changeChoices = this.changeChoices;

        htmlElement.querySelectorAll('.effect-change-input').forEach(element => {
            autocomplete({
                input: element,
                fetch: function (text, update) {
                    if (!text) {
                        update(changeChoices);
                    } else {
                        text = text.toLowerCase();
                        var suggestions = changeChoices.filter(n => n.label.toLowerCase().includes(text));
                        update(suggestions);
                    }
                },
                render: function (item, search) {
                    const label = game.i18n.localize(item.label);
                    const matchIndex = label.toLowerCase().indexOf(search);

                    const beforeText = label.slice(0, matchIndex);
                    const matchText = label.slice(matchIndex, matchIndex + search.length);
                    const after = label.slice(matchIndex + search.length, label.length);

                    const element = document.createElement('li');
                    element.innerHTML = `${beforeText}${matchText ? `<strong>${matchText}</strong>` : ''}${after}`;
                    if (item.hint) {
                        element.dataset.tooltip = game.i18n.localize(item.hint);
                    }

                    return element;
                },
                renderGroup: function (label) {
                    const itemElement = document.createElement('div');
                    itemElement.textContent = game.i18n.localize(label);
                    return itemElement;
                },
                onSelect: function (item) {
                    element.value = `system.${item.value}`;
                },
                click: e => e.fetch(),
                customize: function (_input, _inputRect, container) {
                    container.style.zIndex = foundry.applications.api.ApplicationV2._maxZ;
                },
                minLength: 0
            });
        });
    }

    async _preparePartContext(partId, context) {
        if (partId in context.tabs) context.tab = context.tabs[partId];
        switch (partId) {
            case 'details':
                context.statuses = CONFIG.statusEffects.map(s => ({ value: s.id, label: game.i18n.localize(s.name) }));
                context.isActorEffect = false;
                context.isItemEffect = true;
                const useGeneric = game.settings.get(
                    CONFIG.DH.id,
                    CONFIG.DH.SETTINGS.gameSettings.appearance
                ).showGenericStatusEffects;
                if (!useGeneric) {
                    context.statuses = [
                        ...context.statuses,
                        Object.values(CONFIG.DH.GENERAL.conditions).map(status => ({
                            value: status.id,
                            label: game.i18n.localize(status.name)
                        }))
                    ];
                }
                break;
            case 'changes':
                context.modes = Object.entries(CONST.ACTIVE_EFFECT_MODES).reduce((modes, [key, value]) => {
                    modes[value] = game.i18n.localize(`EFFECT.MODE_${key}`);
                    return modes;
                }, {});

                context.priorities = ActiveEffectConfig.DEFAULT_PRIORITIES;
                break;
        }

        return context;
    }

    static async #onSubmit(_event, _form, formData) {
        this.data = foundry.utils.expandObject(formData.object);
        this.close();
    }

    /**
     * Edit a Document image.
     * @this {DocumentSheetV2}
     * @type {ApplicationClickAction}
     */
    static async #editImage(_event, target) {
        if (target.nodeName !== 'IMG') {
            throw new Error('The editImage action is available only for IMG elements.');
        }

        const attr = target.dataset.edit;
        const current = foundry.utils.getProperty(this.effect, attr);
        const fp = new FilePicker.implementation({
            current,
            type: 'image',
            callback: path => (target.src = path),
            position: {
                top: this.position.top + 40,
                left: this.position.left + 10
            }
        });

        await fp.browse();
    }

    /**
     * Add a new change to the effect's changes array.
     * @this {ActiveEffectConfig}
     * @type {ApplicationClickAction}
     */
    static async #addChange() {
        const { changes, ...rest } = foundry.utils.expandObject(new FormDataExtended(this.form).object);
        const updatedChanges = Object.values(changes ?? {});
        updatedChanges.push({});

        this.effect = { ...rest, changes: updatedChanges };
        this.render();
    }

    /**
     * Delete a change from the effect's changes array.
     * @this {ActiveEffectConfig}
     * @type {ApplicationClickAction}
     */
    static async #deleteChange(event) {
        const submitData = foundry.utils.expandObject(new FormDataExtended(this.form).object);
        const updatedChanges = Object.values(submitData.changes);
        const row = event.target.closest('li');
        const index = Number(row.dataset.index) || 0;
        updatedChanges.splice(index, 1);

        this.effect = { ...submitData, changes: updatedChanges };
        this.render();
    }

    static async configure(effect, options = {}) {
        return new Promise(resolve => {
            const app = new this(effect, options);
            app.addEventListener('close', () => resolve(app.data), { once: true });
            app.render({ force: true });
        });
    }
}

const fields$e = foundry.data.fields;

class DamageField extends fields$e.SchemaField {
    /**
     * Action Workflow order
     */
    static order = 20;

    /** @inheritDoc */
    constructor(options, context = {}) {
        const damageFields = {
            parts: new fields$e.ArrayField(new fields$e.EmbeddedDataField(DHDamageData)),
            includeBase: new fields$e.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.includeBase.label'
            }),
            direct: new fields$e.BooleanField({ initial: false, label: 'DAGGERHEART.CONFIG.DamageType.direct.name' })
        };
        super(damageFields, options, context);
    }

    /**
     * Roll Damage/Healing Action Workflow part.
     * Must be called within Action context or similar.
     * @param {object} config               Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @param {string} [messageId=null]     ChatMessage Id where the clicked button belong.
     * @param {boolean} [force=false]       If the method should be executed outside of Action workflow, for ChatMessage button for example.
     */
    static async execute(config, messageId = null, force = false) {
        if (!this.hasDamage && !this.hasHealing) return;
        if (
            this.hasRoll &&
            DamageField.getAutomation() === CONFIG.DH.SETTINGS.actionAutomationChoices.never.id &&
            !force
        )
            return;

        let formulas = this.damage.parts.map(p => ({
            formula: DamageField.getFormulaValue.call(this, p, config).getFormula(this.actor),
            damageTypes: p.applyTo === 'hitPoints' && !p.type.size ? new Set(['physical']) : p.type,
            applyTo: p.applyTo
        }));

        if (!formulas.length) return false;

        formulas = DamageField.formatFormulas.call(this, formulas, config);

        const damageConfig = {
            ...config,
            roll: formulas,
            dialog: {},
            data: this.getRollData()
        };
        delete damageConfig.evaluate;

        if (DamageField.getAutomation() === CONFIG.DH.SETTINGS.actionAutomationChoices.always.id)
            damageConfig.dialog.configure = false;
        if (config.hasSave) config.onSave = damageConfig.onSave = this.save.damageMod;

        damageConfig.source.message = config.message?._id ?? messageId;
        damageConfig.directDamage = !!damageConfig.source?.message;

        // if(damageConfig.source?.message && game.modules.get('dice-so-nice')?.active)
        //     await game.dice3d.waitFor3DAnimationByMessageID(damageConfig.source.message);

        const damageResult = await CONFIG.Dice.daggerheart.DamageRoll.build(damageConfig);
        if (!damageResult) return false;
        config.damage = damageResult.damage;
        config.message ??= damageConfig.message;
    }

    /**
     * Apply Damage/Healing Action Worflow part.
     * @param {object} config        Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @param {*[]} targets     Arrays of targets to bypass pre-selected ones.
     * @param {boolean} force   If the method should be executed outside of Action workflow, for ChatMessage button for example.
     */
    static async applyDamage(config, targets = null, force = false) {
        targets ??= config.targets.filter(target => target.hit);
        if (!config.damage || !targets?.length || (!DamageField.getApplyAutomation() && !force)) return;

        const targetDamage = [];
        const damagePromises = [];
        for (let target of targets) {
            const actor = foundry.utils.fromUuidSync(target.actorId);
            if (!actor) continue;
            if (!config.hasHealing && config.onSave && target.saved?.success === true) {
                const mod = CONFIG.DH.ACTIONS.damageOnSave[config.onSave]?.mod ?? 1;
                Object.entries(config.damage).forEach(([k, v]) => {
                    v.total = 0;
                    v.parts.forEach(part => {
                        part.total = Math.ceil(part.total * mod);
                        v.total += part.total;
                    });
                });
            }

            const token = target.id
                ? game.scenes.find(x => x.active).tokens.find(x => x.id === target.id)
                : actor.prototypeToken;
            if (config.hasHealing)
                damagePromises.push(
                    actor.takeHealing(config.damage).then(updates => targetDamage.push({ token, updates }))
                );
            else
                damagePromises.push(
                    actor
                        .takeDamage(config.damage, config.isDirect)
                        .then(updates => targetDamage.push({ token, updates }))
                );
        }

        Promise.all(damagePromises).then(async _ => {
            const summaryMessageSettings = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.Automation
            ).summaryMessages;
            if (!summaryMessageSettings.damage) return;

            const cls = getDocumentClass('ChatMessage');
            const msg = {
                type: 'systemMessage',
                user: game.user.id,
                speaker: cls.getSpeaker(),
                title: game.i18n.localize(
                    `DAGGERHEART.UI.Chat.damageSummary.${config.hasHealing ? 'healingTitle' : 'title'}`
                ),
                content: await foundry.applications.handlebars.renderTemplate(
                    'systems/daggerheart/templates/ui/chat/damageSummary.hbs',
                    {
                        targets: targetDamage
                    }
                )
            };

            cls.create(msg);
        });
    }

    /**
     * Return value or valueAlt from damage part
     * Must be called within Action context or similar.
     * @param {object} part Damage Part
     * @param {object} data Action getRollData
     * @returns Formula value object
     */
    static getFormulaValue(part, data) {
        let formulaValue = part.value;

        if (data.hasRoll && part.resultBased && data.roll.result.duality === -1) return part.valueAlt;

        const isAdversary = this.actor.type === 'adversary';
        if (isAdversary && this.actor.system.type === CONFIG.DH.ACTOR.adversaryTypes.horde.id) {
            const hasHordeDamage = this.actor.effects.find(x => x.type === 'horde');
            if (hasHordeDamage && !hasHordeDamage.disabled) return part.valueAlt;
        }

        return formulaValue;
    }

    /**
     * Prepare formulas for Damage Roll
     * Must be called within Action context or similar.
     * @param {object[]} formulas   Array of formatted formulas object
     * @param {object} data         Action getRollData
     * @returns
     */
    static formatFormulas(formulas, data) {
        const formattedFormulas = [];
        formulas.forEach(formula => {
            if (isNaN(formula.formula))
                formula.formula = Roll.replaceFormulaData(formula.formula, this.getRollData(data));
            const same = formattedFormulas.find(
                f => setsEqual(f.damageTypes, formula.damageTypes) && f.applyTo === formula.applyTo
            );
            if (same) same.formula += ` + ${formula.formula}`;
            else formattedFormulas.push(formula);
        });
        return formattedFormulas;
    }

    /**
     * Return the automation setting for execute method for current user role
     * @returns {string} Id from settingsConfig.mjs actionAutomationChoices
     */
    static getAutomation() {
        return (
            (game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.damage.gm) ||
            (!game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.damage.players)
        );
    }

    /**
     * Return the automation setting for applyDamage method for current user role
     * @returns {boolean} If applyDamage should be triggered automatically
     */
    static getApplyAutomation() {
        return (
            (game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.damageApply.gm) ||
            (!game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.damageApply.players)
        );
    }
}

class DHActionDiceData extends foundry.abstract.DataModel {
    /** @override */
    static defineSchema() {
        return {
            multiplier: new fields$e.StringField({
                choices: CONFIG.DH.GENERAL.multiplierTypes,
                initial: 'prof',
                label: 'DAGGERHEART.ACTIONS.Config.damage.multiplier',
                nullable: false,
                required: true
            }),
            flatMultiplier: new fields$e.NumberField({
                nullable: true,
                initial: 1,
                label: 'DAGGERHEART.ACTIONS.Config.damage.flatMultiplier'
            }),
            dice: new fields$e.StringField({
                choices: CONFIG.DH.GENERAL.diceTypes,
                initial: 'd6',
                label: 'DAGGERHEART.GENERAL.Dice.single',
                nullable: false,
                required: true
            }),
            bonus: new fields$e.NumberField({ nullable: true, initial: null, label: 'DAGGERHEART.GENERAL.bonus' }),
            custom: new fields$e.SchemaField({
                enabled: new fields$e.BooleanField({ label: 'DAGGERHEART.ACTIONS.Config.general.customFormula' }),
                formula: new FormulaField({ label: 'DAGGERHEART.ACTIONS.Config.general.formula', initial: '' })
            })
        };
    }

    getFormula() {
        const multiplier = this.multiplier === 'flat' ? this.flatMultiplier : `@${this.multiplier}`,
            bonus = this.bonus ? (this.bonus < 0 ? ` - ${Math.abs(this.bonus)}` : ` + ${this.bonus}`) : '';
        return this.custom.enabled ? this.custom.formula : `${multiplier ?? 1}${this.dice}${bonus}`;
    }
}

class DHResourceData extends foundry.abstract.DataModel {
    /** @override */
    static defineSchema() {
        return {
            applyTo: new fields$e.StringField({
                choices: CONFIG.DH.GENERAL.healingTypes,
                required: true,
                blank: false,
                initial: CONFIG.DH.GENERAL.healingTypes.hitPoints.id,
                label: 'DAGGERHEART.ACTIONS.Settings.applyTo.label'
            }),
            resultBased: new fields$e.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.resultBased.label'
            }),
            value: new fields$e.EmbeddedDataField(DHActionDiceData),
            valueAlt: new fields$e.EmbeddedDataField(DHActionDiceData)
        };
    }
}

class DHDamageData extends DHResourceData {
    /** @override */
    static defineSchema() {
        return {
            ...super.defineSchema(),
            base: new fields$e.BooleanField({ initial: false, readonly: true, label: 'Base' }),
            type: new fields$e.SetField(
                new fields$e.StringField({
                    choices: CONFIG.DH.GENERAL.damageTypes,
                    initial: 'physical',
                    nullable: false,
                    required: true
                }),
                {
                    label: 'Type'
                }
            )
        };
    }
}

const fields$d = foundry.data.fields;

const targetsField = () =>
    new fields$d.ArrayField(
        new fields$d.SchemaField({
            id: new fields$d.StringField({}),
            actorId: new fields$d.StringField({}),
            name: new fields$d.StringField({}),
            img: new fields$d.StringField({}),
            difficulty: new fields$d.NumberField({ integer: true, nullable: true }),
            evasion: new fields$d.NumberField({ integer: true }),
            hit: new fields$d.BooleanField({ initial: false }),
            saved: new fields$d.SchemaField({
                result: new fields$d.NumberField(),
                success: new fields$d.BooleanField({ nullable: true, initial: null })
            })
        })
    );

const originItemField = () =>
    new fields$d.SchemaField({
        type: new fields$d.StringField({
            choices: CONFIG.DH.ITEM.originItemType,
            initial: CONFIG.DH.ITEM.originItemType.itemCollection
        }),
        itemPath: new fields$d.StringField(),
        actionIndex: new fields$d.StringField()
    });

class DHActorRoll extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        return {
            title: new fields$d.StringField(),
            roll: new fields$d.ObjectField(),
            targets: targetsField(),
            hasRoll: new fields$d.BooleanField({ initial: false }),
            hasDamage: new fields$d.BooleanField({ initial: false }),
            hasHealing: new fields$d.BooleanField({ initial: false }),
            hasEffect: new fields$d.BooleanField({ initial: false }),
            hasSave: new fields$d.BooleanField({ initial: false }),
            hasTarget: new fields$d.BooleanField({ initial: false }),
            isDirect: new fields$d.BooleanField({ initial: false }),
            isCritical: new fields$d.BooleanField({ initial: false }),
            onSave: new fields$d.StringField(),
            source: new fields$d.SchemaField({
                actor: new fields$d.StringField(),
                item: new fields$d.StringField(),
                originItem: originItemField(),
                action: new fields$d.StringField()
            }),
            damage: new fields$d.ObjectField(),
            costs: new fields$d.ArrayField(new fields$d.ObjectField()),
            successConsumed: new fields$d.BooleanField({ initial: false })
        };
    }

    get actionActor() {
        if (!this.source.actor) return null;
        return fromUuidSync(this.source.actor);
    }

    get actionItem() {
        const actionActor = this.actionActor;
        if (!actionActor || !this.source.item) return null;

        switch (this.source.originItem.type) {
            case CONFIG.DH.ITEM.originItemType.restMove:
                const restMoves = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).restMoves;
                return Array.from(foundry.utils.getProperty(restMoves, `${this.source.originItem.itemPath}`).actions)[
                    this.source.originItem.actionIndex
                ];
            default:
                const item = actionActor.items.get(this.source.item);
                return item ? item.system.actionsList?.find(a => a.id === this.source.action) : null;
        }
    }

    get action() {
        const { actionActor, actionItem: itemAction } = this;
        if (!this.source.action) return null;
        if (itemAction) return itemAction;
        else if (actionActor?.system.attack?._id === this.source.action) return actionActor.system.attack;
        return null;
    }

    get targetMode() {
        return this.parent.targetSelection;
    }

    set targetMode(mode) {
        if (!this.parent.isAuthor) return;
        this.parent.targetSelection = mode;
        this.registerTargetHook();
        this.updateTargets();
    }

    get hitTargets() {
        return this.currentTargets.filter(t => t.hit || !this.hasRoll || !this.targetMode);
    }

    async updateTargets() {
        if (!ui.chat.collection.get(this.parent.id)) return;
        let targets;
        if (this.targetMode) targets = this.targets;
        else
            targets = Array.from(game.user.targets).map(t =>
                game.system.api.fields.ActionFields.TargetField.formatTarget(t)
            );

        await this.parent.update({
            flags: {
                [game.system.id]: {
                    targets: targets,
                    targetMode: this.targetMode
                }
            }
        });
    }

    registerTargetHook() {
        if (!this.parent.isAuthor || !this.hasTarget) return;
        if (this.targetMode && this.parent.targetHook !== null) {
            Hooks.off('targetToken', this.parent.targetHook);
            return (this.parent.targetHook = null);
        } else if (!this.targetMode && this.parent.targetHook === null) {
            return (this.parent.targetHook = Hooks.on(
                'targetToken',
                foundry.utils.debounce(this.updateTargets.bind(this), 50)
            ));
        }
    }

    prepareDerivedData() {
        if (this.hasTarget) {
            this.hasHitTarget = this.targets.filter(t => t.hit === true).length > 0;
            this.currentTargets = this.getTargetList();
            // this.registerTargetHook();

            if (this.hasRoll) {
                this.targetShort = this.targets.reduce(
                    (a, c) => {
                        if (c.hit) a.hit += 1;
                        else a.miss += 1;
                        return a;
                    },
                    { hit: 0, miss: 0 }
                );
            }
            if (this.hasSave) this.setPendingSaves();
        }

        this.canViewSecret = this.parent.speakerActor?.testUserPermission(game.user, 'OBSERVER');
        this.canButtonApply = game.user.isGM; //temp
        this.isGM = game.user.isGM; //temp
    }

    getTargetList() {
        const targets =
                this.targetMode && this.parent.isAuthor
                    ? this.targets
                    : (this.parent.getFlag(game.system.id, 'targets') ?? this.targets),
            reactionRolls = this.parent.getFlag(game.system.id, 'reactionRolls');

        if (reactionRolls) {
            Object.entries(reactionRolls).forEach(([k, r]) => {
                const target = targets.find(t => t.id === k);
                if (target) target.saved = r;
            });
        }

        return targets;
    }

    setPendingSaves() {
        this.pendingSaves = this.targetMode
            ? this.targets.filter(target => target.hit && target.saved.success === null).length > 0
            : this.currentTargets.filter(target => target.saved.success === null).length > 0;
    }
}

const fields$c = foundry.data.fields;

/*
    ToDo
    - Target Check / Target Picker
    - Range Check
    - Area of effect and measurement placement
    - Summon Action create method
*/

class DHBaseAction extends ActionMixin(foundry.abstract.DataModel) {
    static extraSchemas = ['cost', 'uses', 'range'];

    /** @inheritDoc */
    static defineSchema() {
        const schemaFields = {
            _id: new fields$c.DocumentIdField({ initial: () => foundry.utils.randomID() }),
            systemPath: new fields$c.StringField({ required: true, initial: 'actions' }),
            type: new fields$c.StringField({ initial: undefined, readonly: true, required: true }),
            baseAction: new fields$c.BooleanField({ initial: false }),
            name: new fields$c.StringField({ initial: undefined }),
            description: new fields$c.HTMLField(),
            img: new fields$c.FilePathField({ initial: undefined, categories: ['IMAGE'], base64: false }),
            chatDisplay: new fields$c.BooleanField({ initial: true, label: 'DAGGERHEART.ACTIONS.Config.displayInChat' }),
            originItem: originItemField(),
            actionType: new fields$c.StringField({
                choices: CONFIG.DH.ITEM.actionTypes,
                initial: 'action',
                nullable: false,
                required: true
            })
        };

        this.extraSchemas.forEach(s => {
            let clsField = this.getActionField(s);
            if (clsField) schemaFields[s] = new clsField();
        });

        return schemaFields;
    }

    /**
     * The default values to supply to schema fields when they are created in the actionConfig. Defined by implementing classes.
     */
    get defaultValues() {
        return {};
    }

    /**
     * Create a Map containing each Action step based on fields define in schema. Ordered by Fields order property.
     *
     * Each step can be called individually as long as needed config is provided.
     * Ex: <action>.workflow.get("damage").execute(config)
     * @returns {Map}
     */
    defineWorkflow() {
        const workflow = new Map();
        this.constructor.extraSchemas.forEach(s => {
            let clsField = this.constructor.getActionField(s);
            if (clsField?.execute) {
                workflow.set(s, { order: clsField.order, execute: clsField.execute.bind(this) });
                if (s === 'damage')
                    workflow.set('applyDamage', { order: 75, execute: clsField.applyDamage.bind(this) });
            }
        });
        return new Map([...workflow.entries()].sort(([aKey, aValue], [bKey, bValue]) => aValue.order - bValue.order));
    }

    /**
     * Getter returning the workflow property or creating it the first time the property is called
     */
    get workflow() {
        if (this.hasOwnProperty('_workflow')) return this._workflow;
        const workflow = Object.freeze(this.defineWorkflow());
        Object.defineProperty(this, '_workflow', { value: workflow, writable: false });
        return workflow;
    }

    /**
     * Get the Field class from ActionFields global config
     * @param {string} name Field short name, equal to Action property
     * @returns Action Field
     */
    static getActionField(name) {
        const field = game.system.api.fields.ActionFields[`${name.capitalize()}Field`];
        return fields$c.DataField.isPrototypeOf(field) && field;
    }

    /** @inheritDoc */
    prepareData() {
        this.name = this.name || game.i18n.localize(CONFIG.DH.ACTIONS.actionTypes[this.type].name);
        this.img = this.img ?? this.parent?.parent?.img;
    }

    /**
     * Get Action ID
     */
    get id() {
        return this._id;
    }

    /**
     * Return Item the action is attached too.
     */
    get item() {
        return this.parent.parent;
    }

    /**
     * Return the first Actor parent found.
     */
    get actor() {
        return this.item instanceof DhpActor
            ? this.item
            : this.item?.parent instanceof DhpActor
              ? this.item.parent
              : this.item?.actor;
    }

    static getRollType(parent) {
        return 'trait';
    }

    /**
     * Prepare base data based on Action Type & Parent Type
     * @param {object} parent
     * @returns {object}
     */
    static getSourceConfig(parent) {
        const updateSource = {};
        if (parent?.parent?.type === 'weapon' && this === game.system.api.models.actions.actionsTypes.attack) {
            updateSource['damage'] = { includeBase: true };
            updateSource['range'] = parent?.attack?.range;
            updateSource['roll'] = {
                useDefault: true
            };
        } else {
            if (parent?.trait) {
                updateSource['roll'] = {
                    type: this.getRollType(parent),
                    trait: parent.trait
                };
            }
            if (parent?.range) {
                updateSource['range'] = parent?.range;
            }
        }
        return updateSource;
    }

    /**
     * Obtain a data object used to evaluate any dice rolls associated with this particular Action
     * @param {object} [data ={}]   Optional data object from previous configuration/rolls
     * @returns {object}
     */
    getRollData(data = {}) {
        if (!this.actor) return null;
        const actorData = this.actor.getRollData(false);

        // Add Roll results to RollDatas
        actorData.result = data.roll?.total ?? 1;

        actorData.scale = data.costs?.length // Right now only return the first scalable cost.
            ? (data.costs.find(c => c.scalable)?.total ?? 1)
            : 1;
        actorData.roll = {};

        return actorData;
    }

    /**
     * Execute each part of the Action workflow in order, calling a specific event before and after each part.
     * @param {object} config Config object usually created from prepareConfig method
     */
    async executeWorkflow(config) {
        for (const [key, part] of this.workflow) {
            if (Hooks.call(`${CONFIG.DH.id}.pre${key.capitalize()}Action`, this, config) === false) return;
            if ((await part.execute(config)) === false) return;
            if (Hooks.call(`${CONFIG.DH.id}.post${key.capitalize()}Action`, this, config) === false) return;
        }
    }

    /**
     * Main method to use the Action
     * @param {Event} event Event from the button used to trigger the Action
     * @returns {object}
     */
    async use(event) {
        if (!this.actor) throw new Error("An Action can't be used outside of an Actor context.");

        if (this.chatDisplay) await this.toChat();

        let config = this.prepareConfig(event);
        if (!config) return;

        if (Hooks.call(`${CONFIG.DH.id}.preUseAction`, this, config) === false) return;

        // Display configuration window if necessary
        if (this.requireConfigurationDialog(config)) {
            config = await D20RollDialog.configure(null, config);
            if (!config) return;
        }

        // Execute the Action Worflow in order based of schema fields
        await this.executeWorkflow(config);

        if (Hooks.call(`${CONFIG.DH.id}.postUseAction`, this, config) === false) return;

        return config;
    }

    /**
     * Create the basic config common to every action type
     * @param {Event} event Event from the button used to trigger the Action
     * @returns {object}
     */
    prepareBaseConfig(event) {
        const config = {
            event,
            title: `${this.item instanceof CONFIG.Actor.documentClass ? '' : `${this.item.name}: `}${game.i18n.localize(this.name)}`,
            source: {
                item: this.item._id,
                originItem: this.originItem,
                action: this._id,
                actor: this.actor.uuid
            },
            dialog: {},
            actionType: this.actionType,
            hasRoll: this.hasRoll,
            hasDamage: this.hasDamage,
            hasHealing: this.hasHealing,
            hasEffect: this.hasEffect,
            hasSave: this.hasSave,
            isDirect: !!this.damage?.direct,
            selectedRollMode: game.settings.get('core', 'rollMode'),
            data: this.getRollData(),
            evaluate: this.hasRoll
        };
        DHBaseAction.applyKeybindings(config);
        return config;
    }

    /**
     * Create the config for that action used for its workflow
     * @param {Event} event Event from the button used to trigger the Action
     * @returns {object}
     */
    prepareConfig(event) {
        const config = this.prepareBaseConfig(event);
        for (const clsField of Object.values(this.schema.fields)) {
            if (clsField?.prepareConfig) if (clsField.prepareConfig.call(this, config) === false) return false;
        }
        return config;
    }

    /**
     * Method used to know if a configuration dialog must be shown or not when there is no roll.
     * @param {*} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @returns {boolean}
     */
    requireConfigurationDialog(config) {
        return !config.event.shiftKey && !config.hasRoll && (config.costs?.length || config.uses);
    }

    /**
     * Consume Action configured resources & uses.
     * That method is only used when we want those resources to be consumed outside of the use method workflow.
     * @param {object} config                Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @param {boolean} successCost
     */
    async consume(config, successCost = false) {
        await this.workflow.get('cost')?.execute(config, successCost);
        await this.workflow.get('uses')?.execute(config, successCost);

        if (config.roll && !config.roll.success && successCost) {
            setTimeout(() => {
                (config.message ?? config.parent).update({ 'system.successConsumed': true });
            }, 50);
        }
    }

    /**
     * Set if a configuration dialog must be shown or not if a special keyboard key is pressed.
     * @param {object} config Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    static applyKeybindings(config) {
        config.dialog.configure ??= !(config.event.shiftKey || config.event.altKey || config.event.ctrlKey);
    }

    /**
     * Getters to know which parts the action is composed of. A field can exist but configured to not be used.
     * @returns {boolean} If that part is in the action.
     */

    get hasRoll() {
        return !!this.roll?.type;
    }

    get hasDamage() {
        return this.damage?.parts?.length && this.type !== 'healing';
    }

    get hasHealing() {
        return this.damage?.parts?.length && this.type === 'healing';
    }

    get hasSave() {
        return !!this.save?.trait;
    }

    get hasEffect() {
        return this.effects?.length > 0;
    }

    /**
     * Generates a list of localized tags for this action.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            game.i18n.localize(`DAGGERHEART.ACTIONS.TYPES.${this.type}.name`),
            game.i18n.localize(`DAGGERHEART.CONFIG.ActionType.${this.actionType}`)
        ];

        return tags;
    }
}

class DHDamageAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'damage', 'target', 'effects'];

    /**
     * Return a display ready damage formula string
     * @returns Formula string
     */
    getDamageFormula() {
        const strings = [];
        for (const { value } of this.damage.parts) {
            strings.push(Roll.replaceFormulaData(value.getFormula(), this.actor?.getRollData() ?? {}));
        }

        return strings.join(' + ');
    }
}

class DHAttackAction extends DHDamageAction {
    static extraSchemas = [...super.extraSchemas, 'roll', 'save'];

    static getRollType(parent) {
        return parent.parent.type === 'weapon' ? 'attack' : 'spellcast';
    }

    prepareData() {
        super.prepareData();
        if (!!this.item?.system?.attack) {
            if (this.damage.includeBase) {
                const baseDamage = this.getParentDamage();
                this.damage.parts.unshift(new DHDamageData(baseDamage));
            }
            if (this.roll.useDefault) {
                this.roll.trait = this.item.system.attack.roll.trait;
                this.roll.type = 'attack';
            }
        }
    }

    getParentDamage() {
        return {
            value: {
                multiplier: 'prof',
                dice: this.item?.system?.attack.damage.parts[0].value.dice,
                bonus: this.item?.system?.attack.damage.parts[0].value.bonus ?? 0
            },
            type: this.item?.system?.attack.damage.parts[0].type,
            base: true
        };
    }

    async use(event, options) {
        const result = await super.use(event, options);

        if (result.message.system.action.roll?.type === 'attack') {
            const { updateCountdowns } = game.system.api.applications.ui.DhCountdowns;
            await updateCountdowns(CONFIG.DH.GENERAL.countdownProgressionTypes.characterAttack.id);
        }

        return result;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        const { roll, range, damage } = this;

        if (roll.trait) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${roll.trait}.short`));
        if (range) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Range.${range}.short`));

        const useAltDamage = this.actor?.effects?.find(x => x.type === 'horde')?.active;
        for (const { value, valueAlt, type } of damage.parts) {
            const usedValue = useAltDamage ? valueAlt : value;
            const str = Roll.replaceFormulaData(usedValue.getFormula(), this.actor?.getRollData() ?? {});

            const icons = Array.from(type)
                .map(t => CONFIG.DH.GENERAL.damageTypes[t]?.icon)
                .filter(Boolean);

            if (icons.length === 0) {
                labels.push(str);
            } else {
                labels.push({ value: str, icons });
            }
        }

        return labels;
    }
}

class DhBeastformAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'beastform'];

    /* async use(event, options) {
        const beastformConfig = this.prepareBeastformConfig();

        const abort = await this.handleActiveTransformations();
        if (abort) return;

        const calcCosts = game.system.api.fields.ActionFields.CostField.calcCosts.call(this, this.cost);
        const hasCost = game.system.api.fields.ActionFields.CostField.hasCost.call(this, calcCosts);
        if (!hasCost) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.insufficientResources'));
            return;
        }

        const { selected, evolved, hybrid } = await BeastformDialog.configure(beastformConfig, this.item);
        if (!selected) return;

        const result = await super.use(event, options);
        if (!result) return;

        await this.transform(selected, evolved, hybrid);
    }

    prepareBeastformConfig(config) {
        const settingsTiers = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers;
        const actorLevel = this.actor.system.levelData.level.current;
        const actorTier =
            Object.values(settingsTiers).find(
                tier => actorLevel >= tier.levels.start && actorLevel <= tier.levels.end
            ) ?? 1;

        return {
            tierLimit: this.beastform.tierAccess.exact ?? actorTier
        };
    }

    async transform(selectedForm, evolvedData, hybridData) {
        const formData = evolvedData?.form ? evolvedData.form.toObject() : selectedForm.toObject();
        const beastformEffect = formData.effects.find(x => x.type === 'beastform');
        if (!beastformEffect) {
            ui.notifications.error('DAGGERHEART.UI.Notifications.beastformMissingEffect');
            return;
        }

        if (evolvedData?.form) {
            const evolvedForm = selectedForm.effects.find(x => x.type === 'beastform');
            if (!evolvedForm) {
                ui.notifications.error('DAGGERHEART.UI.Notifications.beastformMissingEffect');
                return;
            }

            beastformEffect.changes = [...beastformEffect.changes, ...evolvedForm.changes];
            formData.system.features = [...formData.system.features, ...selectedForm.system.features.map(x => x.uuid)];
        }

        if (selectedForm.system.beastformType === CONFIG.DH.ITEM.beastformTypes.hybrid.id) {
            formData.system.advantageOn = Object.values(hybridData.advantages).reduce((advantages, formCategory) => {
                Object.keys(formCategory).forEach(advantageKey => {
                    advantages[advantageKey] = formCategory[advantageKey];
                });
                return advantages;
            }, {});
            formData.system.features = [
                ...formData.system.features,
                ...Object.values(hybridData.features).flatMap(x => Object.keys(x))
            ];
        }

        this.actor.createEmbeddedDocuments('Item', [formData]);
    }

    async handleActiveTransformations() {
        const beastformEffects = this.actor.effects.filter(x => x.type === 'beastform');
        const existingEffects = beastformEffects.length > 0;
        await this.actor.deleteEmbeddedDocuments(
            'ActiveEffect',
            beastformEffects.map(x => x.id)
        );
        return existingEffects;
    } */
}

class DhCountdownAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'countdown'];

    get defaultValues() {
        return {
            ...super.defaultValues,
            countdown: {
                name: this.parent.parent.name,
                img: this.img,
                progress: {
                    startFormula: '1'
                }
            }
        };
    }

    /** @inheritdoc */
    static getSourceConfig(parent) {
        const updateSource = game.system.api.data.actions.actionsTypes.base.getSourceConfig(parent);
        updateSource.name = game.i18n.localize('DAGGERHEART.ACTIONS.Config.countdown.startCountdown');
        updateSource['countdown'] = [
            {
                ...game.system.api.data.countdowns.DhCountdown.defaultCountdown(),
                name: parent.parent.name,
                img: parent.parent.img,
                progress: {
                    startFormula: '1'
                }
            }
        ];

        return updateSource;
    }

    /** @inheritDoc */
    static migrateData(source) {
        for (const countdown of source.countdown) {
            if (countdown.progress.max) {
                countdown.progress.startFormula = countdown.progress.max;
                countdown.progress.start = 1;
                countdown.progress.max = null;
            }
        }

        return super.migrateData(source);
    }
}

class DHEffectAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'effects', 'target'];
}

class DHHealingAction extends DHDamageAction {
    static extraSchemas = [...super.extraSchemas, 'roll'];

    static getRollType(parent) {
        return 'spellcast';
    }
}

class DHMacroAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'macro'];
}

class DHSummonAction extends DHBaseAction {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            documentUUID: new fields.DocumentUUIDField({ type: 'Actor' })
        };
    }

    async trigger(event, ...args) {
        if (!this.canSummon || !canvas.scene) return;
    }

    get canSummon() {
        return game.user.can('TOKEN_CREATE');
    }
}

const actionsTypes = {
    base: DHBaseAction,
    attack: DHAttackAction,
    countdown: DhCountdownAction,
    damage: DHDamageAction,
    healing: DHHealingAction,
    summon: DHSummonAction,
    effect: DHEffectAction,
    macro: DHMacroAction,
    beastform: DhBeastformAction
};

var _module$9 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actionsTypes: actionsTypes
});

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$4, ApplicationV2: ApplicationV2$4 } = foundry.applications.api;

class SettingFeatureConfig extends HandlebarsApplicationMixin$4(ApplicationV2$4) {
    constructor(configTitle, move, movePath, settings, optionalParts, options) {
        super(options);

        this.configTitle = configTitle;
        this.move = move;

        this.movePath = movePath;
        this.actionsPath = `${movePath}.actions`;
        this.settings = settings;

        const { hasIcon, hasEffects } = optionalParts;
        this.hasIcon = hasIcon;
        this.hasEffects = hasEffects;
    }

    get title() {
        return this.configTitle;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'setting', 'dh-style'],
        position: { width: 440, height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            editImage: this.onEditImage,
            addItem: this.addItem,
            editItem: this.editItem,
            removeItem: this.removeItem,
            addEffect: this.addEffect,
            resetMoves: this.resetMoves,
            saveForm: this.saveForm
        },
        form: { handler: this.updateData, submitOnChange: true, closeOnSubmit: false }
    };

    static PARTS = {
        header: { template: 'systems/daggerheart/templates/settings/downtime-config/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        main: { template: 'systems/daggerheart/templates/settings/downtime-config/main.hbs' },
        actions: { template: 'systems/daggerheart/templates/settings/downtime-config/actions.hbs' },
        effects: { template: 'systems/daggerheart/templates/settings/downtime-config/effects.hbs' },
        footer: { template: 'systems/daggerheart/templates/settings/downtime-config/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'main' }, { id: 'actions' }, { id: 'effects' }],
            initial: 'main',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.tabs = this._filterTabs(context.tabs);
        context.hasIcon = this.hasIcon;
        context.hasEffects = this.hasEffects;
        context.move = this.move;
        context.move.enrichedDescription = await foundry.applications.ux.TextEditor.enrichHTML(
            context.move.description
        );

        return context;
    }

    static async updateData(event, element, formData) {
        const data = foundry.utils.expandObject(formData.object);
        foundry.utils.mergeObject(this.move, data);

        this.render();
    }

    static async saveForm() {
        this.close({ submitted: true });
    }

    static onEditImage() {
        const fp = new foundry.applications.apps.FilePicker.implementation({
            current: this.img,
            type: 'image',
            callback: async path => {
                this.move.img = path;
                this.render();
            },
            top: this.position.top + 40,
            left: this.position.left + 10
        });
        return fp.browse();
    }

    async selectActionType() {
        return (
            (await foundry.applications.api.DialogV2.input({
                window: { title: game.i18n.localize('DAGGERHEART.CONFIG.SelectAction.selectType') },
                position: { width: 300 },
                classes: ['daggerheart', 'dh-style'],
                content: await foundry.applications.handlebars.renderTemplate(
                    'systems/daggerheart/templates/actionTypes/actionType.hbs',
                    { types: CONFIG.DH.ACTIONS.actionTypes }
                ),
                ok: {
                    label: game.i18n.format('DOCUMENT.Create', {
                        type: game.i18n.localize('DAGGERHEART.GENERAL.Action.single')
                    })
                }
            })) ?? {}
        );
    }

    static async addItem() {
        const { type: actionType } = await this.selectActionType();
        if (!actionType) return;

        const cls = actionsTypes[actionType] ?? actionsTypes.attack,
            action = new cls(
                {
                    type: actionType,
                    name: game.i18n.localize(CONFIG.DH.ACTIONS.actionTypes[actionType].name),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    actionType: 'action',
                    systemPath: this.actionsPath
                },
                {
                    parent: this.settings
                }
            );

        await this.settings.updateSource({ [`${this.actionsPath}.${action.id}`]: action });
        this.move = foundry.utils.getProperty(this.settings, this.movePath);

        this.render();
    }

    static async editItem(_, target) {
        const { type, id } = target.dataset;
        if (type === 'effect') {
            const effectIndex = this.move.effects.findIndex(x => x.id === id);
            const effect = this.move.effects[effectIndex];
            const updatedEffect =
                await game.system.api.applications.sheetConfigs.SettingActiveEffectConfig.configure(effect);
            if (!updatedEffect) return;

            await this.settings.updateSource({
                [`${this.movePath}.effects`]: this.move.effects.reduce((acc, effect, index) => {
                    acc.push(index === effectIndex ? { ...updatedEffect, id: effect.id } : effect);
                    return acc;
                }, [])
            });
            this.move = foundry.utils.getProperty(this.settings, this.movePath);
            this.render();
        } else {
            const action = this.move.actions.get(id);
            await new DHActionSettingsConfig(action, this.move.effects, async (updatedMove, effectData, deleteEffect) => {
                let updatedEffects = null;
                if (effectData) {
                    const currentEffects = foundry.utils.getProperty(this.settings, `${this.movePath}.effects`);
                    const existingEffectIndex = currentEffects.findIndex(x => x.id === effectData.id);

                    updatedEffects = deleteEffect
                        ? currentEffects.filter(x => x.id !== effectData.id)
                        : existingEffectIndex === -1
                          ? [...currentEffects, effectData]
                          : currentEffects.with(existingEffectIndex, effectData);
                    await this.settings.updateSource({
                        [`${this.movePath}.effects`]: updatedEffects
                    });
                }

                await this.settings.updateSource({ [`${this.actionsPath}.${id}`]: updatedMove });
                this.move = foundry.utils.getProperty(this.settings, this.movePath);
                this.render();
                return updatedEffects;
            }).render(true);
        }
    }

    static async removeItem(_, target) {
        const { type, id } = target.dataset;
        if (type === 'effect') {
            const move = foundry.utils.getProperty(this.settings, this.movePath);
            for (const action of move.actions) {
                const remainingEffects = action.effects.filter(x => x._id !== id);
                if (action.effects.length !== remainingEffects.length) {
                    await action.update({
                        effects: remainingEffects.map(x => {
                            const { _id, ...rest } = x;
                            return { ...rest, _id: _id };
                        })
                    });
                }
            }
            await this.settings.updateSource({
                [this.movePath]: {
                    effects: move.effects.filter(x => x.id !== id),
                    actions: move.actions
                }
            });
        } else {
            await this.settings.updateSource({ [`${this.actionsPath}.-=${target.dataset.id}`]: null });
        }

        this.move = foundry.utils.getProperty(this.settings, this.movePath);
        this.render();
    }

    static async addEffect(_, target) {
        const currentEffects = foundry.utils.getProperty(this.settings, `${this.movePath}.effects`);
        await this.settings.updateSource({
            [`${this.movePath}.effects`]: [
                ...currentEffects,
                game.system.api.data.activeEffects.BaseEffect.getDefaultObject()
            ]
        });

        this.move = foundry.utils.getProperty(this.settings, this.movePath);
        this.render();
    }

    static resetMoves() {}

    _filterTabs(tabs) {
        return this.hasEffects
            ? tabs
            : Object.keys(tabs).reduce((acc, key) => {
                  if (key !== 'effects') acc[key] = tabs[key];
                  return acc;
              }, {});
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.move = null;
    }

    static async configure(configTitle, move, movePath, settings, optionalParts, options = {}) {
        return new Promise(resolve => {
            const app = new this(configTitle, move, movePath, settings, optionalParts, options);
            app.addEventListener('close', () => resolve(app.move), { once: true });
            app.render({ force: true });
        });
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHEnvironmentSettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['environment-settings'],
        actions: {
            addCategory: DHEnvironmentSettings.#addCategory,
            removeCategory: DHEnvironmentSettings.#removeCategory,
            deleteAdversary: DHEnvironmentSettings.#deleteAdversary
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.category-container' },
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/details.hbs'
        },
        features: {
            id: 'features',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/features.hbs'
        },
        adversaries: {
            id: 'adversaries',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/adversaries.hbs'
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'features' }, { id: 'adversaries' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**
     *  Adds a new category entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addCategory() {
        await this.actor.update({
            [`system.potentialAdversaries.${foundry.utils.randomID()}.label`]: game.i18n.localize(
                'DAGGERHEART.ACTORS.Environment.newAdversary'
            )
        });
    }

    /**
     * Removes an category entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeCategory(_, target) {
        await this.actor.update({ [`system.potentialAdversaries.-=${target.dataset.categoryId}`]: null });
    }

    /**
     *
     * @type {ApplicationClickAction}
     * @returns
     */
    static async #deleteAdversary(_event, target) {
        const doc = await getDocFromElement(target);
        const { category } = target.dataset;
        const path = `system.potentialAdversaries.${category}.adversaries`;

        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                    type: game.i18n.localize('TYPES.Actor.adversary'),
                    name: doc.name
                })
            },
            content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: doc.name })
        });

        if (!confirmed) return;

        const adversaries = foundry.utils.getProperty(this.actor, path);
        const newAdversaries = adversaries.filter(a => a.uuid !== doc.uuid);
        await this.actor.update({ [path]: newAdversaries.map(x => x.uuid) });
    }

    async _onDragStart(event) {
        const featureItem = event.currentTarget.closest('.feature-item');

        if (featureItem) {
            const feature = this.actor.items.get(featureItem.id);
            const featureData = { type: 'Item', uuid: feature.uuid, fromInternal: true };
            event.dataTransfer.setData('text/plain', JSON.stringify(featureData));
            event.dataTransfer.setDragImage(featureItem.querySelector('img'), 60, 0);
        }
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        const item = await fromUuid(data.uuid);
        if (data.fromInternal && item?.parent?.uuid === this.actor.uuid) return;

        if (item.type === 'adversary' && event.target.closest('.category-container')) {
            const target = event.target.closest('.category-container');
            const path = `system.potentialAdversaries.${target.dataset.potentialAdversary}.adversaries`;
            const current = foundry.utils.getProperty(this.actor, path).map(x => x.uuid);
            await this.actor.update({
                [path]: [...current, item.uuid]
            });
            this.render();
        } else if (item.type === 'feature' && event.target.closest('.tab.features')) {
            await this.actor.createEmbeddedDocuments('Item', [item]);
            this.render();
        }
    }
}

class DhActiveEffectConfig extends foundry.applications.sheets.ActiveEffectConfig {
    constructor(options) {
        super(options);

        const ignoredActorKeys = ['config', 'DhEnvironment'];
        this.changeChoices = Object.keys(game.system.api.models.actors).reduce((acc, key) => {
            if (!ignoredActorKeys.includes(key)) {
                const model = game.system.api.models.actors[key];
                const attributes = CONFIG.Token.documentClass.getTrackedAttributes(model);
                const group = game.i18n.localize(model.metadata.label);
                const choices = CONFIG.Token.documentClass
                    .getTrackedAttributeChoices(attributes, model)
                    .map(x => ({ ...x, group: group }));
                acc.push(...choices);
            }
            return acc;
        }, []);
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'sheet', 'dh-style']
    };

    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/activeEffect/header.hbs' },
        tabs: { template: 'templates/generic/tab-navigation.hbs' },
        details: { template: 'systems/daggerheart/templates/sheets/activeEffect/details.hbs', scrollable: [''] },
        settings: { template: 'systems/daggerheart/templates/sheets/activeEffect/settings.hbs' },
        changes: {
            template: 'systems/daggerheart/templates/sheets/activeEffect/changes.hbs',
            scrollable: ['ol[data-changes]']
        },
        footer: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-form-footer.hbs' }
    };

    static TABS = {
        sheet: {
            tabs: [
                { id: 'details', icon: 'fa-solid fa-book' },
                { id: 'settings', icon: 'fa-solid fa-bars', label: 'DAGGERHEART.GENERAL.Tabs.settings' },
                { id: 'changes', icon: 'fa-solid fa-gears' }
            ],
            initial: 'details',
            labelPrefix: 'EFFECT.TABS'
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        const changeChoices = this.changeChoices;

        htmlElement.querySelectorAll('.effect-change-input').forEach(element => {
            autocomplete({
                input: element,
                fetch: function (text, update) {
                    if (!text) {
                        update(changeChoices);
                    } else {
                        text = text.toLowerCase();
                        var suggestions = changeChoices.filter(n => n.label.toLowerCase().includes(text));
                        update(suggestions);
                    }
                },
                render: function (item, search) {
                    const label = game.i18n.localize(item.label);
                    const matchIndex = label.toLowerCase().indexOf(search);

                    const beforeText = label.slice(0, matchIndex);
                    const matchText = label.slice(matchIndex, matchIndex + search.length);
                    const after = label.slice(matchIndex + search.length, label.length);

                    const element = document.createElement('li');
                    element.innerHTML = `${beforeText}${matchText ? `<strong>${matchText}</strong>` : ''}${after}`;
                    if (item.hint) {
                        element.dataset.tooltip = game.i18n.localize(item.hint);
                    }

                    return element;
                },
                renderGroup: function (label) {
                    const itemElement = document.createElement('div');
                    itemElement.textContent = game.i18n.localize(label);
                    return itemElement;
                },
                onSelect: function (item) {
                    element.value = `system.${item.value}`;
                },
                click: e => e.fetch(),
                customize: function (_input, _inputRect, container) {
                    container.style.zIndex = foundry.applications.api.ApplicationV2._maxZ;
                },
                minLength: 0
            });
        });
    }

    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.systemFields = context.document.system.schema.fields;

        return context;
    }

    async _preparePartContext(partId, context) {
        const partContext = await super._preparePartContext(partId, context);
        switch (partId) {
            case 'details':
                const useGeneric = game.settings.get(
                    CONFIG.DH.id,
                    CONFIG.DH.SETTINGS.gameSettings.appearance
                ).showGenericStatusEffects;
                if (!useGeneric) {
                    partContext.statuses = Object.values(CONFIG.DH.GENERAL.conditions()).map(status => ({
                        value: status.id,
                        label: game.i18n.localize(status.name)
                    }));
                }
                break;
        }

        return partContext;
    }
}

class DhTokenConfig extends foundry.applications.sheets.TokenConfig {
    /** @inheritDoc */
    async _prepareResourcesTab() {
        const token = this.token;
        const usesTrackableAttributes = !foundry.utils.isEmpty(CONFIG.Actor.trackableAttributes);
        const attributeSource =
            this.actor?.system instanceof foundry.abstract.DataModel && usesTrackableAttributes
                ? this.actor?.type
                : this.actor?.system;
        const TokenDocument = foundry.utils.getDocumentClass('Token');
        const attributes = TokenDocument.getTrackedAttributes(attributeSource);
        return {
            barAttributes: TokenDocument.getTrackedAttributeChoices(attributes, attributeSource),
            bar1: token.getBarAttribute?.('bar1'),
            bar2: token.getBarAttribute?.('bar2'),
            turnMarkerModes: DhTokenConfig.TURN_MARKER_MODES,
            turnMarkerAnimations: CONFIG.Combat.settings.turnMarkerAnimations
        };
    }
}

class DhPrototypeTokenConfig extends foundry.applications.sheets.PrototypeTokenConfig {
    /** @inheritDoc */
    async _prepareResourcesTab() {
        const token = this.token;
        const usesTrackableAttributes = !foundry.utils.isEmpty(CONFIG.Actor.trackableAttributes);
        const attributeSource =
            this.actor?.system instanceof foundry.abstract.DataModel && usesTrackableAttributes
                ? this.actor?.type
                : this.actor?.system;
        const TokenDocument = foundry.utils.getDocumentClass('Token');
        const attributes = TokenDocument.getTrackedAttributes(attributeSource);
        return {
            barAttributes: TokenDocument.getTrackedAttributeChoices(attributes, attributeSource),
            bar1: token.getBarAttribute?.('bar1'),
            bar2: token.getBarAttribute?.('bar2'),
            turnMarkerModes: DhPrototypeTokenConfig.TURN_MARKER_MODES,
            turnMarkerAnimations: CONFIG.Combat.settings.turnMarkerAnimations
        };
    }
}

var _module$8 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActionConfig: DHActionConfig,
    ActionSettingsConfig: DHActionSettingsConfig,
    ActiveEffectConfig: DhActiveEffectConfig,
    AdversarySettings: DHAdversarySettings,
    CharacterSettings: DHCharacterSettings,
    CompanionSettings: DHCompanionSettings,
    DhPrototypeTokenConfig: DhPrototypeTokenConfig,
    DhTokenConfig: DhTokenConfig,
    EnvironmentSettings: DHEnvironmentSettings,
    SettingActiveEffectConfig: SettingActiveEffectConfig,
    SettingFeatureConfig: SettingFeatureConfig
});

class DhActorDirectory extends foundry.applications.sidebar.tabs.ActorDirectory {
    static DEFAULT_OPTIONS = {
        renderUpdateKeys: ['system.levelData.level.current', 'system.partner', 'system.tier']
    };

    static _entryPartial = 'systems/daggerheart/templates/ui/sidebar/actor-document-partial.hbs';

    async _prepareDirectoryContext(context, options) {
        await super._prepareDirectoryContext(context, options);
        const adversaryTypes = CONFIG.DH.ACTOR.allAdversaryTypes();
        const environmentTypes = CONFIG.DH.ACTOR.environmentTypes;
        context.getTypeLabel = document => {
            return document.type === 'adversary'
                ? game.i18n.localize(adversaryTypes[document.system.type]?.label ?? 'TYPES.Actor.adversary')
                : document.type === 'environment'
                  ? game.i18n.localize(environmentTypes[document.system.type]?.label ?? 'TYPES.Actor.environment')
                  : null;
        };
    }
}

class DhSidebar extends foundry.applications.sidebar.Sidebar {
    /** @override */
    static TABS = {
        chat: {
            documentName: 'ChatMessage'
        },
        combat: {
            documentName: 'Combat'
        },
        scenes: {
            documentName: 'Scene',
            gmOnly: true
        },
        actors: {
            documentName: 'Actor'
        },
        items: {
            documentName: 'Item'
        },
        journal: {
            documentName: 'JournalEntry',
            tooltip: 'SIDEBAR.TabJournal'
        },
        tables: {
            documentName: 'RollTable'
        },
        cards: {
            documentName: 'Cards'
        },
        macros: {
            documentName: 'Macro'
        },
        playlists: {
            documentName: 'Playlist'
        },
        compendium: {
            tooltip: 'SIDEBAR.TabCompendium',
            icon: 'fa-solid fa-book-atlas'
        },
        daggerheartMenu: {
            tooltip: 'DAGGERHEART.UI.Sidebar.daggerheartMenu.title',
            img: 'systems/daggerheart/assets/logos/FoundryBorneLogoWhite.svg',
            gmOnly: true
        },
        settings: {
            tooltip: 'SIDEBAR.TabSettings',
            icon: 'fa-solid fa-gears'
        }
    };

    /** @override */
    static PARTS = {
        tabs: {
            id: 'tabs',
            template: 'systems/daggerheart/templates/sidebar/tabs.hbs'
        }
    };

    /** @override */
    async _prepareTabContext(context, options) {
        context.tabs = Object.entries(this.constructor.TABS).reduce((obj, [k, v]) => {
            let { documentName, gmOnly, tooltip, icon, img } = v;
            if (gmOnly && !game.user.isGM) return obj;
            if (documentName) {
                tooltip ??= getDocumentClass(documentName).metadata.labelPlural;
                icon ??= CONFIG[documentName]?.sidebarIcon;
            }
            obj[k] = { tooltip, icon, img };
            obj[k].active = this.tabGroups.primary === k;
            return obj;
        }, {});
    }
}

var _module$7 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DaggerheartMenu: DaggerheartMenu,
    DhActorDirectory: DhActorDirectory,
    DhSidebar: DhSidebar
});

let DhCountdowns$1 = class DhCountdowns extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            /* Outdated and unused. Needed for migration. Remove in next minor version. (1.3) */
            narrative: new fields.EmbeddedDataField(DhCountdownData),
            encounter: new fields.EmbeddedDataField(DhCountdownData),
            /**/
            countdowns: new fields.TypedObjectField(new fields.EmbeddedDataField(DhCountdown)),
            defaultOwnership: new fields.NumberField({
                required: true,
                choices: CONFIG.DH.GENERAL.basicOwnershiplevels,
                initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER
            })
        };
    }
};

/* Outdated and unused. Needed for migration. Remove in next minor version. (1.3) */
class DhCountdownData extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            countdowns: new fields.TypedObjectField(new fields.EmbeddedDataField(DhOldCountdown)),
            ownership: new fields.SchemaField({
                default: new fields.NumberField({
                    required: true,
                    choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                    initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE
                }),
                players: new fields.TypedObjectField(
                    new fields.SchemaField({
                        type: new fields.NumberField({
                            required: true,
                            choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                            initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT
                        })
                    })
                )
            }),
            window: new fields.SchemaField({})
        };
    }

    get playerOwnership() {
        return Array.from(game.users).reduce((acc, user) => {
            acc[user.id] = {
                value: user.isGM
                    ? CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER
                    : this.ownership.players[user.id] && this.ownership.players[user.id].type !== -1
                      ? this.ownership.players[user.id].type
                      : this.ownership.default,
                isGM: user.isGM
            };

            return acc;
        }, {});
    }
}

/* Outdated and unused. Needed for migration. Remove in next minor version. (1.3) */
class DhOldCountdown extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            name: new fields.StringField({
                required: true,
                label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.name.label'
            }),
            img: new fields.FilePathField({
                categories: ['IMAGE'],
                base64: false,
                initial: 'icons/magic/time/hourglass-yellow-green.webp'
            }),
            ownership: new fields.SchemaField({
                default: new fields.NumberField({
                    required: true,
                    choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                    initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE
                }),
                players: new fields.TypedObjectField(
                    new fields.SchemaField({
                        type: new fields.NumberField({
                            required: true,
                            choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                            initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT
                        })
                    })
                )
            }),
            progress: new fields.SchemaField({
                current: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 1,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.current.label'
                }),
                max: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 1,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.max.label'
                }),
                type: new fields.SchemaField({
                    value: new fields.StringField({
                        required: true,
                        choices: CONFIG.DH.GENERAL.countdownProgressionTypes,
                        initial: CONFIG.DH.GENERAL.countdownProgressionTypes.custom.id,
                        label: 'DAGGERHEART.GENERAL.type'
                    }),
                    label: new fields.StringField({
                        label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.type.label.label'
                    })
                })
            })
        };
    }

    get playerOwnership() {
        return Array.from(game.users).reduce((acc, user) => {
            acc[user.id] = {
                value: user.isGM
                    ? CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER
                    : this.ownership.players[user.id] && this.ownership.players[user.id].type !== -1
                      ? this.ownership.players[user.id].type
                      : this.ownership.default,
                isGM: user.isGM
            };

            return acc;
        }, {});
    }
}

class DhCountdown extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            type: new fields.StringField({
                required: true,
                choices: CONFIG.DH.GENERAL.countdownBaseTypes,
                label: 'DAGGERHEART.GENERAL.type'
            }),
            name: new fields.StringField({
                required: true,
                label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.name.label'
            }),
            img: new fields.FilePathField({
                categories: ['IMAGE'],
                base64: false,
                initial: 'icons/magic/time/hourglass-yellow-green.webp'
            }),
            ownership: new fields.TypedObjectField(
                new fields.NumberField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.simpleOwnershiplevels,
                    initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT
                })
            ),
            progress: new fields.SchemaField({
                current: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 1,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.current.label'
                }),
                start: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 1,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.start.label',
                    deterministic: false
                }),
                startFormula: new FormulaField({
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.startFormula.label',
                    deterministic: false
                }),
                looping: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.countdownLoopingTypes,
                    initial: CONFIG.DH.GENERAL.countdownLoopingTypes.noLooping.id,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.looping.label'
                }),
                type: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.countdownProgressionTypes,
                    initial: CONFIG.DH.GENERAL.countdownProgressionTypes.custom.id,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.type.label'
                })
            })
        };
    }

    static defaultCountdown(type, playerHidden) {
        const ownership = playerHidden
            ? game.users.reduce((acc, user) => {
                  if (!user.isGM) {
                      acc[user.id] = CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
                  }
                  return acc;
              }, {})
            : undefined;

        return {
            type: type ?? CONFIG.DH.GENERAL.countdownBaseTypes.narrative.id,
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Countdown.newCountdown'),
            img: 'icons/magic/time/hourglass-yellow-green.webp',
            ownership: ownership,
            progress: {
                current: 1,
                start: 1
            }
        };
    }

    get playerOwnership() {
        return Array.from(game.users).reduce((acc, user) => {
            acc[user.id] = {
                value: user.isGM
                    ? CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER
                    : this.ownership.players[user.id] && this.ownership.players[user.id].type !== -1
                      ? this.ownership.players[user.id].type
                      : this.ownership.default,
                isGM: user.isGM
            };

            return acc;
        }, {});
    }

    /** @inheritDoc */
    static migrateData(source) {
        if (source.progress.max) {
            source.progress.start = Number(source.progress.max);
            source.progress.max = null;
            source.progress.startFormula = null;
        }

        return super.migrateData(source);
    }
}

var countdowns = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhCountdown: DhCountdown,
    default: DhCountdowns$1
});

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$3, ApplicationV2: ApplicationV2$3 } = foundry.applications.api;

class CountdownEdit extends HandlebarsApplicationMixin$3(ApplicationV2$3) {
    constructor() {
        super();

        this.data = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        this.editingCountdowns = new Set();
        this.currentEditCountdown = null;
        this.hideNewCountdowns = false;
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dialog', 'dh-style', 'countdown-edit'],
        tag: 'form',
        position: { width: 600 },
        window: {
            title: 'DAGGERHEART.APPLICATIONS.CountdownEdit.title',
            icon: 'fa-solid fa-clock-rotate-left'
        },
        actions: {
            addCountdown: CountdownEdit.#addCountdown,
            toggleCountdownEdit: CountdownEdit.#toggleCountdownEdit,
            editCountdownImage: CountdownEdit.#editCountdownImage,
            editCountdownOwnership: CountdownEdit.#editCountdownOwnership,
            randomiseCountdownStart: CountdownEdit.#randomiseCountdownStart,
            removeCountdown: CountdownEdit.#removeCountdown
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        countdowns: {
            template: 'systems/daggerheart/templates/ui/countdown-edit.hbs',
            scrollable: ['.expanded-view', '.edit-content']
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.isGM = game.user.isGM;
        context.ownershipDefaultOptions = CONFIG.DH.GENERAL.basicOwnershiplevels;
        context.defaultOwnership = this.data.defaultOwnership;
        context.countdownBaseTypes = CONFIG.DH.GENERAL.countdownBaseTypes;
        context.countdownProgressionTypes = CONFIG.DH.GENERAL.countdownProgressionTypes;
        context.countdownLoopingTypes = CONFIG.DH.GENERAL.countdownLoopingTypes;
        context.hideNewCountdowns = this.hideNewCountdowns;
        context.countdowns = Object.keys(this.data.countdowns).reduce((acc, key) => {
            const countdown = this.data.countdowns[key];
            const isLooping = countdown.progress.looping !== CONFIG.DH.GENERAL.countdownLoopingTypes.noLooping;
            const loopTooltip = isLooping
                ? countdown.progress.looping === CONFIG.DH.GENERAL.countdownLoopingTypes.increasing.id
                    ? 'DAGGERHEART.UI.Countdowns.increasingLoop'
                    : countdown.progress.looping === CONFIG.DH.GENERAL.countdownLoopingTypes.decreasing.id
                      ? 'DAGGERHEART.UI.Countdowns.decreasingLoop'
                      : 'DAGGERHEART.UI.Countdowns.loop'
                : null;
            const randomizeValid = !new Roll(countdown.progress.startFormula ?? '').isDeterministic;
            acc[key] = {
                ...countdown,
                typeName: game.i18n.localize(CONFIG.DH.GENERAL.countdownBaseTypes[countdown.type].label),
                progress: {
                    ...countdown.progress,
                    typeName: game.i18n.localize(
                        CONFIG.DH.GENERAL.countdownProgressionTypes[countdown.progress.type].label
                    )
                },
                editing: this.editingCountdowns.has(key),
                randomizeValid,
                loopTooltip
            };

            return acc;
        }, {});

        return context;
    }

    /** @override */
    async _postRender(_context, _options) {
        if (this.currentEditCountdown) {
            setTimeout(() => {
                const input = this.element.querySelector(
                    `.countdown-edit-container[data-id="${this.currentEditCountdown}"] input`
                );
                if (input) {
                    input.select();
                    this.currentEditCountdown = null;
                }
            }, 100);
        }
    }

    canPerformEdit() {
        if (game.user.isGM) return true;

        if (!game.users.activeGM) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.gmRequired'));
            return false;
        }

        return true;
    }

    async updateSetting(update) {
        const noGM = !game.users.find(x => x.isGM && x.active);
        if (noGM) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.gmRequired'));
            return;
        }

        await this.data.updateSource(update);
        await emitAsGM(GMUpdateEvent.UpdateCountdowns, this.gmSetSetting.bind(this.data), this.data, null, {
            refreshType: RefreshType.Countdown
        });

        this.render();
    }

    static async updateData(_event, _, formData) {
        const { hideNewCountdowns, ...settingsData } = foundry.utils.expandObject(formData.object);

        // Sync current and max if max is changing and they were equal before
        for (const [id, countdown] of Object.entries(settingsData.countdowns ?? {})) {
            const existing = this.data.countdowns[id];
            countdown.progress.current = this.getMatchingCurrentValue(
                existing,
                countdown.progress.start,
                countdown.progress.current
            );
        }

        this.hideNewCountdowns = hideNewCountdowns;
        this.updateSetting(settingsData);
    }

    getMatchingCurrentValue(oldCount, newStart, newCurrent) {
        const wasEqual = oldCount && oldCount.progress.current === oldCount.progress.start;
        if (wasEqual && newStart !== oldCount.progress.start) {
            return newStart;
        } else {
            return Math.min(newCurrent, newStart);
        }
    }

    async gmSetSetting(data) {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, data),
            game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.Refresh,
                data: { refreshType: RefreshType.Countdown }
            });
        Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.Countdown });
    }

    static #addCountdown() {
        const id = foundry.utils.randomID();
        this.editingCountdowns.add(id);
        this.currentEditCountdown = id;
        this.updateSetting({
            [`countdowns.${id}`]: DhCountdown.defaultCountdown(null, this.hideNewCountdowns)
        });
    }

    static #editCountdownImage(_, target) {
        const countdown = this.data.countdowns[target.id];
        const fp = new foundry.applications.apps.FilePicker.implementation({
            current: countdown.img,
            type: 'image',
            callback: async path => this.updateSetting({ [`countdowns.${target.id}.img`]: path }),
            top: this.position.top + 40,
            left: this.position.left + 10
        });
        return fp.browse();
    }

    static #toggleCountdownEdit(_, button) {
        const { countdownId } = button.dataset;

        const isEditing = this.editingCountdowns.has(countdownId);
        if (isEditing) this.editingCountdowns.delete(countdownId);
        else {
            this.editingCountdowns.add(countdownId);
            this.currentEditCountdown = countdownId;
        }

        this.render();
    }

    static async #editCountdownOwnership(_, button) {
        const countdown = this.data.countdowns[button.dataset.countdownId];
        const data = await game.system.api.applications.dialogs.OwnershipSelection.configure(
            countdown.name,
            countdown.ownership,
            this.data.defaultOwnership
        );
        if (!data) return;

        this.updateSetting({ [`countdowns.${button.dataset.countdownId}`]: data });
    }

    static async #randomiseCountdownStart(_, button) {
        const countdown = this.data.countdowns[button.dataset.countdownId];
        const roll = await new Roll(countdown.progress.startFormula).roll();
        const message = await roll.toMessage({ title: 'Countdown' });

        await waitForDiceSoNice(message);
        await this.updateSetting({
            [`countdowns.${button.dataset.countdownId}.progress`]: {
                start: roll.total,
                current: this.getMatchingCurrentValue(countdown, roll.total, countdown.progress.current)
            }
        });
        this.render();
    }

    static async #removeCountdown(event, button) {
        const { countdownId } = button.dataset;

        if (!event.shiftKey) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.APPLICATIONS.CountdownEdit.removeCountdownTitle')
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.CountdownEdit.removeCountdownText', {
                    name: this.data.countdowns[countdownId].name
                })
            });
            if (!confirmed) return;
        }

        if (this.editingCountdowns.has(countdownId)) this.editingCountdowns.delete(countdownId);
        this.updateSetting({ [`countdowns.-=${countdownId}`]: null });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$2, ApplicationV2: ApplicationV2$2 } = foundry.applications.api;

/**
 * A UI element which displays the countdowns in this world.
 *
 * @extends ApplicationV2
 * @mixes HandlebarsApplication
 */

class DhCountdowns extends HandlebarsApplicationMixin$2(ApplicationV2$2) {
    constructor(options = {}) {
        super(options);

        this.setupHooks();
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        id: 'countdowns',
        tag: 'div',
        classes: ['daggerheart', 'dh-style', 'countdowns', 'faded-ui'],
        window: {
            icon: 'fa-solid fa-clock-rotate-left',
            frame: true,
            title: 'DAGGERHEART.UI.Countdowns.title',
            positioned: false,
            resizable: false,
            minimizable: false
        },
        actions: {
            toggleViewMode: DhCountdowns.#toggleViewMode,
            editCountdowns: DhCountdowns.#editCountdowns,
            loopCountdown: DhCountdowns.#loopCountdown,
            decreaseCountdown: (_, target) => this.editCountdown(false, target),
            increaseCountdown: (_, target) => this.editCountdown(true, target)
        },
        position: {
            width: 400,
            height: 222,
            top: 50
        }
    };

    /** @override */
    static PARTS = {
        resources: {
            root: true,
            template: 'systems/daggerheart/templates/ui/countdowns.hbs'
        }
    };

    get element() {
        return document.body.querySelector('.daggerheart.dh-style.countdowns');
    }

    /**@inheritdoc */
    async _renderFrame(options) {
        const frame = await super._renderFrame(options);

        const iconOnly =
            game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.countdownMode) ===
            CONFIG.DH.GENERAL.countdownAppMode.iconOnly;
        if (iconOnly) frame.classList.add('icon-only');
        else frame.classList.remove('icon-only');

        const header = frame.querySelector('.window-header');
        header.querySelector('button[data-action="close"]').remove();

        if (game.user.isGM) {
            const editTooltip = game.i18n.localize('DAGGERHEART.APPLICATIONS.CountdownEdit.editTitle');
            const editButton = `<a style="margin-right: 8px;" class="header-control" data-tooltip="${editTooltip}" aria-label="${editTooltip}" data-action="editCountdowns"><i class="fa-solid fa-wrench"></i></a>`;
            header.insertAdjacentHTML('beforeEnd', editButton);
        }

        const minimizeTooltip = game.i18n.localize('DAGGERHEART.UI.Countdowns.toggleIconMode');
        const minimizeButton = `<a class="header-control" data-tooltip="${minimizeTooltip}" aria-label="${minimizeTooltip}" data-action="toggleViewMode"><i class="fa-solid fa-down-left-and-up-right-to-center"></i></a>`;
        header.insertAdjacentHTML('beforeEnd', minimizeButton);

        return frame;
    }

    /** Returns countdown data filtered by ownership */
    #getCountdowns() {
        const setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        const values = Object.entries(setting.countdowns).map(([key, countdown]) => ({
            key,
            countdown,
            ownership: DhCountdowns.#getPlayerOwnership(game.user, setting, countdown)
        }));
        return values.filter(v => v.ownership !== CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE);
    }

    /** @override */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.isGM = game.user.isGM;

        context.iconOnly =
            game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.countdownMode) ===
            CONFIG.DH.GENERAL.countdownAppMode.iconOnly;
        const setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        context.countdowns = this.#getCountdowns().reduce((acc, { key, countdown, ownership }) => {
            const playersWithAccess = game.users.reduce((acc, user) => {
                const ownership = DhCountdowns.#getPlayerOwnership(user, setting, countdown);
                if (!user.isGM && ownership && ownership !== CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE) {
                    acc.push(user);
                }
                return acc;
            }, []);
            const nonGmPlayers = game.users.filter(x => !x.isGM);

            const countdownEditable = game.user.isGM || ownership === CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
            const isLooping = countdown.progress.looping !== CONFIG.DH.GENERAL.countdownLoopingTypes.noLooping;
            const loopTooltip = isLooping
                ? countdown.progress.looping === CONFIG.DH.GENERAL.countdownLoopingTypes.increasing.id
                    ? 'DAGGERHEART.UI.Countdowns.increasingLoop'
                    : countdown.progress.looping === CONFIG.DH.GENERAL.countdownLoopingTypes.decreasing.id
                      ? 'DAGGERHEART.UI.Countdowns.decreasingLoop'
                      : 'DAGGERHEART.UI.Countdowns.loop'
                : null;
            const loopDisabled =
                !countdownEditable ||
                (isLooping && (countdown.progress.current > 0 || countdown.progress.start === '0'));

            acc[key] = {
                ...countdown,
                editable: countdownEditable,
                noPlayerAccess: nonGmPlayers.length && playersWithAccess.length === 0,
                shouldLoop: isLooping && countdown.progress.current === 0 && countdown.progress.start > 0,
                loopDisabled: isLooping ? loopDisabled : null,
                loopTooltip: isLooping && game.i18n.localize(loopTooltip)
            };
            return acc;
        }, {});

        return context;
    }

    static #getPlayerOwnership(user, setting, countdown) {
        const playerOwnership = countdown.ownership[user.id];
        return playerOwnership === undefined || playerOwnership === CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT
            ? setting.defaultOwnership
            : playerOwnership;
    }

    cooldownRefresh = ({ refreshType }) => {
        if (refreshType === RefreshType.Countdown) this.render();
    };

    static canPerformEdit() {
        if (game.user.isGM) return true;

        const noGM = !game.users.find(x => x.isGM && x.active);
        if (noGM) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.gmRequired'));
            return false;
        }

        return true;
    }

    static async #toggleViewMode() {
        const currentMode = game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.countdownMode);
        const appMode = CONFIG.DH.GENERAL.countdownAppMode;
        const newMode = currentMode === appMode.textIcon ? appMode.iconOnly : appMode.textIcon;
        await game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.countdownMode, newMode);

        if (newMode === appMode.iconOnly) this.element.classList.add('icon-only');
        else this.element.classList.remove('icon-only');
        this.render();
    }

    static async #editCountdowns() {
        new game.system.api.applications.ui.CountdownEdit().render(true);
    }

    static async #loopCountdown(_, target) {
        if (!DhCountdowns.canPerformEdit()) return;

        const settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        const countdown = settings.countdowns[target.id];

        let progressMax = countdown.progress.start;
        let message = null;
        if (countdown.progress.startFormula) {
            const roll = await new Roll(countdown.progress.startFormula).evaluate();
            progressMax = roll.total;
            message = await roll.toMessage();
        }

        const newMax =
            countdown.progress.looping === CONFIG.DH.GENERAL.countdownLoopingTypes.increasing.id
                ? Number(progressMax) + 1
                : countdown.progress.looping === CONFIG.DH.GENERAL.countdownLoopingTypes.decreasing.id
                  ? Math.max(Number(progressMax) - 1, 0)
                  : progressMax;

        await waitForDiceSoNice(message);
        await settings.updateSource({
            [`countdowns.${target.id}.progress`]: {
                current: newMax,
                start: newMax
            }
        });
        await emitAsGM(GMUpdateEvent.UpdateCountdowns, DhCountdowns.gmSetSetting.bind(settings), settings, null, {
            refreshType: RefreshType.Countdown
        });
    }

    static async editCountdown(increase, target) {
        if (!DhCountdowns.canPerformEdit()) return;

        const settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        const countdown = settings.countdowns[target.id];
        const newCurrent = increase
            ? Math.min(countdown.progress.current + 1, countdown.progress.start)
            : Math.max(countdown.progress.current - 1, 0);
        await settings.updateSource({ [`countdowns.${target.id}.progress.current`]: newCurrent });
        await emitAsGM(GMUpdateEvent.UpdateCountdowns, DhCountdowns.gmSetSetting.bind(settings), settings, null, {
            refreshType: RefreshType.Countdown
        });
    }

    static async gmSetSetting(data) {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, data),
            game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.Refresh,
                data: { refreshType: RefreshType.Countdown }
            });
        Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.Countdown });
    }

    setupHooks() {
        Hooks.on(socketEvent.Refresh, this.cooldownRefresh.bind());
    }

    async close(options) {
        /* Opt out of Foundry's standard behavior of closing all application windows marked as UI when Escape is pressed */
        if (options.closeKey) return;

        Hooks.off(socketEvent.Refresh, this.cooldownRefresh);
        return super.close(options);
    }

    static async updateCountdowns(progressType) {
        const { countdownAutomation } = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation);
        if (!countdownAutomation) return;

        const countdownSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        const updatedCountdowns = Object.keys(countdownSetting.countdowns).reduce((acc, key) => {
            const countdown = countdownSetting.countdowns[key];
            if (countdown.progress.type === progressType && countdown.progress.current > 0) {
                acc.push(key);
            }

            return acc;
        }, []);

        const countdownData = countdownSetting.toObject();
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, {
            ...countdownData,
            countdowns: Object.keys(countdownData.countdowns).reduce((acc, key) => {
                const countdown = foundry.utils.deepClone(countdownData.countdowns[key]);
                if (updatedCountdowns.includes(key)) {
                    countdown.progress.current -= 1;
                }

                acc[key] = countdown;
                return acc;
            }, {})
        });

        const data = { refreshType: RefreshType.Countdown };
        await game.socket.emit(`system.${CONFIG.DH.id}`, {
            action: socketEvent.Refresh,
            data
        });
        Hooks.callAll(socketEvent.Refresh, data);
    }

    async _onRender(context, options) {
        await super._onRender(context, options);
        this.element.hidden = !game.user.isGM && this.#getCountdowns().length === 0;
        if (options?.force) {
            document.getElementById('ui-right-column-1')?.appendChild(this.element);
        }
    }
}

class DhpChatLog extends foundry.applications.sidebar.tabs.ChatLog {
    constructor(options) {
        super(options);

        this.targetTemplate = {
            activeLayer: undefined,
            document: undefined,
            object: undefined,
            minimizedSheets: [],
            config: undefined,
            targets: undefined
        };
        this.setupHooks();
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['daggerheart']
    };

    _getEntryContextOptions() {
        return [
            ...super._getEntryContextOptions(),
            // {
            //     name: 'Reroll',
            //     icon: '<i class="fa-solid fa-dice"></i>',
            //     condition: li => {
            //         const message = game.messages.get(li.dataset.messageId);

            //         return (game.user.isGM || message.isAuthor) && message.rolls.length > 0;
            //     },
            //     callback: li => {
            //         const message = game.messages.get(li.dataset.messageId);
            //         new game.system.api.applications.dialogs.RerollDialog(message).render({ force: true });
            //     }
            // },
            {
                name: game.i18n.localize('DAGGERHEART.UI.ChatLog.rerollDamage'),
                icon: '<i class="fa-solid fa-dice"></i>',
                condition: li => {
                    const message = game.messages.get(li.dataset.messageId);
                    const hasRolledDamage = message.system.hasDamage
                        ? Object.keys(message.system.damage).length > 0
                        : false;
                    return (game.user.isGM || message.isAuthor) && hasRolledDamage;
                },
                callback: li => {
                    const message = game.messages.get(li.dataset.messageId);
                    new game.system.api.applications.dialogs.RerollDamageDialog(message).render({ force: true });
                }
            }
        ];
    }

    addChatListeners = async (app, html, data) => {
        html.querySelectorAll('.simple-roll-button').forEach(element =>
            element.addEventListener('click', event => this.onRollSimple(event, data.message))
        );
        html.querySelectorAll('.ability-use-button').forEach(element =>
            element.addEventListener('click', event => this.abilityUseButton(event, data.message))
        );
        html.querySelectorAll('.action-use-button').forEach(element =>
            element.addEventListener('click', event => this.actionUseButton(event, data.message))
        );
        html.querySelectorAll('.reroll-button').forEach(element =>
            element.addEventListener('click', event => this.rerollEvent(event, data.message))
        );
        html.querySelectorAll('.group-roll-button').forEach(element =>
            element.addEventListener('click', event => this.groupRollButton(event, data.message))
        );
        html.querySelectorAll('.group-roll-reroll').forEach(element =>
            element.addEventListener('click', event => this.groupRollReroll(event, data.message))
        );
        html.querySelectorAll('.group-roll-success').forEach(element =>
            element.addEventListener('click', event => this.groupRollSuccessEvent(event, data.message))
        );
        html.querySelectorAll('.group-roll-header-expand-section').forEach(element =>
            element.addEventListener('click', this.groupRollExpandSection)
        );
    };

    setupHooks() {
        Hooks.on('renderChatMessageHTML', this.addChatListeners.bind());
    }

    close(options) {
        Hooks.off('renderChatMessageHTML', this.addChatListeners);
        super.close(options);
    }

    async onRollSimple(event, message) {
        const buttonType = event.target.dataset.type ?? 'damage',
            total = message.rolls.reduce((a, c) => a + Roll.fromJSON(c).total, 0),
            damages = {
                hitPoints: {
                    parts: [
                        {
                            applyTo: 'hitPoints',
                            damageTypes: [],
                            total
                        }
                    ]
                }
            },
            targets = Array.from(game.user.targets);

        if (targets.length === 0)
            return ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noTargetsSelected'));

        targets.forEach(target => {
            if (buttonType === 'healing') target.actor.takeHealing(damages);
            else target.actor.takeDamage(damages);
        });
    }

    async abilityUseButton(event, message) {
        event.stopPropagation();

        const item = await foundry.utils.fromUuid(message.system.origin);
        const action =
            item.system.attack?.id === event.currentTarget.id
                ? item.system.attack
                : item.system.actions.get(event.currentTarget.id);
        if (event.currentTarget.dataset.directDamage) {
            const config = action.prepareConfig(event);
            config.hasRoll = false;
            action.workflow.get('damage').execute(config, null, true);
        } else action.use(event);
    }

    async actionUseButton(event, message) {
        const { moveIndex, actionIndex, movePath } = event.currentTarget.dataset;
        const parent = await foundry.utils.fromUuid(message.system.actor);
        const actionType = message.system.moves[moveIndex].actions[actionIndex];
        const cls = game.system.api.models.actions.actionsTypes[actionType.type];
        const action = new cls(
            {
                ...actionType,
                _id: foundry.utils.randomID(),
                name: game.i18n.localize(actionType.name),
                originItem: {
                    type: CONFIG.DH.ITEM.originItemType.restMove,
                    itemPath: movePath,
                    actionIndex: actionIndex
                }
            },
            { parent: parent.system }
        );

        action.use(event);
    }

    async rerollEvent(event, message) {
        event.stopPropagation();
        if (!event.shiftKey) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.UI.Chat.reroll.confirmTitle')
                },
                content: game.i18n.localize('DAGGERHEART.UI.Chat.reroll.confirmText')
            });
            if (!confirmed) return;
        }

        const target = event.target.closest('[data-die-index]');

        if (target.dataset.type === 'damage') {
            game.system.api.dice.DamageRoll.reroll(target, message);
        } else {
            let originalRoll_parsed = message.rolls.map(roll => JSON.parse(roll))[0];
            const rollClass =
                game.system.api.dice[
                    message.type === 'dualityRoll'
                        ? 'DualityRoll'
                        : target.dataset.type === 'damage'
                          ? 'DHRoll'
                          : 'D20Roll'
                ];

            if (!game.modules.get('dice-so-nice')?.active) foundry.audio.AudioHelper.play({ src: CONFIG.sounds.dice });

            const { newRoll, parsedRoll } = await rollClass.reroll(originalRoll_parsed, target, message);

            await game.messages.get(message._id).update({
                'system.roll': newRoll,
                'rolls': [parsedRoll]
            });

            Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.TagTeamRoll });
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.Refresh,
                data: {
                    refreshType: RefreshType.TagTeamRoll
                }
            });
        }
    }

    async groupRollButton(event, message) {
        const path = event.currentTarget.dataset.path;
        const isLeader = path === 'leader';
        const { actor: actorData, trait } = foundry.utils.getProperty(message.system, path);
        const actor = game.actors.get(actorData._id);

        if (!actor) {
            return ui.notifications.error(
                game.i18n.format('DAGGERHEART.UI.Notifications.documentIsMissing', {
                    documentType: game.i18n.localize('TYPES.Actor.character')
                })
            );
        }

        if (!actor.testUserPermission(game.user, 'OWNER')) {
            return ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.noActorOwnership'));
        }

        const traitLabel = game.i18n.localize(abilities[trait].label);
        const config = {
            event: event,
            title: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${actor.name}`,
            headerTitle: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: traitLabel
            }),
            roll: {
                trait: trait,
                advantage: 0,
                modifiers: [{ label: traitLabel, value: actor.system.traits[trait].value }]
            },
            hasRoll: true,
            skips: {
                createMessage: true,
                resources: !isLeader,
                updateCountdowns: !isLeader
            }
        };
        const result = await actor.diceRoll({
            ...config,
            headerTitle: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${actor.name}`,
            title: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: traitLabel
            })
        });

        if (!result) return;
        await game.system.api.fields.ActionFields.CostField.execute.call({ actor }, result);

        const newMessageData = foundry.utils.deepClone(message.system);
        foundry.utils.setProperty(newMessageData, `${path}.result`, result.roll);
        const renderData = { system: new game.system.api.models.chatMessages.config.groupRoll(newMessageData) };

        const updatedContent = await foundry.applications.handlebars.renderTemplate(
            'systems/daggerheart/templates/ui/chat/groupRoll.hbs',
            { ...renderData, user: game.user }
        );
        const mess = game.messages.get(message._id);

        await emitAsGM(
            GMUpdateEvent.UpdateDocument,
            mess.update.bind(mess),
            {
                ...renderData,
                content: updatedContent
            },
            mess.uuid
        );
    }

    async groupRollReroll(event, message) {
        const path = event.currentTarget.dataset.path;
        const { actor: actorData, trait } = foundry.utils.getProperty(message.system, path);
        const actor = game.actors.get(actorData._id);

        if (!actor.testUserPermission(game.user, 'OWNER')) {
            return ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.noActorOwnership'));
        }

        const traitLabel = game.i18n.localize(abilities[trait].label);

        const config = {
            event: event,
            title: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${actor.name}`,
            headerTitle: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: traitLabel
            }),
            roll: {
                trait: trait,
                advantage: 0,
                modifiers: [{ label: traitLabel, value: actor.system.traits[trait].value }]
            },
            hasRoll: true,
            skips: {
                createMessage: true,
                updateCountdowns: true
            }
        };
        const result = await actor.diceRoll({
            ...config,
            headerTitle: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${actor.name}`,
            title: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: traitLabel
            })
        });

        const newMessageData = foundry.utils.deepClone(message.system);
        foundry.utils.setProperty(newMessageData, `${path}.result`, { ...result.roll, rerolled: true });
        const renderData = { system: new game.system.api.models.chatMessages.config.groupRoll(newMessageData) };

        const updatedContent = await foundry.applications.handlebars.renderTemplate(
            'systems/daggerheart/templates/ui/chat/groupRoll.hbs',
            { ...renderData, user: game.user }
        );
        const mess = game.messages.get(message._id);
        await emitAsGM(
            GMUpdateEvent.UpdateDocument,
            mess.update.bind(mess),
            {
                ...renderData,
                content: updatedContent
            },
            mess.uuid
        );
    }

    async groupRollSuccessEvent(event, message) {
        if (!game.user.isGM) {
            return ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.gmOnly'));
        }

        const { path, success } = event.currentTarget.dataset;
        const { actor: actorData } = foundry.utils.getProperty(message.system, path);
        const actor = game.actors.get(actorData._id);

        if (!actor.testUserPermission(game.user, 'OWNER')) {
            return ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.noActorOwnership'));
        }

        const newMessageData = foundry.utils.deepClone(message.system);
        foundry.utils.setProperty(newMessageData, `${path}.manualSuccess`, Boolean(success));
        const renderData = { system: new game.system.api.models.chatMessages.config.groupRoll(newMessageData) };

        const updatedContent = await foundry.applications.handlebars.renderTemplate(
            'systems/daggerheart/templates/ui/chat/groupRoll.hbs',
            { ...renderData, user: game.user }
        );
        const mess = game.messages.get(message._id);
        await emitAsGM(
            GMUpdateEvent.UpdateDocument,
            mess.update.bind(mess),
            {
                ...renderData,
                content: updatedContent
            },
            mess.uuid
        );
    }

    async groupRollExpandSection(event) {
        event.target
            .closest('.group-roll-header-expand-section')
            .querySelectorAll('i')
            .forEach(element => {
                element.classList.toggle('fa-angle-up');
                element.classList.toggle('fa-angle-down');
            });
        event.target.closest('.group-roll-section').querySelector('.group-roll-content').classList.toggle('closed');
    }
}

class DhCombatTracker extends foundry.applications.sidebar.tabs.CombatTracker {
    static DEFAULT_OPTIONS = {
        actions: {
            requestSpotlight: this.requestSpotlight,
            toggleSpotlight: this.toggleSpotlight,
            setActionTokens: this.setActionTokens,
            openCountdowns: this.openCountdowns
        }
    };

    static PARTS = {
        header: {
            template: 'systems/daggerheart/templates/ui/combatTracker/combatTrackerHeader.hbs'
        },
        tracker: {
            template: 'systems/daggerheart/templates/ui/combatTracker/combatTracker.hbs'
        },
        footer: {
            template: 'systems/daggerheart/templates/ui/combatTracker/combatTrackerFooter.hbs'
        }
    };

    /** @inheritDoc */
    async _preparePartContext(_partId, context, _options) {
        return context;
    }

    async _prepareContext(options) {
        const context = await super._prepareContext(options);

        await this._prepareTrackerContext(context, options);
        await this._prepareCombatContext(context, options);

        return context;
    }

    async _prepareCombatContext(context, options) {
        await super._prepareCombatContext(context, options);

        const modifierBP =
            this.combats
                .find(x => x.active)
                ?.system?.extendedBattleToggles?.reduce((acc, toggle) => acc + toggle.category, 0) ?? 0;
        const maxBP = CONFIG.DH.ENCOUNTER.BaseBPPerEncounter(context.characters.length) + modifierBP;
        const currentBP = AdversaryBPPerEncounter(context.adversaries, context.characters);

        Object.assign(context, {
            fear: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear),
            battlepoints: { max: maxBP, current: currentBP, hasModifierBP: Boolean(modifierBP) }
        });
    }

    async _prepareTrackerContext(context, options) {
        await super._prepareTrackerContext(context, options);

        const adversaries = context.turns?.filter(x => x.isNPC) ?? [];
        const characters = context.turns?.filter(x => !x.isNPC) ?? [];

        const spotlightRequests = characters
            ?.filter(x => !x.isNPC)
            .filter(x => x.system.spotlight.requestOrderIndex > 0)
            .sort((a, b) => {
                const valueA = a.system.spotlight.requestOrderIndex;
                const valueB = b.system.spotlight.requestOrderIndex;

                return valueA - valueB;
            });

        Object.assign(context, {
            actionTokens: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).actionTokens,
            adversaries,
            characters: characters?.filter(x => !x.isNPC).filter(x => x.system.spotlight.requestOrderIndex == 0),
            spotlightRequests
        });
    }

    _getCombatContextOptions() {
        return [
            {
                name: 'COMBAT.ClearMovementHistories',
                icon: '<i class="fa-solid fa-shoe-prints"></i>',
                condition: () => game.user.isGM && this.viewed?.combatants.size > 0,
                callback: () => this.viewed.clearMovementHistories()
            },
            {
                name: 'COMBAT.Delete',
                icon: '<i class="fa-solid fa-trash"></i>',
                condition: () => game.user.isGM && !!this.viewed,
                callback: () => this.viewed.endCombat()
            }
        ];
    }

    getDefeatedId(combatant) {
        if (!combatant.actor) return CONFIG.specialStatusEffects.DEFEATED;

        const settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).defeated;
        return settings[`${combatant.actor.type}Default`];
    }

    /** @inheritdoc */
    async _onToggleDefeatedStatus(combatant) {
        const isDefeated = !combatant.isDefeated;
        await combatant.update({ defeated: isDefeated });
        await combatant.actor?.toggleStatusEffect(this.getDefeatedId(combatant), { overlay: true, active: isDefeated });
    }

    /** @inheritdoc */
    async _prepareTurnContext(combat, combatant, index) {
        const { id, name, isOwner, isDefeated, hidden, initiative, permission } = combatant;
        const resource = permission >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER ? combatant.resource : null;
        const hasDecimals = Number.isFinite(initiative) && !Number.isInteger(initiative);
        const turn = {
            hasDecimals,
            hidden,
            id,
            isDefeated,
            initiative,
            isOwner,
            name,
            resource,
            active: index === combat.turn,
            canPing: combatant.sceneId === canvas.scene?.id && game.user.hasPermission('PING_CANVAS'),
            type: combatant.actor.system.type,
            img: await this._getCombatantThumbnail(combatant)
        };

        turn.css = [turn.active ? 'active' : null, hidden ? 'hide' : null, isDefeated ? 'defeated' : null].filterJoin(
            ' '
        );

        const defeatedId = this.getDefeatedId(combatant);
        const effects = [];
        for (const effect of combatant.actor?.temporaryEffects ?? []) {
            if (effect.statuses.has(defeatedId)) turn.isDefeated = true;
            else if (effect.img) effects.push({ img: effect.img, name: effect.name });
        }
        turn.effects = {
            icons: effects,
            tooltip: this._formatEffectsTooltip(effects)
        };

        return { ...turn, isNPC: combatant.isNPC, system: combatant.system.toObject() };
    }

    async setCombatantSpotlight(combatantId) {
        const update = {
            system: {
                'spotlight.requesting': false,
                'spotlight.requestOrderIndex': 0
            }
        };
        const combatant = this.viewed.combatants.get(combatantId);

        const toggleTurn = this.viewed.combatants.contents
            .sort(this.viewed._sortCombatants)
            .map(x => x.id)
            .indexOf(combatantId);

        if (this.viewed.turn !== toggleTurn) {
            const { updateCountdowns } = game.system.api.applications.ui.DhCountdowns;
            await updateCountdowns(CONFIG.DH.GENERAL.countdownProgressionTypes.spotlight.id);
            if (combatant.actor.type === 'character') {
                await updateCountdowns(CONFIG.DH.GENERAL.countdownProgressionTypes.characterSpotlight.id);
            }

            const autoPoints = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).actionPoints;
            if (autoPoints) {
                update.system.actionTokens = Math.max(combatant.system.actionTokens - 1, 0);
            }
        }

        await this.viewed.update({
            turn: this.viewed.turn === toggleTurn ? null : toggleTurn,
            round: this.viewed.round + 1
        });
        await combatant.update(update);
    }

    static async requestSpotlight(_, target) {
        const characters = this.viewed.turns?.filter(x => !x.isNPC) ?? [];
        const orderValues = characters.map(character => character.system.spotlight.requestOrderIndex);
        const maxRequestIndex = Math.max(...orderValues);
        const { combatantId } = target.closest('[data-combatant-id]')?.dataset ?? {};
        const combatant = this.viewed.combatants.get(combatantId);
        await combatant.update({
            'system.spotlight': {
                requesting: !combatant.system.spotlight.requesting,
                requestOrderIndex: !combatant.system.spotlight.requesting ? maxRequestIndex + 1 : 0
            }
        });

        this.render();
    }

    static async toggleSpotlight(_, target) {
        const { combatantId } = target.closest('[data-combatant-id]')?.dataset ?? {};
        await this.setCombatantSpotlight(combatantId);
    }

    static async setActionTokens(_, target) {
        const { combatantId, tokenIndex } = target.closest('[data-combatant-id]')?.dataset ?? {};

        const combatant = this.viewed.combatants.get(combatantId);
        const changeIndex = Number(tokenIndex);
        const newIndex = combatant.system.actionTokens > changeIndex ? changeIndex : changeIndex + 1;

        await combatant.update({ 'system.actionTokens': newIndex });
        this.render();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$1, ApplicationV2: ApplicationV2$1 } = foundry.applications.api;

/**
 * A UI element which displays the Active Effects on a selected token.
 *
 * @extends ApplicationV2
 * @mixes HandlebarsApplication
 */

class DhEffectsDisplay extends HandlebarsApplicationMixin$1(ApplicationV2$1) {
    constructor(options = {}) {
        super(options);

        this.setupHooks();
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        id: 'effects-display',
        tag: 'div',
        classes: ['daggerheart', 'dh-style', 'effects-display'],
        window: {
            frame: false,
            positioned: false,
            resizable: false,
            minimizable: false
        },
        actions: {}
    };

    /** @override */
    static PARTS = {
        resources: {
            root: true,
            template: 'systems/daggerheart/templates/ui/effects-display.hbs'
        }
    };

    get element() {
        return document.body.querySelector('.daggerheart.dh-style.effects-display');
    }

    get hidden() {
        return this.element.classList.contains('hidden');
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        if (this.element) {
            this.element.querySelectorAll('.effect-container a').forEach(element => {
                element.addEventListener('contextmenu', this.removeEffect.bind(this));
            });
        }
    }

    /** @override */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.effects = DhEffectsDisplay.getTokenEffects();

        return context;
    }

    static getTokenEffects = token => {
        const actor = token
            ? token.actor
            : canvas.tokens.controlled.length === 0
              ? !game.user.isGM
                  ? game.user.character
                  : null
              : canvas.tokens.controlled[0].actor;
        return actor?.getActiveEffects() ?? [];
    };

    toggleHidden(token, focused) {
        const effects = DhEffectsDisplay.getTokenEffects(focused ? token : null);
        this.element.hidden = effects.length === 0;

        Hooks.callAll(CONFIG.DH.HOOKS.effectDisplayToggle, this.element.hidden, token);

        this.render();
    }

    async removeEffect(event) {
        const element = event.target.closest('.effect-container');
        const effects = DhEffectsDisplay.getTokenEffects();
        const effect = effects.find(x => x.id === element.id);
        await effect.delete();
        this.render();
    }

    setupHooks() {
        Hooks.on('controlToken', this.toggleHidden.bind(this));
        Hooks.on(RefreshType.EffectsDisplay, this.toggleHidden.bind(this));
    }

    async close(options) {
        /* Opt out of Foundry's standard behavior of closing all application windows marked as UI when Escape is pressed */
        if (options.closeKey) return;

        Hooks.off('controlToken', this.toggleHidden);
        Hooks.off(RefreshType.EffectsDisplay, this.toggleHidden);
        return super.close(options);
    }

    async _onRender(context, options) {
        await super._onRender(context, options);

        this.element.hidden = context.effects.length === 0;
        if (options?.force) {
            document.getElementById('ui-right-column-1')?.appendChild(this.element);
        }
    }
}

const { HandlebarsApplicationMixin, ApplicationV2 } = foundry.applications.api;

/**
 * A UI element which displays the Users defined for this world.
 * Currently active users are always displayed, while inactive users can be displayed on toggle.
 *
 * @extends ApplicationV2
 * @mixes HandlebarsApplication
 */

class FearTracker extends HandlebarsApplicationMixin(ApplicationV2) {
    constructor(options = {}) {
        super(options);
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        id: 'resources',
        classes: [],
        tag: 'div',
        window: {
            frame: true,
            title: 'Fear',
            positioned: true,
            resizable: true,
            minimizable: false
        },
        actions: {
            setFear: FearTracker.setFear,
            increaseFear: FearTracker.increaseFear
        },
        position: {
            width: 222,
            height: 222
            // top: "200px",
            // left: "120px"
        }
    };

    /** @override */
    static PARTS = {
        resources: {
            root: true,
            template: 'systems/daggerheart/templates/ui/fearTracker.hbs'
        }
    };

    get currentFear() {
        return game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear);
    }

    get maxFear() {
        return game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear;
    }

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    /** @override */
    async _prepareContext(_options) {
        const display = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance).displayFear,
            current = this.currentFear,
            max = this.maxFear,
            percent = (current / max) * 100,
            isGM = game.user.isGM;
        // Return the data for rendering
        return { display, current, max, percent, isGM };
    }

    /** @override */
    async _preFirstRender(context, options) {
        options.position =
            game.user.getFlag(CONFIG.DH.id, 'app.resources.position') ?? FearTracker.DEFAULT_OPTIONS.position;
    }

    /** @override */
    async _preRender(context, options) {
        if (this.currentFear > this.maxFear && game.user.isGM)
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear, this.maxFear);
    }

    _onPosition(position) {
        game.user.setFlag(CONFIG.DH.id, 'app.resources.position', position);
    }

    async close(options = {}) {
        if (!options.allowed) return;
        else super.close(options);
    }

    static async setFear(event, target) {
        if (!game.user.isGM) return;
        const fearCount = Number(target.dataset.index ?? 0);
        await this.updateFear(this.currentFear === fearCount + 1 ? fearCount : fearCount + 1);
    }

    static async increaseFear(event, target) {
        if (!game.user.isGM) return;
        let value = target.dataset.increment ?? 0,
            operator = value.split('')[0] ?? null;
        value = Number(value);
        await this.updateFear(operator ? this.currentFear + value : value);
    }

    async updateFear(value) {
        return emitAsGM(
            GMUpdateEvent.UpdateFear,
            game.settings.set.bind(game.settings, CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear),
            value
        );
    }
}

class DhHotbar extends foundry.applications.ui.Hotbar {
    constructor(options) {
        super(options);

        this.setupHooks();
    }

    static async useItem(uuid) {
        const item = await fromUuid(uuid);
        if (!item) {
            return ui.notifications.warn('WARNING.ObjectDoesNotExist', {
                format: {
                    name: game.i18n.localize('Document'),
                    identifier: uuid
                }
            });
        }

        await item.use({});
    }

    static async useAction(itemUuid, actionId) {
        const item = await foundry.utils.fromUuid(itemUuid);
        if (!item) {
            return ui.notifications.warn('WARNING.ObjectDoesNotExist', {
                format: {
                    name: game.i18n.localize('Document'),
                    identifier: itemUuid
                }
            });
        }

        const action = item.system.actions.get(actionId);
        if (!action) {
            return ui.notifications.warn('DAGGERHEART.UI.Notifications.actionIsMissing');
        }

        await action.use({});
    }

    static async useAttack(actorUuid) {
        const actor = await foundry.utils.fromUuid(actorUuid);
        if (!actor) {
            return ui.notifications.warn('WARNING.ObjectDoesNotExist', {
                format: {
                    name: game.i18n.localize('Document'),
                    identifier: actorUuid
                }
            });
        }

        const attack = actor.system.attack;
        if (!attack) {
            return ui.notifications.warn('DAGGERHEART.UI.Notifications.attackIsMissing');
        }

        await attack.use({});
    }

    setupHooks() {
        Hooks.on('hotbarDrop', (bar, data, slot) => {
            if (data.type === 'Item') {
                const item = foundry.utils.fromUuidSync(data.uuid);
                if (item.uuid.startsWith('Compendium') || !item.isOwned || !item.isOwner) return true;

                switch (item.type) {
                    case 'ancestry':
                    case 'community':
                    case 'class':
                    case 'subclass':
                        return true;
                    default:
                        this.createItemMacro(item, slot);
                        return false;
                }
            } else if (data.type === 'Action') {
                const item = foundry.utils.fromUuidSync(data.data.itemUuid);
                if (item.uuid.startsWith('Compendium')) return true;
                if (!item.isOwned || !item.isOwner) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.unownedActionMacro'));
                    return false;
                }

                this.createActionMacro(data, slot);
                return false;
            } else if (data.type === 'Attack') {
                const actor = foundry.utils.fromUuidSync(data.actorUuid);
                if (actor.uuid.startsWith('Compendium')) return true;
                if (!actor.isOwner) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.unownedAttackMacro'));
                    return false;
                }

                this.createAttackMacro(data, slot);
                return false;
            }
        });
    }

    async createItemMacro(data, slot) {
        const macro = await Macro.implementation.create({
            name: data.name,
            type: CONST.MACRO_TYPES.SCRIPT,
            img: data.img,
            command: `await game.system.api.applications.ui.DhHotbar.useItem("${data.uuid}");`
        });
        await game.user.assignHotbarMacro(macro, slot);
    }

    async createActionMacro(data, slot) {
        const macro = await Macro.implementation.create({
            name: data.data.name,
            type: CONST.MACRO_TYPES.SCRIPT,
            img: data.data.img,
            command: `await game.system.api.applications.ui.DhHotbar.useAction("${data.data.itemUuid}", "${data.data.id}");`
        });
        await game.user.assignHotbarMacro(macro, slot);
    }

    async createAttackMacro(data, slot) {
        const macro = await Macro.implementation.create({
            name: data.name,
            type: CONST.MACRO_TYPES.SCRIPT,
            img: data.img,
            command: `await game.system.api.applications.ui.DhHotbar.useAttack("${data.actorUuid}");`
        });
        await game.user.assignHotbarMacro(macro, slot);
    }
}

var _module$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CountdownEdit: CountdownEdit,
    DhChatLog: DhpChatLog,
    DhCombatTracker: DhCombatTracker,
    DhCountdowns: DhCountdowns,
    DhEffectsDisplay: DhEffectsDisplay,
    DhFearTracker: FearTracker,
    DhHotbar: DhHotbar,
    ItemBrowser: ItemBrowser
});

/**
 * @typedef ContextMenuEntry
 * @property {string} name                              The context menu label. Can be localized.
 * @property {string} [icon]                            A string containing an HTML icon element for the menu item.
 * @property {string} [classes]                         Additional CSS classes to apply to this menu item.
 * @property {string} [group]                           An identifier for a group this entry belongs to.
 * @property {ContextMenuJQueryCallback} callback       The function to call when the menu item is clicked.
 * @property {ContextMenuCondition|boolean} [condition] A function to call or boolean value to determine if this entry
 *                                                      appears in the menu.
 */

/**
 * @callback ContextMenuCondition
 * @param {jQuery|HTMLElement} html                     The element of the context menu entry.
 * @returns {boolean}                                   Whether the entry should be rendered in the context menu.
 */

/**
 * @callback ContextMenuCallback
 * @param {HTMLElement} target                          The element that the context menu has been triggered for.
 * @returns {unknown}
 */

/**
 * @callback ContextMenuJQueryCallback
 * @param {HTMLElement|jQuery} target                   The element that the context menu has been triggered for. Will
 *                                                      either be a jQuery object or an HTMLElement instance, depending
 *                                                      on how the ContextMenu was configured.
 * @returns {unknown}
 */

/**
 * @typedef ContextMenuOptions
 * @property {string} [eventName="contextmenu"] Optionally override the triggering event which can spawn the menu. If
 *                                              the menu is using fixed positioning, this event must be a MouseEvent.
 * @property {ContextMenuCallback} [onOpen]     A function to call when the context menu is opened.
 * @property {ContextMenuCallback} [onClose]    A function to call when the context menu is closed.
 * @property {boolean} [fixed=false]            If true, the context menu is given a fixed position rather than being
 *                                              injected into the target.
 * @property {boolean} [jQuery=true]            If true, callbacks will be passed jQuery objects instead of HTMLElement
 *                                              instances.
 */

/**
 * @typedef ContextMenuRenderOptions
 * @property {Event} [event]           The event that triggered the context menu opening.
 * @property {boolean} [animate=true]  Animate the context menu opening.
 */

/**
 * A subclass of ContextMenu.
 * @extends {foundry.applications.ux.ContextMenu}
 */
class DHContextMenu extends foundry.applications.ux.ContextMenu {
    /**
     * @param {HTMLElement|jQuery} container - The HTML element that contains the context menu targets.
     * @param {string} selector - A CSS selector which activates the context menu.
     * @param {ContextMenuEntry[]} menuItems - An Array of entries to display in the menu
     * @param {ContextMenuOptions} [options] - Additional options to configure the context menu.
     */
    constructor(container, selector, menuItems, options) {
        super(container, selector, menuItems, options);

        /** @deprecated since v13 until v15 */
        this.#jQuery = options.jQuery;
    }

    /**
     * Whether to pass jQuery objects or HTMLElement instances to callback.
     * @type {boolean}
     */
    #jQuery;

    /**@inheritdoc */
    activateListeners(menu) {
        menu.addEventListener('click', this.#onClickItem.bind(this));
    }

    /**
     * Handle click events on context menu items.
     * @param {PointerEvent} event      The click event
     */
    #onClickItem(event) {
        event.preventDefault();
        event.stopPropagation();
        const element = event.target.closest('.context-item');
        if (!element) return;
        const item = this.menuItems.find(i => i.element === element);
        item?.callback(this.#jQuery ? $(this.target) : this.target, event);
        this.close();
    }

    /* -------------------------------------------- */

    /**
     * Trigger a context menu event in response to a normal click on a additional options button.
     * @param {PointerEvent} event
     */
    static triggerContextMenu(event) {
        event.preventDefault();
        event.stopPropagation();
        const { clientX, clientY } = event;
        const selector = '[data-item-uuid]';
        const target = event.target.closest(selector) ?? event.currentTarget.closest(selector);
        target?.dispatchEvent(
            new PointerEvent('contextmenu', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX,
                clientY
            })
        );
    }
}

var _module$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHContextMenu: DHContextMenu,
    FilterMenu: FilterMenu
});

var applications = /*#__PURE__*/Object.freeze({
    __proto__: null,
    characterCreation: _module$i,
    dialogs: _module$h,
    hud: _module$g,
    levelup: _module$f,
    scene: _module$e,
    settings: _module$d,
    sheetConfigs: _module$8,
    sheets: _module$a,
    sidebar: _module$7,
    ui: _module$6,
    ux: _module$5
});

class DhCombat extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            battleToggles: new fields.ArrayField(
                new fields.SchemaField({
                    category: new fields.NumberField({ required: true, integer: true }),
                    grouping: new fields.StringField({ required: true })
                })
            )
        };
    }

    /** Includes automatic BPModifiers  */
    get extendedBattleToggles() {
        const modifiers = CONFIG.DH.ENCOUNTER.BPModifiers;
        const adversaries =
            this.parent.turns?.filter(x => x.isNPC)?.map(x => ({ ...x.actor, type: x.actor.system.type })) ?? [];
        const characters = this.parent.turns?.filter(x => !x.isNPC) ?? [];

        const activeAutomatic = Object.keys(modifiers).reduce((acc, categoryKey) => {
            const category = modifiers[categoryKey];
            acc.push(
                ...Object.keys(category).reduce((acc, groupingKey) => {
                    const grouping = category[groupingKey];
                    if (grouping.automatic && grouping.conditional?.(this.parent, adversaries, characters)) {
                        acc.push({ category: Number(categoryKey), grouping: groupingKey });
                    }

                    return acc;
                }, [])
            );

            return acc;
        }, []);

        return [...this.battleToggles, ...activeAutomatic];
    }
}

let DhCombatant$1 = class DhCombatant extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            spotlight: new fields.SchemaField({
                requesting: new fields.BooleanField({ required: true, initial: false }),
                requestOrderIndex: new fields.NumberField({ required: true, integer: true, initial: 0 })
            }),
            actionTokens: new fields.NumberField({ required: true, integer: true, initial: 3 })
        };
    }

    get isDefeated() {
        const { unconscious, defeated, dead } = CONFIG.DH.GENERAL.conditions;
        const defeatedConditions = new Set([unconscious.id, defeated.id, dead.id]);
        return this.defeated || this.actor?.statuses.intersection(defeatedConditions)?.size;
    }
};

/**
 * A subclass of {@link foundry.data.fields.DocumentUUIDField} to allow selecting a foreign document reference
 * that resolves to either the document, the index(for items in compenidums) or the UUID string.
 */
class ForeignDocumentUUIDField extends foundry.data.fields.DocumentUUIDField {
    /**
     * @param {foundry.data.types.DocumentUUIDFieldOptions} [options] Options which configure the behavior of the field
     * @param {foundry.data.types.DataFieldContext} [context]    Additional context which describes the field
     */
    constructor(options, context) {
        super(options, context);
    }

    /** @inheritdoc */
    static get _defaults() {
        return foundry.utils.mergeObject(super._defaults, {
            nullable: true,
            readonly: false,
            idOnly: false
        });
    }

    /**@override */
    initialize(value, _model, _options = {}) {
        if (this.idOnly) return value;
        return () => {
            try {
                const doc = fromUuidSync(value);
                return doc;
            } catch (error) {
                console.error(error);
                return value ?? null;
            }
        };
    }

    /**@override */
    toObject(value) {
        return value?.uuid ?? value;
    }

    /** @override */
    _cast(value) {
        if (typeof value === 'string') return value;
        if (value instanceof foundry.abstract.Document) return value.uuid;
        throw new Error(
            `The value provided to a ForeignDocumentUUIDField must be a ${foundry.abstract.Document.name} instance or a UUID string.`
        );
    }
}

class DhLevelData extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            level: new fields.SchemaField({
                current: new fields.NumberField({ required: true, integer: true, initial: 1 }),
                changed: new fields.NumberField({ required: true, integer: true, initial: 1 }),
                bonuses: new fields.TypedObjectField(new fields.NumberField({ integer: true, nullable: false }))
            }),
            levelups: new fields.TypedObjectField(
                new fields.SchemaField({
                    achievements: new fields.SchemaField(
                        {
                            experiences: new fields.TypedObjectField(
                                new fields.SchemaField({
                                    name: new fields.StringField({ required: true }),
                                    modifier: new fields.NumberField({ required: true, integer: true })
                                })
                            ),
                            domainCards: new fields.ArrayField(
                                new fields.SchemaField({
                                    uuid: new fields.StringField({ required: true }),
                                    itemUuid: new fields.StringField({ required: true })
                                })
                            ),
                            proficiency: new fields.NumberField({ integer: true })
                        },
                        { nullable: true, initial: null }
                    ),
                    selections: new fields.ArrayField(
                        new fields.SchemaField({
                            tier: new fields.NumberField({ required: true, integer: true }),
                            level: new fields.NumberField({ required: true, integer: true }),
                            optionKey: new fields.StringField({ required: true }),
                            type: new fields.StringField({ required: true, choices: LevelOptionType }),
                            checkboxNr: new fields.NumberField({ required: true, integer: true }),
                            value: new fields.NumberField({ integer: true }),
                            minCost: new fields.NumberField({ integer: true }),
                            amount: new fields.NumberField({ integer: true }),
                            data: new fields.ArrayField(new fields.StringField({ required: true })),
                            secondaryData: new fields.TypedObjectField(new fields.StringField({ required: true })),
                            itemUuid: new fields.DocumentUUIDField({ required: true }),
                            features: new fields.ArrayField(
                                new fields.SchemaField({
                                    onPartner: new fields.BooleanField(),
                                    id: new fields.StringField()
                                })
                            )
                        })
                    )
                })
            )
        };
    }

    get canLevelUp() {
        return this.level.current < this.level.changed;
    }
}

const resistanceField = (resistanceLabel, immunityLabel, reductionLabel) =>
    new foundry.data.fields.SchemaField({
        resistance: new foundry.data.fields.BooleanField({
            initial: false,
            label: `${resistanceLabel}.label`,
            hint: `${resistanceLabel}.hint`,
            isAttributeChoice: true
        }),
        immunity: new foundry.data.fields.BooleanField({
            initial: false,
            label: `${immunityLabel}.label`,
            hint: `${immunityLabel}.hint`,
            isAttributeChoice: true
        }),
        reduction: new foundry.data.fields.NumberField({
            integer: true,
            initial: 0,
            label: `${reductionLabel}.label`,
            hint: `${reductionLabel}.hint`
        })
    });

/**
 * Describes metadata about the actor data model type
 * @typedef {Object} ActorDataModelMetadata
 * @property {string} label - A localizable label used on application.
 * @property {string} type - The system type that this data model represents.
 * @property {Boolean} isNPC - This data model represents a NPC?
 * @property {typeof DHBaseActorSettings} settingSheet - The sheet class used to render the settings UI for this actor type.
 */
class BaseDataActor extends foundry.abstract.TypeDataModel {
    /** @returns {ActorDataModelMetadata}*/
    static get metadata() {
        return {
            label: 'Base Actor',
            type: 'base',
            isNPC: true,
            settingSheet: null,
            hasResistances: true,
            hasAttribution: false,
            hasLimitedView: true
        };
    }

    /**@returns {ActorDataModelMetadata}*/
    get metadata() {
        return this.constructor.metadata;
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        const schema = {};

        if (this.metadata.hasAttribution) {
            schema.attribution = new fields.SchemaField({
                source: new fields.StringField(),
                page: new fields.NumberField(),
                artist: new fields.StringField()
            });
        }
        if (this.metadata.isNPC) schema.description = new fields.HTMLField({ required: true, nullable: true });
        if (this.metadata.hasResistances)
            schema.resistance = new fields.SchemaField({
                physical: resistanceField(
                    'DAGGERHEART.GENERAL.DamageResistance.physicalResistance',
                    'DAGGERHEART.GENERAL.DamageResistance.physicalImmunity',
                    'DAGGERHEART.GENERAL.DamageResistance.physicalReduction'
                ),
                magical: resistanceField(
                    'DAGGERHEART.GENERAL.DamageResistance.magicalResistance',
                    'DAGGERHEART.GENERAL.DamageResistance.magicalImmunity',
                    'DAGGERHEART.GENERAL.DamageResistance.magicalReduction'
                )
            });
        return schema;
    }

    /* -------------------------------------------- */

    /**
     * The default icon used for newly created Actors documents
     * @type {string}
     */
    static DEFAULT_ICON = null;

    get attributionLabel() {
        if (!this.attribution) return;

        const { source, page } = this.attribution;
        return [source, page ? `pg ${page}.` : null].filter(x => x).join('. ');
    }

    /* -------------------------------------------- */

    /**
     * Obtain a data object used to evaluate any dice rolls associated with this Item Type
     * @param {object} [options] - Options which modify the getRollData method.
     * @returns {object}
     */
    getRollData() {
        const data = { ...this };
        return data;
    }

    async _preDelete() {
        /* Clear all partyMembers from tagTeam setting.*/
        /* Revisit this when tagTeam is improved for many parties */
        if (this.parent.parties.size > 0) {
            const tagTeam = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
            await tagTeam.updateSource({
                initiator: this.parent.id === tagTeam.initiator ? null : tagTeam.initiator,
                members: Object.keys(tagTeam.members).find(x => x === this.parent.id)
                    ? { [`-=${this.parent.id}`]: null }
                    : {}
            });
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll, tagTeam);
        }
    }

    async _preUpdate(changes, options, userId) {
        const allowed = await super._preUpdate(changes, options, userId);
        if (allowed === false) return;

        const autoSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation);
        if (changes.system?.resources && autoSettings.resourceScrollTexts) {
            const textData = Object.keys(changes.system.resources).reduce((acc, key) => {
                const resource = changes.system.resources[key];
                if (resource.value !== undefined && resource.value !== this.resources[key].value) {
                    acc.push(getScrollTextData(this.resources, resource, key));
                }

                return acc;
            }, []);
            options.scrollingTextData = textData;
        }

        if (changes.system?.resources) {
            const defeatedSettings = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.Automation
            ).defeated;
            const typeForDefeated = ['character', 'adversary', 'companion'].find(x => x === this.parent.type);
            if (defeatedSettings.enabled && typeForDefeated) {
                const resource = typeForDefeated === 'companion' ? 'stress' : 'hitPoints';
                const resourceValue = changes.system.resources[resource];
                if (
                    resourceValue &&
                    this.resources[resource].max &&
                    resourceValue.value !== this.resources[resource].value
                ) {
                    const becameMax = resourceValue.value === this.resources[resource].max;
                    const wasMax =
                        this.resources[resource].value === this.resources[resource].max &&
                        this.resources[resource].value !== resourceValue.value;
                    if (becameMax) {
                        this.parent.toggleDefeated(true);
                    } else if (wasMax) {
                        this.parent.toggleDefeated(false);
                    }
                }
            }
        }
    }

    _onUpdate(changes, options, userId) {
        super._onUpdate(changes, options, userId);

        if (options.scrollingTextData) this.parent.queueScrollText(options.scrollingTextData);
    }
}

const fields$b = foundry.data.fields;

const attributeField = label =>
    new fields$b.SchemaField({
        value: new fields$b.NumberField({ initial: 0, integer: true, label }),
        tierMarked: new fields$b.BooleanField({ initial: false })
    });

const resourceField = (max = 0, initial = 0, label, reverse = false, maxLabel) =>
    new fields$b.SchemaField({
        value: new fields$b.NumberField({ initial: initial, min: 0, integer: true, label }),
        max: new fields$b.NumberField({
            initial: max,
            integer: true,
            label:
                maxLabel ?? game.i18n.format('DAGGERHEART.GENERAL.maxWithThing', { thing: game.i18n.localize(label) })
        }),
        isReversed: new fields$b.BooleanField({ initial: reverse })
    });

const stressDamageReductionRule = localizationPath =>
    new fields$b.SchemaField({
        cost: new fields$b.NumberField({
            integer: true,
            label: `${localizationPath}.label`,
            hint: `${localizationPath}.hint`
        })
    });

const bonusField = label =>
    new fields$b.SchemaField({
        bonus: new fields$b.NumberField({ integer: true, initial: 0, label: `${game.i18n.localize(label)} Value` }),
        dice: new fields$b.ArrayField(new fields$b.StringField(), { label: `${game.i18n.localize(label)} Dice` })
    });

class DhCharacter extends BaseDataActor {
    /**@override */
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Character'];

    /**@inheritdoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.character',
            type: 'character',
            settingSheet: DHCharacterSettings,
            isNPC: false
        });
    }

    /**@inheritdoc */
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            ...super.defineSchema(),
            resources: new fields.SchemaField({
                hitPoints: resourceField(
                    0,
                    0,
                    'DAGGERHEART.GENERAL.HitPoints.plural',
                    true,
                    'DAGGERHEART.ACTORS.Character.maxHPBonus'
                ),
                stress: resourceField(6, 0, 'DAGGERHEART.GENERAL.stress', true),
                hope: resourceField(6, 2, 'DAGGERHEART.GENERAL.hope')
            }),
            traits: new fields.SchemaField({
                agility: attributeField('DAGGERHEART.CONFIG.Traits.agility.name'),
                strength: attributeField('DAGGERHEART.CONFIG.Traits.strength.name'),
                finesse: attributeField('DAGGERHEART.CONFIG.Traits.finesse.name'),
                instinct: attributeField('DAGGERHEART.CONFIG.Traits.instinct.name'),
                presence: attributeField('DAGGERHEART.CONFIG.Traits.presence.name'),
                knowledge: attributeField('DAGGERHEART.CONFIG.Traits.knowledge.name')
            }),
            proficiency: new fields.NumberField({
                initial: 1,
                integer: true,
                label: 'DAGGERHEART.GENERAL.proficiency'
            }),
            evasion: new fields.NumberField({ initial: 0, integer: true, label: 'DAGGERHEART.GENERAL.evasion' }),
            armorScore: new fields.NumberField({ integer: true, initial: 0, label: 'DAGGERHEART.GENERAL.armorScore' }),
            damageThresholds: new fields.SchemaField({
                severe: new fields.NumberField({
                    integer: true,
                    initial: 0,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.severeThreshold'
                }),
                major: new fields.NumberField({
                    integer: true,
                    initial: 0,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.majorThreshold'
                })
            }),
            experiences: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField(),
                    value: new fields.NumberField({ integer: true, initial: 0 }),
                    description: new fields.StringField(),
                    core: new fields.BooleanField({ initial: false })
                })
            ),
            gold: new fields.SchemaField({
                coins: new fields.NumberField({ initial: 0, integer: true }),
                handfuls: new fields.NumberField({ initial: 1, integer: true }),
                bags: new fields.NumberField({ initial: 0, integer: true }),
                chests: new fields.NumberField({ initial: 0, integer: true })
            }),
            scars: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField({}),
                    description: new fields.StringField()
                })
            ),
            biography: new fields.SchemaField({
                background: new fields.HTMLField(),
                connections: new fields.HTMLField(),
                characteristics: new fields.SchemaField({
                    pronouns: new fields.StringField({}),
                    age: new fields.StringField({}),
                    faith: new fields.StringField({})
                })
            }),
            attack: new ActionField({
                initial: {
                    name: 'DAGGERHEART.GENERAL.unarmedAttack',
                    img: 'icons/skills/melee/unarmed-punch-fist-yellow-red.webp',
                    _id: foundry.utils.randomID(),
                    systemPath: 'attack',
                    chatDisplay: false,
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        type: 'attack',
                        trait: 'strength'
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@profd4'
                                    }
                                }
                            }
                        ]
                    }
                }
            }),
            advantageSources: new fields.ArrayField(new fields.StringField(), {
                label: 'DAGGERHEART.ACTORS.Character.advantageSources.label',
                hint: 'DAGGERHEART.ACTORS.Character.advantageSources.hint'
            }),
            disadvantageSources: new fields.ArrayField(new fields.StringField(), {
                label: 'DAGGERHEART.ACTORS.Character.disadvantageSources.label',
                hint: 'DAGGERHEART.ACTORS.Character.disadvantageSources.hint'
            }),
            levelData: new fields.EmbeddedDataField(DhLevelData),
            bonuses: new fields.SchemaField({
                roll: new fields.SchemaField({
                    attack: bonusField('DAGGERHEART.GENERAL.Roll.attack'),
                    spellcast: bonusField('DAGGERHEART.GENERAL.Roll.spellcast'),
                    trait: bonusField('DAGGERHEART.GENERAL.Roll.trait'),
                    action: bonusField('DAGGERHEART.GENERAL.Roll.action'),
                    reaction: bonusField('DAGGERHEART.GENERAL.Roll.reaction'),
                    primaryWeapon: bonusField('DAGGERHEART.GENERAL.Roll.primaryWeaponAttack'),
                    secondaryWeapon: bonusField('DAGGERHEART.GENERAL.Roll.secondaryWeaponAttack')
                }),
                damage: new fields.SchemaField({
                    physical: bonusField('DAGGERHEART.GENERAL.Damage.physicalDamage'),
                    magical: bonusField('DAGGERHEART.GENERAL.Damage.magicalDamage'),
                    primaryWeapon: bonusField('DAGGERHEART.GENERAL.Damage.primaryWeapon'),
                    secondaryWeapon: bonusField('DAGGERHEART.GENERAL.Damage.secondaryWeapon')
                }),
                healing: bonusField('DAGGERHEART.GENERAL.Healing.healingAmount'),
                range: new fields.SchemaField({
                    weapon: new fields.NumberField({
                        integer: true,
                        initial: 0,
                        label: 'DAGGERHEART.GENERAL.Range.weapon'
                    }),
                    spell: new fields.NumberField({
                        integer: true,
                        initial: 0,
                        label: 'DAGGERHEART.GENERAL.Range.spell'
                    }),
                    other: new fields.NumberField({
                        integer: true,
                        initial: 0,
                        label: 'DAGGERHEART.GENERAL.Range.other'
                    })
                }),
                rally: new fields.ArrayField(new fields.StringField(), {
                    label: 'DAGGERHEART.CLASS.Feature.rallyDice'
                }),
                rest: new fields.SchemaField({
                    shortRest: new fields.SchemaField({
                        shortMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.shortRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.shortRestMoves.hint'
                        }),
                        longMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.longRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.longRestMoves.hint'
                        })
                    }),
                    longRest: new fields.SchemaField({
                        shortMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.shortRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.shortRestMoves.hint'
                        }),
                        longMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.longRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.longRestMoves.hint'
                        })
                    })
                }),
                maxLoadout: new fields.NumberField({
                    integer: true,
                    initial: 0,
                    label: 'DAGGERHEART.GENERAL.Bonuses.maxLoadout.label'
                })
            }),
            companion: new ForeignDocumentUUIDField({ type: 'Actor', nullable: true, initial: null }),
            rules: new fields.SchemaField({
                damageReduction: new fields.SchemaField({
                    maxArmorMarked: new fields.SchemaField({
                        value: new fields.NumberField({
                            required: true,
                            integer: true,
                            initial: 1,
                            label: 'DAGGERHEART.GENERAL.Rules.damageReduction.maxArmorMarkedBonus'
                        }),
                        stressExtra: new fields.NumberField({
                            required: true,
                            integer: true,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Rules.damageReduction.maxArmorMarkedStress.label',
                            hint: 'DAGGERHEART.GENERAL.Rules.damageReduction.maxArmorMarkedStress.hint'
                        })
                    }),
                    stressDamageReduction: new fields.SchemaField({
                        severe: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.severe'),
                        major: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.major'),
                        minor: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.minor'),
                        any: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.any')
                    }),
                    increasePerArmorMark: new fields.NumberField({
                        integer: true,
                        initial: 1,
                        label: 'DAGGERHEART.GENERAL.Rules.damageReduction.increasePerArmorMark.label',
                        hint: 'DAGGERHEART.GENERAL.Rules.damageReduction.increasePerArmorMark.hint'
                    }),
                    magical: new fields.BooleanField({ initial: false }),
                    physical: new fields.BooleanField({ initial: false }),
                    thresholdImmunities: new fields.SchemaField({
                        minor: new fields.BooleanField({ initial: false })
                    }),
                    reduceSeverity: new fields.SchemaField({
                        magical: new fields.NumberField({ initial: 0, min: 0 }),
                        physical: new fields.NumberField({ initial: 0, min: 0 })
                    }),
                    disabledArmor: new fields.BooleanField({ intial: false })
                }),
                attack: new fields.SchemaField({
                    damage: new fields.SchemaField({
                        diceIndex: new fields.NumberField({
                            integer: true,
                            min: 0,
                            max: 5,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.damage.dice.label',
                            hint: 'DAGGERHEART.GENERAL.Rules.attack.damage.dice.hint'
                        }),
                        bonus: new fields.NumberField({
                            required: true,
                            initial: 0,
                            min: 0,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.damage.bonus.label'
                        })
                    }),
                    roll: new fields.SchemaField({
                        trait: new fields.StringField({
                            required: true,
                            choices: CONFIG.DH.ACTOR.abilities,
                            nullable: true,
                            initial: null,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.roll.trait.label'
                        })
                    })
                }),
                conditionImmunities: new fields.SchemaField({
                    hidden: new fields.BooleanField({ initial: false }),
                    restrained: new fields.BooleanField({ initial: false }),
                    vulnerable: new fields.BooleanField({ initial: false })
                }),
                runeWard: new fields.BooleanField({ initial: false }),
                burden: new fields.SchemaField({
                    ignore: new fields.BooleanField()
                })
            })
        };
    }

    /* -------------------------------------------- */

    get tier() {
        const currentLevel = this.levelData.level.current;
        return currentLevel === 1
            ? 1
            : Object.values(game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers).find(
                  tier => currentLevel >= tier.levels.start && currentLevel <= tier.levels.end
              ).tier;
    }

    get ancestry() {
        return this.parent.items.find(x => x.type === 'ancestry') ?? null;
    }

    get community() {
        return this.parent.items.find(x => x.type === 'community') ?? null;
    }

    get class() {
        const value = this.parent.items.find(x => x.type === 'class' && !x.system.isMulticlass);
        const subclass = this.parent.items.find(x => x.type === 'subclass' && !x.system.isMulticlass);

        return {
            value,
            subclass
        };
    }

    get multiclass() {
        const value = this.parent.items.find(x => x.type === 'class' && x.system.isMulticlass);
        const subclass = this.parent.items.find(x => x.type === 'subclass' && x.system.isMulticlass);

        return {
            value,
            subclass
        };
    }

    get features() {
        return this.parent.items.filter(x => x.type === 'feature') ?? [];
    }

    get companionFeatures() {
        return this.companion ? this.companion.items.filter(x => x.type === 'feature') : [];
    }

    get needsCharacterSetup() {
        const { value: classValue, subclass } = this.class;
        return !(classValue || subclass || this.ancestry || this.community);
    }

    get spellcastModifierTrait() {
        const subClasses = this.parent.items.filter(x => x.type === 'subclass') ?? [];
        const modifiers = subClasses
            ?.map(sc => ({ ...this.traits[sc.system.spellcastingTrait], key: sc.system.spellcastingTrait }))
            .filter(x => x);
        return modifiers.sort((a, b) => a.value - b.value)[0];
    }

    get spellcastModifier() {
        return this.spellcastModifierTrait?.value ?? 0;
    }

    get spellcastingModifiers() {
        return {
            main: this.class.subclass?.system?.spellcastingTrait,
            multiclass: this.multiclass.subclass?.system?.spellcastingTrait
        };
    }

    get domains() {
        const classDomains = this.class.value ? this.class.value.system.domains : [];
        const multiclass = this.multiclass.value;
        const multiclassDomains = multiclass ? multiclass.system.domains : [];
        return [...classDomains, ...multiclassDomains];
    }

    get domainData() {
        const allDomainData = CONFIG.DH.DOMAIN.allDomains();
        return this.domains.map(key => {
            const domain = allDomainData[key];
            return {
                ...domain,
                label: game.i18n.localize(domain.label)
            };
        });
    }

    get domainCards() {
        const domainCards = this.parent.items.filter(x => x.type === 'domainCard');
        const loadout = domainCards.filter(x => !x.system.inVault);
        const vault = domainCards.filter(x => x.system.inVault);

        return {
            loadout: loadout,
            vault: vault,
            total: [...loadout, ...vault]
        };
    }

    get loadoutSlot() {
        const loadoutCount = this.domainCards.loadout?.length ?? 0,
            worldSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxLoadout,
            max = !worldSetting ? null : worldSetting + this.bonuses.maxLoadout;

        return {
            current: loadoutCount,
            available: !max ? true : Math.max(max - loadoutCount, 0),
            max
        };
    }

    get armor() {
        return this.parent.items.find(x => x.type === 'armor' && x.system.equipped);
    }

    get activeBeastform() {
        return this.parent.effects.find(x => x.type === 'beastform');
    }

    /**
     * Gets the unarmed attackwhen no primary or secondary weapon is equipped.
     * Returns `null` if either weapon is equipped.
     * If the actor is in beastform, overrides the attack's name and image.
     *
     * @returns {DHAttackAction|null}
     */
    get usedUnarmed() {
        if (this.primaryWeapon?.system?.equipped || this.secondaryWeapon?.system?.equipped) return null;

        const attack = foundry.utils.deepClone(this.attack);
        if (this.activeBeastform) {
            attack.name = 'DAGGERHEART.ITEMS.Beastform.attackName';
            attack.img = 'icons/creatures/claws/claw-straight-brown.webp';
        }
        return attack;
    }

    get sheetLists() {
        const ancestryFeatures = [],
            communityFeatures = [],
            classFeatures = [],
            subclassFeatures = [],
            companionFeatures = [],
            features = [];

        for (let item of this.parent.items) {
            if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.ancestry.id) {
                ancestryFeatures.push(item);
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.community.id) {
                communityFeatures.push(item);
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.class.id) {
                classFeatures.push(item);
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.subclass.id) {
                if (this.class.subclass) {
                    const prop = item.system.multiclassOrigin ? 'multiclass' : 'class';
                    const subclassState = this[prop].subclass?.system?.featureState;
                    if (!subclassState) continue;

                    if (
                        item.system.identifier === CONFIG.DH.ITEM.featureSubTypes.foundation ||
                        (item.system.identifier === CONFIG.DH.ITEM.featureSubTypes.specialization &&
                            subclassState >= 2) ||
                        (item.system.identifier === CONFIG.DH.ITEM.featureSubTypes.mastery && subclassState >= 3)
                    ) {
                        subclassFeatures.push(item);
                    }
                }
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.companion.id) {
                companionFeatures.push(item);
            } else if (item.type === 'feature' && !item.system.type) {
                features.push(item);
            }
        }

        return {
            ancestryFeatures: {
                title: `${game.i18n.localize('TYPES.Item.ancestry')} - ${this.ancestry?.name}`,
                type: 'ancestry',
                values: ancestryFeatures
            },
            communityFeatures: {
                title: `${game.i18n.localize('TYPES.Item.community')} - ${this.community?.name}`,
                type: 'community',
                values: communityFeatures
            },
            classFeatures: {
                title: `${game.i18n.localize('TYPES.Item.class')} - ${this.class.value?.name}`,
                type: 'class',
                values: classFeatures
            },
            subclassFeatures: {
                title: `${game.i18n.localize('TYPES.Item.subclass')} - ${this.class.subclass?.name}`,
                type: 'subclass',
                values: subclassFeatures
            },
            companionFeatures: {
                title: game.i18n.localize('DAGGERHEART.ACTORS.Character.companionFeatures'),
                type: 'companion',
                values: companionFeatures
            },
            features: { title: game.i18n.localize('DAGGERHEART.GENERAL.features'), type: 'feature', values: features }
        };
    }

    get primaryWeapon() {
        return this.parent.items.find(x => x.type === 'weapon' && x.system.equipped && !x.system.secondary);
    }

    get secondaryWeapon() {
        return this.parent.items.find(x => x.type === 'weapon' && x.system.equipped && x.system.secondary);
    }

    get getWeaponBurden() {
        return this.primaryWeapon?.system?.burden === burden.twoHanded.value ||
            (this.primaryWeapon && this.secondaryWeapon)
            ? burden.twoHanded.value
            : this.primaryWeapon || this.secondaryWeapon
              ? burden.oneHanded.value
              : null;
    }

    get deathMoveViable() {
        return this.resources.hitPoints.max > 0 && this.resources.hitPoints.value >= this.resources.hitPoints.max;
    }

    get armorApplicableDamageTypes() {
        return {
            physical: !this.rules.damageReduction.magical,
            magical: !this.rules.damageReduction.physical
        };
    }

    get basicAttackDamageDice() {
        const diceTypes = Object.keys(CONFIG.DH.GENERAL.diceTypes);
        const attackDiceIndex = Math.max(Math.min(this.rules.attack.damage.diceIndex, 5), 0);
        return diceTypes[attackDiceIndex];
    }

    static async unequipBeforeEquip(itemToEquip) {
        const primary = this.primaryWeapon,
            secondary = this.secondaryWeapon;
        if (itemToEquip.system.secondary) {
            if (primary && primary.burden === CONFIG.DH.GENERAL.burden.twoHanded.value) {
                await primary.update({ 'system.equipped': false });
            }

            if (secondary) {
                await secondary.update({ 'system.equipped': false });
            }
        } else {
            if (secondary && itemToEquip.system.burden === CONFIG.DH.GENERAL.burden.twoHanded.value) {
                await secondary.update({ 'system.equipped': false });
            }

            if (primary) {
                await primary.update({ 'system.equipped': false });
            }
        }
    }

    prepareBaseData() {
        this.evasion += this.class.value?.system?.evasion ?? 0;

        const currentLevel = this.levelData.level.current;
        const currentTier =
            currentLevel === 1
                ? null
                : Object.values(game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers).find(
                      tier => currentLevel >= tier.levels.start && currentLevel <= tier.levels.end
                  ).tier;
        if (game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto) {
            for (let levelKey in this.levelData.levelups) {
                const level = this.levelData.levelups[levelKey];

                this.proficiency += level.achievements.proficiency;

                for (let selection of level.selections) {
                    switch (selection.type) {
                        case 'trait':
                            selection.data.forEach(data => {
                                this.traits[data].value += 1;
                                this.traits[data].tierMarked = selection.tier === currentTier;
                            });
                            break;
                        case 'hitPoint':
                            this.resources.hitPoints.max += selection.value;
                            break;
                        case 'stress':
                            this.resources.stress.max += selection.value;
                            break;
                        case 'evasion':
                            this.evasion += selection.value;
                            break;
                        case 'proficiency':
                            this.proficiency += selection.value;
                            break;
                        case 'experience':
                            selection.data.forEach(id => {
                                const experience = this.experiences[id];
                                if (experience) {
                                    experience.value += selection.value;
                                    experience.leveledUp = true;
                                }
                            });
                            break;
                    }
                }
            }
        }

        const armor = this.armor;
        this.armorScore = armor ? armor.system.baseScore : 0;
        this.damageThresholds = {
            major: armor
                ? armor.system.baseThresholds.major + this.levelData.level.current
                : this.levelData.level.current,
            severe: armor
                ? armor.system.baseThresholds.severe + this.levelData.level.current
                : this.levelData.level.current * 2
        };
        this.resources.hope.max -= Object.keys(this.scars).length;
        this.resources.hitPoints.max += this.class.value?.system?.hitPoints ?? 0;
    }

    prepareDerivedData() {
        let baseHope = this.resources.hope.value;
        if (this.companion) {
            for (let levelKey in this.companion.system.levelData.levelups) {
                const level = this.companion.system.levelData.levelups[levelKey];
                for (let selection of level.selections) {
                    switch (selection.type) {
                        case 'hope':
                            this.resources.hope.max += selection.value;
                            break;
                    }
                }
            }
        }

        this.resources.hope.value = Math.min(baseHope, this.resources.hope.max);
        this.attack.roll.trait = this.rules.attack.roll.trait ?? this.attack.roll.trait;

        this.resources.armor = {
            value: this.armor?.system?.marks?.value ?? 0,
            max: this.armorScore,
            isReversed: true
        };

        this.attack.damage.parts[0].value.custom.formula = `@prof${this.basicAttackDamageDice}${this.rules.attack.damage.bonus ? ` + ${this.rules.attack.damage.bonus}` : ''}`;
    }

    getRollData() {
        const data = super.getRollData();

        return {
            ...data,
            basicAttackDamageDice: this.basicAttackDamageDice,
            tier: this.tier,
            level: this.levelData.level.current
        };
    }

    async _preUpdate(changes, options, userId) {
        const allowed = await super._preUpdate(changes, options, userId);
        if (allowed === false) return;

        /* The first two experiences are always marked as core */
        if (changes.system?.experiences && Object.keys(this.experiences).length < 2) {
            const experiences = new Set(Object.keys(this.experiences));
            const changeExperiences = new Set(Object.keys(changes.system.experiences));
            const newExperiences = Array.from(changeExperiences.difference(experiences));

            for (var i = 0; i < Math.min(newExperiences.length, 2 - experiences.size); i++) {
                const experience = newExperiences[i];
                changes.system.experiences[experience].core = true;
            }
        }
    }

    async _preDelete() {
        super._preDelete();

        if (this.companion) {
            this.companion.updateLevel(1);
        }
    }

    _getTags() {
        return [this.class.value?.name, this.class.subclass?.name, this.community?.name, this.ancestry?.name].filter(
            t => !!t
        );
    }
}

class DhCompanion extends BaseDataActor {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Companion'];

    /**@inheritdoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.companion',
            type: 'companion',
            isNPC: false,
            settingSheet: DHCompanionSettings
        });
    }

    /**@inheritdoc */
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            ...super.defineSchema(),
            partner: new ForeignDocumentUUIDField({ type: 'Actor' }),
            resources: new fields.SchemaField({
                stress: resourceField(3, 0, 'DAGGERHEART.GENERAL.stress', true),
                hope: new fields.NumberField({ initial: 0, integer: true, label: 'DAGGERHEART.GENERAL.hope' })
            }),
            evasion: new fields.NumberField({
                required: true,
                min: 1,
                initial: 10,
                integer: true,
                label: 'DAGGERHEART.GENERAL.evasion'
            }),
            experiences: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField({}),
                    value: new fields.NumberField({ integer: true, initial: 0 }),
                    description: new fields.StringField(),
                    core: new fields.BooleanField({ initial: false })
                }),
                {
                    initial: {
                        experience1: { value: 2, core: true },
                        experience2: { value: 2, core: true }
                    }
                }
            ),
            rules: new fields.SchemaField({
                conditionImmunities: new fields.SchemaField({
                    hidden: new fields.BooleanField({ initial: false }),
                    restrained: new fields.BooleanField({ initial: false }),
                    vulnerable: new fields.BooleanField({ initial: false })
                })
            }),
            attack: new ActionField({
                initial: {
                    name: 'Attack',
                    img: 'icons/creatures/claws/claw-bear-paw-swipe-brown.webp',
                    _id: foundry.utils.randomID(),
                    systemPath: 'attack',
                    chatDisplay: false,
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        type: 'attack',
                        bonus: 0
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    dice: 'd6',
                                    multiplier: 'prof'
                                }
                            }
                        ]
                    }
                }
            }),
            levelData: new fields.EmbeddedDataField(DhLevelData),
            bonuses: new fields.SchemaField({
                damage: new fields.SchemaField({
                    physical: bonusField('DAGGERHEART.GENERAL.Damage.physicalDamage'),
                    magical: bonusField('DAGGERHEART.GENERAL.Damage.magicalDamage')
                })
            })
        };
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/actors/capybara.svg';

    /* -------------------------------------------- */

    get proficiency() {
        return this.partner?.system?.proficiency ?? 1;
    }
    
    isItemValid() {
        return false;
    }

    prepareBaseData() {
        this.attack.roll.bonus = this.partner?.system?.spellcastModifier ?? 0;

        for (let levelKey in this.levelData.levelups) {
            const level = this.levelData.levelups[levelKey];
            for (let selection of level.selections) {
                switch (selection.type) {
                    case 'hope':
                        this.resources.hope += selection.value;
                        break;
                    case 'vicious':
                        if (selection.data[0] === 'damage') {
                            this.attack.damage.parts[0].value.dice = adjustDice(this.attack.damage.parts[0].value.dice);
                        } else {
                            this.attack.range = adjustRange(this.attack.range);
                        }
                        break;
                    case 'stress':
                        this.resources.stress.max += selection.value;
                        break;
                    case 'evasion':
                        this.evasion += selection.value;
                        break;
                    case 'experience':
                        Object.keys(this.experiences).forEach(key => {
                            const experience = this.experiences[key];
                            experience.value += selection.value;
                        });
                        break;
                }
            }
        }
    }

    async _preUpdate(changes, options, userId) {
        const allowed = await super._preUpdate(changes, options, userId);
        if (allowed === false) return;

        /* The first two experiences are always marked as core */
        if (changes.system?.experiences && Object.keys(this.experiences).length < 2) {
            const experiences = new Set(Object.keys(this.experiences));
            const changeExperiences = new Set(Object.keys(changes.system.experiences));
            const newExperiences = Array.from(changeExperiences.difference(experiences));

            for (var i = 0; i < Math.min(newExperiences.length, 2 - experiences.size); i++) {
                const experience = newExperiences[i];
                changes.system.experiences[experience].core = true;
            }
        }
    }

    async _preDelete() {
        if (this.partner) {
            await this.partner.update({ 'system.companion': null });
        }
    }
}

class DhpAdversary extends BaseDataActor {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Adversary'];

    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.adversary',
            type: 'adversary',
            settingSheet: DHAdversarySettings,
            hasAttribution: true
        });
    }

    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                choices: CONFIG.DH.GENERAL.tiers,
                initial: CONFIG.DH.GENERAL.tiers[1].id
            }),
            type: new fields.StringField({
                required: true,
                choices: CONFIG.DH.ACTOR.allAdversaryTypes,
                initial: CONFIG.DH.ACTOR.adversaryTypes.standard.id
            }),
            motivesAndTactics: new fields.StringField(),
            notes: new fields.HTMLField(),
            difficulty: new fields.NumberField({ required: true, initial: 1, integer: true }),
            hordeHp: new fields.NumberField({
                required: true,
                initial: 1,
                integer: true,
                label: 'DAGGERHEART.GENERAL.hordeHp'
            }),
            criticalThreshold: new fields.NumberField({ required: true, integer: true, min: 1, max: 20, initial: 20 }),
            damageThresholds: new fields.SchemaField({
                major: new fields.NumberField({
                    required: true,
                    initial: 0,
                    integer: true,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.majorThreshold'
                }),
                severe: new fields.NumberField({
                    required: true,
                    initial: 0,
                    integer: true,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.severeThreshold'
                })
            }),
            resources: new fields.SchemaField({
                hitPoints: resourceField(
                    0,
                    0,
                    'DAGGERHEART.GENERAL.HitPoints.plural',
                    true,
                    game.i18n.localize('DAGGERHEART.GENERAL.max')
                ),
                stress: resourceField(
                    0,
                    0,
                    'DAGGERHEART.GENERAL.stress',
                    true,
                    game.i18n.localize('DAGGERHEART.GENERAL.max')
                )
            }),
            rules: new fields.SchemaField({
                conditionImmunities: new fields.SchemaField({
                    hidden: new fields.BooleanField({ initial: false }),
                    restrained: new fields.BooleanField({ initial: false }),
                    vulnerable: new fields.BooleanField({ initial: false })
                })
            }),
            attack: new ActionField({
                initial: {
                    name: 'Attack',
                    img: 'icons/skills/melee/blood-slash-foam-red.webp',
                    _id: foundry.utils.randomID(),
                    systemPath: 'attack',
                    chatDisplay: false,
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        type: 'attack'
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    multiplier: 'flat'
                                }
                            }
                        ]
                    }
                }
            }),
            experiences: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField(),
                    value: new fields.NumberField({ required: true, integer: true, initial: 1 }),
                    description: new fields.StringField()
                })
            ),
            bonuses: new fields.SchemaField({
                roll: new fields.SchemaField({
                    attack: bonusField('DAGGERHEART.GENERAL.Roll.attack'),
                    action: bonusField('DAGGERHEART.GENERAL.Roll.action'),
                    reaction: bonusField('DAGGERHEART.GENERAL.Roll.reaction')
                }),
                damage: new fields.SchemaField({
                    physical: bonusField('DAGGERHEART.GENERAL.Damage.physicalDamage'),
                    magical: bonusField('DAGGERHEART.GENERAL.Damage.magicalDamage')
                })
            })
        };
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/actors/dragon-head.svg';

    /* -------------------------------------------- */

    get attackBonus() {
        return this.attack.roll.bonus;
    }

    get features() {
        return this.parent.items.filter(x => x.type === 'feature');
    }

    isItemValid(source) {
        return source.type === "feature";
    }

    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        if (this.type === CONFIG.DH.ACTOR.adversaryTypes.horde.id) {
            const autoHordeDamage = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.Automation
            ).hordeDamage;
            if (autoHordeDamage && changes.system?.resources?.hitPoints?.value !== undefined) {
                const hordeActiveEffect = this.parent.effects.find(x => x.type === 'horde');
                if (hordeActiveEffect) {
                    const halfHP = Math.ceil(this.resources.hitPoints.max / 2);
                    const newHitPoints = changes.system.resources.hitPoints.value;
                    const previouslyAboveHalf = this.resources.hitPoints.value < halfHP;
                    const loweredBelowHalf = previouslyAboveHalf && newHitPoints >= halfHP;
                    const raisedAboveHalf = !previouslyAboveHalf && newHitPoints < halfHP;
                    if (loweredBelowHalf) {
                        await hordeActiveEffect.update({ disabled: false });
                    } else if (raisedAboveHalf) {
                        await hordeActiveEffect.update({ disabled: true });
                    }
                }
            }
        }
    }

    _onUpdate(changes, options, userId) {
        super._onUpdate(changes, options, userId);

        if (game.user.id === userId) {
            if (changes.system?.type) {
                const existingHordeEffect = this.parent.effects.find(x => x.type === 'horde');
                if (changes.system.type === CONFIG.DH.ACTOR.adversaryTypes.horde.id) {
                    if (!existingHordeEffect)
                        this.parent.createEmbeddedDocuments('ActiveEffect', [
                            {
                                type: 'horde',
                                name: game.i18n.localize('DAGGERHEART.CONFIG.AdversaryType.horde.label'),
                                img: 'icons/magic/movement/chevrons-down-yellow.webp',
                                disabled: true
                            }
                        ]);
                } else {
                    existingHordeEffect?.delete();
                }
            }
        }
    }

    _getTags() {
        const tags = [
            game.i18n.localize(`DAGGERHEART.GENERAL.Tiers.${this.tier}`),
            `${game.i18n.localize(`DAGGERHEART.CONFIG.AdversaryType.${this.type}.label`)}`,
            `${game.i18n.localize('DAGGERHEART.GENERAL.difficulty')}: ${this.difficulty}`
        ];
        return tags;
    }
}

/**
 * A subclass of {@link foundry.data.fields.ArrayField} that defines an array of foreign document UUID references.
 */
class ForeignDocumentUUIDArrayField extends foundry.data.fields.ArrayField {
    /**
     * @param {foundry.data.types.DocumentUUIDFieldOptions} [fieldOption] - Options to configure each individual ForeignDocumentUUIDField.
     * @param {foundry.data.types.ArrayFieldOptions} [options] - Options to configure the array behavior
     * @param {foundry.data.types.DataFieldContext} [context] -  Optional context for schema processing
     */
    constructor(fieldOption = {}, options = {}, context = {}) {
        super(new ForeignDocumentUUIDField(fieldOption), options, context);
    }

    /** @inheritdoc */
    initialize(value, model, options = {}) {
        const v = super.initialize(value, model, options);
        return () => {
            const data = v.map(entry => (typeof entry === 'function' ? entry() : entry));
            return this.options.prune ? data.filter(d => !!d) : data;
        };
    }
}

class DhEnvironment extends BaseDataActor {
    /**@override */
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Environment'];

    /**@inheritdoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.environment',
            type: 'environment',
            settingSheet: DHEnvironmentSettings,
            hasResistances: false,
            hasAttribution: true
        });
    }

    /**@inheritdoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                choices: CONFIG.DH.GENERAL.tiers,
                initial: CONFIG.DH.GENERAL.tiers[1].id
            }),
            type: new fields.StringField({ choices: CONFIG.DH.ACTOR.environmentTypes }),
            impulses: new fields.StringField(),
            difficulty: new fields.NumberField({ required: true, initial: 11, integer: true }),
            potentialAdversaries: new fields.TypedObjectField(
                new fields.SchemaField({
                    label: new fields.StringField(),
                    adversaries: new ForeignDocumentUUIDArrayField({ type: 'Actor' })
                })
            ),
            notes: new fields.HTMLField()
        };
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/actors/forest.svg';

    /* -------------------------------------------- */

    get features() {
        return this.parent.items.filter(x => x.type === 'feature');
    }

    isItemValid(source) {
        return source.type === "feature";
    }
}

class DhParty extends BaseDataActor {
    /**@inheritdoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            partyMembers: new ForeignDocumentUUIDArrayField({ type: 'Actor' }, { prune: true }),
            notes: new fields.HTMLField(),
            gold: new fields.SchemaField({
                coins: new fields.NumberField({ initial: 0, integer: true }),
                handfuls: new fields.NumberField({ initial: 1, integer: true }),
                bags: new fields.NumberField({ initial: 0, integer: true }),
                chests: new fields.NumberField({ initial: 0, integer: true })
            })
        };
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/actors/dark-squad.svg';

    /* -------------------------------------------- */

    isItemValid(source) {
        return ["weapon", "armor", "consumable", "loot"].includes(source.type);
    }

    prepareBaseData() {
        super.prepareBaseData();

        // Register this party to all members
        if (game.actors.get(this.parent.id) === this.parent) {
            for (const member of this.partyMembers) {
                member.parties?.add(this.parent);
            }
        }
    }

    async _preDelete() {
        /* Clear all partyMembers from tagTeam setting.*/
        /* Revisit this when tagTeam is improved for many parties */
        const tagTeam = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
        await tagTeam.updateSource({
            initiator: this.partyMembers.some(x => x.id === tagTeam.initiator) ? null : tagTeam.initiator,
            members: Object.keys(tagTeam.members).reduce((acc, key) => {
                if (this.partyMembers.find(x => x.id === key)) {
                    acc[`-=${key}`] = null;
                }

                return acc;
            }, {})
        });
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll, tagTeam);
    }

    _onDelete(options, userId) {
        super._onDelete(options, userId);

        // Clear this party from all members that aren't deleted
        for (const member of this.partyMembers) {
            member?.parties?.delete(this.parent);
        }
    }
}

const config$3 = {
    character: DhCharacter,
    companion: DhCompanion,
    adversary: DhpAdversary,
    environment: DhEnvironment,
    party: DhParty
};

var _module$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhAdversary: DhpAdversary,
    DhCharacter: DhCharacter,
    DhCompanion: DhCompanion,
    DhEnvironment: DhEnvironment,
    DhParty: DhParty,
    config: config$3
});

class DhTagTeamRoll extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            initiator: new fields.SchemaField({
                id: new fields.StringField({ nullable: true, initial: null }),
                cost: new fields.NumberField({ integer: true, min: 0, initial: 3 })
            }),
            members: new fields.TypedObjectField(
                new fields.SchemaField({
                    messageId: new fields.StringField({ required: true, nullable: true, initial: null }),
                    selected: new fields.BooleanField({ required: true, initial: false })
                })
            )
        };
    }
}

class BaseEffect extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            rangeDependence: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.GENERAL.enabled'
                }),
                type: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.rangeInclusion,
                    initial: CONFIG.DH.GENERAL.rangeInclusion.withinRange.id,
                    label: 'DAGGERHEART.GENERAL.type'
                }),
                target: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.otherTargetTypes,
                    initial: CONFIG.DH.GENERAL.otherTargetTypes.hostile.id,
                    label: 'DAGGERHEART.GENERAL.Target.single'
                }),
                range: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.range,
                    initial: CONFIG.DH.GENERAL.range.melee.id,
                    label: 'DAGGERHEART.GENERAL.range'
                })
            })
        };
    }

    static getDefaultObject() {
        return {
            name: 'New Effect',
            id: foundry.utils.randomID(),
            disabled: false,
            img: 'icons/magic/life/heart-cross-blue.webp',
            description: '',
            statuses: [],
            changes: [],
            system: {
                rangeDependence: {
                    enabled: false,
                    type: CONFIG.DH.GENERAL.rangeInclusion.withinRange.id,
                    target: CONFIG.DH.GENERAL.otherTargetTypes.hostile.id,
                    range: CONFIG.DH.GENERAL.range.melee.id
                }
            }
        };
    }
}

class BeastformEffect extends BaseEffect {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            characterTokenData: new fields.SchemaField({
                usesDynamicToken: new fields.BooleanField({ initial: false }),
                tokenImg: new fields.FilePathField({
                    categories: ['IMAGE'],
                    base64: false,
                    nullable: true,
                    wildcard: true
                }),
                tokenRingImg: new fields.FilePathField({
                    initial: 'icons/svg/mystery-man.svg',
                    categories: ['IMAGE'],
                    base64: false
                }),
                tokenSize: new fields.SchemaField({
                    height: new fields.NumberField({ integer: false, nullable: true }),
                    width: new fields.NumberField({ integer: false, nullable: true })
                })
            }),
            advantageOn: new fields.ArrayField(new fields.StringField()),
            featureIds: new fields.ArrayField(new fields.StringField()),
            effectIds: new fields.ArrayField(new fields.StringField())
        };
    }

    /** @inheritDoc */
    static migrateData(source) {
        if (!source.characterTokenData.tokenSize.height) source.characterTokenData.tokenSize.height = 1;
        if (!source.characterTokenData.tokenSize.width) source.characterTokenData.tokenSize.width = 1;

        return super.migrateData(source);
    }

    async _onCreate(_data, _options, userId) {
        if (userId !== game.user.id) return;

        if (this.parent.parent?.type === 'character') {
            this.parent.parent.system.primaryWeapon?.update?.({ 'system.equipped': false });
            this.parent.parent.system.secondaryWeapon?.update?.({ 'system.equipped': false });
        }
    }

    async _preDelete() {
        if (this.parent.parent.type === 'character') {
            const baseUpdate = {
                height: this.characterTokenData.tokenSize.height,
                width: this.characterTokenData.tokenSize.width
            };
            const update = {
                ...baseUpdate,
                texture: {
                    src: this.characterTokenData.tokenImg
                },
                ring: {
                    enabled: this.characterTokenData.usesDynamicToken,
                    subject: {
                        texture: this.characterTokenData.tokenRingImg
                    }
                }
            };

            const updateToken = token => ({
                ...baseUpdate,
                'texture': {
                    enabled: this.characterTokenData.usesDynamicToken,
                    src: token.flags.daggerheart?.beastformTokenImg ?? this.characterTokenData.tokenImg
                },
                'ring': {
                    subject: {
                        texture:
                            token.flags.daggerheart?.beastformSubjectTexture ?? this.characterTokenData.tokenRingImg
                    }
                },
                'flags.daggerheart': { '-=beastformTokenImg': null, '-=beastformSubjectTexture': null }
            });

            await updateActorTokens(this.parent.parent, update, updateToken);

            await this.parent.parent.deleteEmbeddedDocuments('Item', this.featureIds);
            await this.parent.parent.deleteEmbeddedDocuments('ActiveEffect', this.effectIds);
        }
    }
}

class HordeEffect extends BaseEffect {}

const config$2 = {
    base: BaseEffect,
    beastform: BeastformEffect,
    horde: HordeEffect
};

var _module$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaseEffect: BaseEffect,
    BeastformEffect: BeastformEffect,
    HordeEffect: HordeEffect,
    config: config$2
});

class DHAbilityUse extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            origin: new fields.StringField({}),
            img: new fields.StringField({}),
            name: new fields.StringField({}),
            description: new fields.StringField({}),
            actions: new fields.ArrayField(
                new fields.ObjectField({
                    name: new fields.StringField({}),
                    damage: new fields.SchemaField({
                        type: new fields.StringField({}),
                        value: new fields.StringField({})
                    }),
                    healing: new fields.SchemaField({
                        type: new fields.StringField({}),
                        value: new fields.StringField({})
                    }),
                    cost: new fields.SchemaField({
                        type: new fields.StringField({}),
                        value: new fields.NumberField({})
                    }),
                    target: new fields.SchemaField({
                        type: new fields.StringField({ nullable: true })
                    })
                })
            )
        };
    }
}

class DHGroupRoll extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            leader: new fields.EmbeddedDataField(GroupRollMemberField),
            members: new fields.ArrayField(new fields.EmbeddedDataField(GroupRollMemberField))
        };
    }

    get totalModifier() {
        return this.members.reduce((acc, m) => {
            if (m.manualSuccess === null) return acc;

            return acc + (m.manualSuccess ? 1 : -1);
        }, 0);
    }
}

class GroupRollMemberField extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            actor: new fields.ObjectField(),
            trait: new fields.StringField({ choices: abilities }),
            difficulty: new fields.StringField(),
            result: new fields.ObjectField({ nullable: true, initial: null }),
            manualSuccess: new fields.BooleanField({ nullable: true, initial: null })
        };
    }

    /* Can be expanded if we handle automation of success/failure */
    get success() {
        return manualSuccess;
    }
}

class DHSystemMessage extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            useTitle: new fields.BooleanField({ initial: true })
        };
    }
}

const config$1 = {
    abilityUse: DHAbilityUse,
    adversaryRoll: DHActorRoll,
    damageRoll: DHActorRoll,
    dualityRoll: DHActorRoll,
    groupRoll: DHGroupRoll,
    systemMessage: DHSystemMessage
};

var _modules = /*#__PURE__*/Object.freeze({
    __proto__: null,
    config: config$1
});

const fields$a = foundry.data.fields;

class CostField extends fields$a.ArrayField {
    /**
     * Action Workflow order
     */
    static order = 150;

    /** @inheritDoc */
    constructor(options = {}, context = {}) {
        const element = new fields$a.SchemaField({
            key: new fields$a.StringField({
                nullable: false,
                required: true,
                initial: 'hope'
            }),
            itemId: new fields$a.StringField({ nullable: true, initial: null }),
            value: new fields$a.NumberField({ nullable: true, initial: 1, min: 0 }),
            scalable: new fields$a.BooleanField({ initial: false }),
            step: new fields$a.NumberField({ nullable: true, initial: null }),
            consumeOnSuccess: new fields$a.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.consumeOnSuccess.label'
            })
        });
        super(element, options, context);
    }

    /**
     * Cost Consumption Action Workflow part.
     * Consume configured action resources.
     * Must be called within Action context or similar.
     * @param {object} config                   Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @param {boolean} [successCost=false]     Consume only resources configured as "On Success only" if not already consumed.
     */
    static async execute(config, successCost = false) {
        const actor = this.actor.system.partner ?? this.actor,
            usefulResources = {
                ...foundry.utils.deepClone(actor.system.resources),
                fear: {
                    value: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear),
                    max: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear,
                    reversed: false
                }
            };

        if (this.parent?.parent) {
            for (var cost of config.costs) {
                if (cost.itemId) {
                    usefulResources[cost.key] = {
                        value: cost.value,
                        target: this.parent.parent,
                        itemId: cost.itemId
                    };
                }
            }
        }

        const resources = CostField.getRealCosts(config.costs)
            .filter(
                c =>
                    (!successCost && (!c.consumeOnSuccess || config.roll?.success)) ||
                    (successCost && c.consumeOnSuccess)
            )
            .reduce((a, c) => {
                const resource = usefulResources[c.key];
                if (resource) {
                    a.push({
                        key: c.key,
                        value: (c.total ?? c.value) * (resource.isReversed ? 1 : -1),
                        target: resource.target,
                        itemId: resource.itemId
                    });
                    return a;
                }
            }, []);

        await actor.modifyResource(resources);
    }

    /**
     * Update Action Workflow config object.
     * Must be called within Action context or similar.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @returns {boolean}       Return false if fast-forwarded and no more uses.
     */
    prepareConfig(config) {
        const costs = this.cost?.length ? foundry.utils.deepClone(this.cost) : [];
        config.costs = CostField.calcCosts.call(this, costs);
        const hasCost = CostField.hasCost.call(this, config.costs);
        if (config.dialog.configure === false && !hasCost) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.insufficientResources'));
            return hasCost;
        }
    }

    /**
     *
     * Must be called within Action context.
     * @param {*} costs
     * @returns
     */
    static calcCosts(costs) {
        const resources = CostField.getResources.call(this, costs);
        let filteredCosts = costs;
        if (this.parent?.metadata.isQuantifiable && this.parent.consumeOnUse === false) {
            filteredCosts = filteredCosts.filter(c => c.key !== 'quantity');
        }

        return filteredCosts.map(c => {
            c.scale = c.scale ?? 0;
            c.step = c.step ?? 1;
            c.total = c.value + c.scale * c.step;
            c.enabled = c.hasOwnProperty('enabled') ? c.enabled : true;
            c.max =
                c.key === 'fear'
                    ? game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear)
                    : resources[c.key].isReversed
                      ? resources[c.key].max - resources[c.key].value
                      : resources[c.key].value;
            if (c.scalable) c.maxStep = Math.floor((c.max - c.value) / c.step);
            return c;
        });
    }

    /**
     * Check if the current Actor currently has all needed resources.
     * Must be called within Action context.
     * @param {*} costs
     * @returns {boolean}
     */
    static hasCost(costs) {
        const realCosts = CostField.getRealCosts.call(this, costs),
            hasFearCost = realCosts.findIndex(c => c.key === 'fear');

        if (hasFearCost > -1) {
            const fearCost = realCosts.splice(hasFearCost, 1)[0];
            if (
                !game.user.isGM ||
                fearCost.total > game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear)
            )
                return false;
        }

        /* isReversed is a sign that the resource is inverted, IE it counts upwards instead of down */
        const resources = CostField.getResources.call(this, realCosts);
        return realCosts.reduce(
            (a, c) =>
                !resources[c.key]
                    ? a
                    : a && resources[c.key].isReversed
                      ? resources[c.key].value + (c.total ?? c.value) <= resources[c.key].max
                      : resources[c.key]?.value >= (c.total ?? c.value),
            true
        );
    }

    /**
     * Get all Actor resources + parent Item potential one.
     * Must be called within Action context.
     * @param {*} costs
     * @returns
     */
    static getResources(costs) {
        const actorResources = foundry.utils.deepClone(this.actor.system.resources);
        if (this.actor.system.partner)
            actorResources.hope = foundry.utils.deepClone(this.actor.system.partner.system.resources.hope);
        const itemResources = {};
        for (let itemResource of costs) {
            if (itemResource.itemId) {
                itemResources[itemResource.key] = CostField.getItemIdCostResource.bind(this)(itemResource);
            }
        }

        return {
            ...actorResources,
            ...itemResources
        };
    }

    static getItemIdCostResource(itemResource) {
        switch (itemResource.key) {
            case CONFIG.DH.GENERAL.itemAbilityCosts.resource.id:
                return {
                    value: this.parent.resource.value ?? 0,
                    max: CostField.formatMax.call(this, this.parent?.resource?.max)
                };
            case CONFIG.DH.GENERAL.itemAbilityCosts.quantity.id:
                return {
                    value: this.parent.quantity ?? 0,
                    max: this.parent.quantity ?? 0
                };
            default:
                return { value: 0, max: 0 };
        }
    }

    static getItemIdCostUpdate(r) {
        switch (r.key) {
            case CONFIG.DH.GENERAL.itemAbilityCosts.resource.id:
                return {
                    path: 'system.resource.value',
                    value: r.target.system.resource.value + r.value
                };
            case CONFIG.DH.GENERAL.itemAbilityCosts.quantity.id:
                return {
                    path: 'system.quantity',
                    value: r.target.system.quantity + r.value
                };
            default:
                return { path: '', value: undefined };
        }
    }

    /**
     *
     * @param {*} costs
     * @returns
     */
    static getRealCosts(costs) {
        const cloneCosts = foundry.utils.deepClone(costs),
            realCosts = cloneCosts?.length ? cloneCosts.filter(c => c.enabled) : [];
        let mergedCosts = [];
        realCosts.forEach(c => {
            const getCost = Object.values(mergedCosts).find(gc => gc.key === c.key);
            if (getCost) getCost.total += c.total;
            else mergedCosts.push(c);
        });
        return mergedCosts;
    }

    /**
     * Format scalable max cost, inject Action datas if it's a formula.
     * Must be called within Action context.
     * @param {number|string} max   Configured maximum for that resource.
     * @returns {number}            The max cost value.
     */
    static formatMax(max) {
        max ??= 0;
        if (isNaN(max)) {
            const roll = Roll.replaceFormulaData(max, this.getRollData());
            max = roll.total;
        }
        return Number(max);
    }
}

const fields$9 = foundry.data.fields;

class CountdownField extends fields$9.ArrayField {
    constructor(options = {}, context = {}) {
        const element = new fields$9.SchemaField({
            ...game.system.api.data.countdowns.DhCountdown.defineSchema(),
            type: new fields$9.StringField({
                required: true,
                choices: CONFIG.DH.GENERAL.countdownBaseTypes,
                initial: CONFIG.DH.GENERAL.countdownBaseTypes.encounter.id,
                label: 'DAGGERHEART.GENERAL.type'
            }),
            name: new fields$9.StringField({
                required: true,
                initial: game.i18n.localize('DAGGERHEART.APPLICATIONS.Countdown.newCountdown'),
                label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.name.label'
            }),
            defaultOwnership: new fields$9.NumberField({
                required: true,
                choices: CONFIG.DH.GENERAL.simpleOwnershiplevels,
                initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT,
                label: 'DAGGERHEART.ACTIONS.Config.countdown.defaultOwnership'
            })
        });
        super(element, options, context);
    }

    /**
     * Countdown Action Workflow part.
     * Must be called within Action context or similar. Requires a GM online to edit the game setting for countdowns.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    static async execute(config) {
        const noGM = !game.users.find(x => x.isGM && x.active);
        if (noGM) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.gmRequired'));
            return;
        }

        const data = { countdowns: {} };
        const countdownMessages = [];
        for (let countdown of config.countdowns) {
            let startFormula = countdown.progress.startFormula ? countdown.progress.startFormula : null;
            let countdownStart = startFormula ?? '1';
            if (startFormula) {
                const roll = await new Roll(startFormula).roll();
                if (roll.dice.length > 0) {
                    countdownStart = roll.total;
                    const message = await roll.toMessage();
                    countdownMessages.push(message);
                } else {
                    startFormula = null;
                }
            }

            data.countdowns[foundry.utils.randomID()] = {
                ...countdown,
                progress: {
                    ...countdown.progress,
                    current: countdownStart,
                    start: countdownStart,
                    startFormula
                }
            };
        }

        if (game.modules.get('dice-so-nice')?.active) {
            await Promise.all(
                countdownMessages.map(message => {
                    return game.dice3d.waitFor3DAnimationByMessageID(message.id);
                })
            );
        }

        await emitAsGM(
            GMUpdateEvent.UpdateCountdowns,
            async () => {
                const countdownSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
                await countdownSetting.updateSource(data);
                await game.settings.set(
                    CONFIG.DH.id,
                    CONFIG.DH.SETTINGS.gameSettings.Countdowns,
                    countdownSetting.toObject()
                ),
                    game.socket.emit(`system.${CONFIG.DH.id}`, {
                        action: socketEvent.Refresh,
                        data: { refreshType: RefreshType.Countdown }
                    });
                Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.Countdown });
            },
            data,
            null,
            {
                refreshType: RefreshType.Countdown
            }
        );
    }

    /**
     * Update Action Workflow config object.
     * Must be called within Action context.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    prepareConfig(config) {
        config.countdowns = this.countdown;
        return config;
    }
}

const fields$8 = foundry.data.fields;

class UsesField extends fields$8.SchemaField {
    /**
     * Action Workflow order
     */
    static order = 160;

    /** @inheritDoc */
    constructor(options = {}, context = {}) {
        const usesFields = {
            value: new fields$8.NumberField({ nullable: true, initial: null }),
            max: new FormulaField({ nullable: true, initial: null, deterministic: true }),
            recovery: new fields$8.StringField({
                choices: CONFIG.DH.GENERAL.refreshTypes,
                initial: null,
                nullable: true
            }),
            consumeOnSuccess: new fields$8.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.consumeOnSuccess.label'
            })
        };
        super(usesFields, options, context);
    }

    /**
     * Uses Consumption Action Workflow part.
     * Increment Action spent uses by 1.
     * Must be called within Action context or similar or similar.
     * @param {object} config                   Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @param {boolean} [successCost=false]     Consume only resources configured as "On Success only" if not already consumed.
     */
    static async execute(config, successCost = false) {
        if (
            config.uses?.enabled &&
            ((!successCost && (!config.uses?.consumeOnSuccess || config.roll?.success)) ||
                (successCost && config.uses?.consumeOnSuccess))
        )
            this.update({ 'uses.value': this.uses.value + 1 });
    }

    /**
     * Update Action Workflow config object.
     * Must be called within Action context.
     * @param {object} config   Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @returns {boolean}       Return false if fast-forwarded and no more uses.
     */
    prepareConfig(config) {
        const uses = this.uses?.max ? foundry.utils.deepClone(this.uses) : null;
        if (uses && !uses.value) uses.value = 0;
        config.uses = uses;
        const hasUses = UsesField.hasUses.call(this, config.uses);
        if (config.dialog.configure === false && !hasUses) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.actionNoUsesRemaining'));
            return hasUses;
        }
    }

    /**
     * Prepare Uses object for Action Workflow
     * Must be called within Action context.
     * @param {object} uses
     * @returns {object}
     */
    static calcUses(uses) {
        if (!uses) return null;
        return {
            ...uses,
            remaining: this.remainingUses,
            enabled: uses.hasOwnProperty('enabled') ? uses.enabled : true
        };
    }

    /**
     * Check if the Action still get atleast one unspent uses.
     * Must be called within Action context.
     * @param {*} uses
     * @returns {boolean}
     */
    static hasUses(uses) {
        if (!uses) return true;
        let max = uses.max ?? 0;
        if (isNaN(max)) {
            const roll = new Roll(Roll.replaceFormulaData(uses.max, this.getRollData())).evaluateSync();
            max = roll.total;
        }
        return (uses.hasOwnProperty('enabled') && !uses.enabled) || uses.value + 1 <= max;
    }
}

const fields$7 = foundry.data.fields;

class RangeField extends fields$7.StringField {
    /** @inheritDoc */
    constructor(context = {}) {
        const options = {
            choices: CONFIG.DH.GENERAL.range,
            required: false,
            blank: true,
            label: 'DAGGERHEART.GENERAL.range'
        };
        super(options, context);
    }

    /**
     * Update Action Workflow config object.
     * NOT YET IMPLEMENTED.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    prepareConfig(config) {
        return;
    }
}

const fields$6 = foundry.data.fields;

class TargetField extends fields$6.SchemaField {
    /** @inheritDoc */
    constructor(options = {}, context = {}) {
        const targetFields = {
            type: new fields$6.StringField({
                choices: CONFIG.DH.GENERAL.targetTypes,
                initial: CONFIG.DH.GENERAL.targetTypes.any.id,
                nullable: true,
                blank: true
            }),
            amount: new fields$6.NumberField({ nullable: true, initial: null, integer: true, min: 0 })
        };
        super(targetFields, options, context);
    }

    /**
     * Update Action Workflow config object.
     * Must be called within Action context.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    prepareConfig(config) {
        if (!this.target?.type) return (config.targets = []);
        config.hasTarget = true;
        let targets;
        // If the Action is configured as self-targeted, set targets as the owner. Probably better way than to fallback to getDependentTokens
        if (this.target?.type === CONFIG.DH.GENERAL.targetTypes.self.id)
            targets = [this.actor.token ?? this.actor.prototypeToken];
        else {
            targets = Array.from(game.user.targets);
            if (this.target.type !== CONFIG.DH.GENERAL.targetTypes.any.id) {
                targets = targets.filter(target => TargetField.isTargetFriendly(this.actor, target, this.target.type));
                if (this.target.amount && targets.length > this.target.amount) targets = [];
            }
        }
        config.targets = targets.map(t => TargetField.formatTarget.call(this, t));
        const hasTargets = TargetField.checkTargets.call(this, this.target.amount, config.targets);
        if (config.dialog.configure === false && !hasTargets) {
            ui.notifications.warn('Too many targets selected for that actions.');
            return hasTargets;
        }
    }

    /**
     * Check if the number of selected targets respect the amount set in the Action.
     * NOT YET IMPLEMENTED. Will be with Target Picker.
     * @param {number} amount   Max amount of targets configured in the action.
     * @param {*[]} targets     Array of targeted tokens.
     * @returns {boolean}       If the amount of targeted tokens does not exceed action configured one.
     */
    static checkTargets(amount, targets) {
        return true;
        // return !amount || (targets.length > amount);
    }

    /**
     * Compare 2 Actors disposition between each other
     * @param {*} actor         First actor document.
     * @param {*} target        Second actor document.
     * @param {string} type     Disposition id to compare (friendly/hostile).
     * @returns {boolean}       If both actors respect the provided type.
     */
    static isTargetFriendly(actor, target, type) {
        const actorDisposition = actor.token ? actor.token.disposition : actor.prototypeToken.disposition,
            targetDisposition = target.document.disposition;
        return (
            (type === CONFIG.DH.GENERAL.targetTypes.friendly.id && actorDisposition === targetDisposition) ||
            (type === CONFIG.DH.GENERAL.targetTypes.hostile.id && actorDisposition + targetDisposition === 0)
        );
    }

    /**
     * Format actor to useful datas for Action roll workflow.
     * @param {*} token     Token object to format.
     * @returns {*}         Formatted Actor.
     */
    static formatTarget(token) {
        return {
            id: token.id,
            actorId: token.actor.uuid,
            name: token.actor.name,
            img: token.actor.img,
            difficulty: token.actor.system.difficulty,
            evasion: token.actor.system.evasion,
            saved: {
                value: null,
                success: null
            }
        };
    }
}

const fields$5 = foundry.data.fields;

class EffectsField extends fields$5.ArrayField {
    /**
     * Action Workflow order
     */
    static order = 100;

    /** @inheritDoc */
    constructor(options = {}, context = {}) {
        const element = new fields$5.SchemaField({
            _id: new fields$5.DocumentIdField(),
            onSave: new fields$5.BooleanField({ initial: false })
        });
        super(element, options, context);
    }

    /**
     * Apply Effects Action Workflow part.
     * Must be called within Action context or similar.
     * @param {object} config                    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @param {object[]} [targets=null]     Array of targets to override pre-selected ones.
     * @param {boolean} [force=false]       If the method should be executed outside of Action workflow, for ChatMessage button for example.
     */
    static async execute(config, targets = null, force = false) {
        if (!config.hasEffect) return;
        let message = config.message ?? ui.chat.collection.get(config.parent?._id);
        if (!message) {
            const roll = new CONFIG.Dice.daggerheart.DHRoll('');
            roll._evaluated = true;
            message = config.message = await CONFIG.Dice.daggerheart.DHRoll.toMessage(roll, config);
        }
        if (EffectsField.getAutomation() || force) {
            targets ??= (message.system?.targets ?? config.targets).filter(t => !config.hasRoll || t.hit);
            await emitAsGM(GMUpdateEvent.UpdateEffect, EffectsField.applyEffects.bind(this), targets, this.uuid);
            // EffectsField.applyEffects.call(this, config.targets.filter(t => !config.hasRoll || t.hit));
        }
    }

    /**
     * Apply Action Effects to a list of Targets
     * Must be called within Action context or similar.
     * @param {object[]} targets Array of formatted targets
     */
    static async applyEffects(targets) {
        if (!this.effects?.length || !targets?.length) return;

        const conditions = CONFIG.DH.GENERAL.conditions();
        let effects = this.effects;
        const messageTargets = [];
        targets.forEach(async baseToken => {
            if (this.hasSave && baseToken.saved.success === true) effects = this.effects.filter(e => e.onSave === true);
            if (!effects.length) return;

            const token =
                canvas.tokens.get(baseToken.id) ?? foundry.utils.fromUuidSync(baseToken.actorId).prototypeToken;
            if (!token) return;

            const messageToken = token.document ?? token;
            const conditionImmunities = messageToken.actor.system.rules.conditionImmunities ?? {};
            messageTargets.push({
                token: messageToken,
                conditionImmunities: Object.values(conditionImmunities).some(x => x)
                    ? game.i18n.format('DAGGERHEART.UI.Chat.effectSummary.immunityTo', {
                          immunities: Object.keys(conditionImmunities)
                              .filter(x => conditionImmunities[x])
                              .map(x => game.i18n.localize(conditions[x].name))
                              .join(', ')
                      })
                    : null
            });

            effects.forEach(async e => {
                const effect = this.item.effects.get(e._id);
                if (!token.actor || !effect) return;
                await EffectsField.applyEffect(effect, token.actor);
            });
        });

        if (messageTargets.length === 0) return;

        const summaryMessageSettings = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.Automation
        ).summaryMessages;
        if (!summaryMessageSettings.effects) return;

        const cls = getDocumentClass('ChatMessage');
        const msg = {
            type: 'systemMessage',
            user: game.user.id,
            speaker: cls.getSpeaker(),
            title: game.i18n.localize('DAGGERHEART.UI.Chat.effectSummary.title'),
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/effectSummary.hbs',
                {
                    effects: this.effects.map(e => this.item.effects.get(e._id)),
                    targets: messageTargets
                }
            )
        };

        cls.create(msg);
    }

    /**
     * Apply an Effect to a target or enable it if already on it
     * @param {object} effect   Effect object containing ActiveEffect UUID
     * @param {object} actor    Actor Document
     */
    static async applyEffect(effect, actor) {
        const existingEffect = actor.effects.find(e => e.origin === effect.uuid);
        if (existingEffect) {
            return effect.update(
                foundry.utils.mergeObject({
                    ...effect.constructor.getInitialDuration(),
                    disabled: false
                })
            );
        }

        // Otherwise, create a new effect on the target
        const effectData = foundry.utils.mergeObject({
            ...effect.toObject(),
            disabled: false,
            transfer: false,
            origin: effect.uuid
        });
        await ActiveEffect.implementation.create(effectData, { parent: actor });
    }

    /**
     * Return the automation setting for execute method for current user role
     * @returns {boolean} If execute should be triggered automatically
     */
    static getAutomation() {
        return (
            (game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.effect.gm) ||
            (!game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.effect.players)
        );
    }
}

const fields$4 = foundry.data.fields;

class SaveField extends fields$4.SchemaField {
    /**
     * Action Workflow order
     */
    static order = 50;

    /** @inheritDoc */
    constructor(options = {}, context = {}) {
        const saveFields = {
            trait: new fields$4.StringField({
                nullable: true,
                initial: null,
                choices: CONFIG.DH.ACTOR.abilities
            }),
            difficulty: new fields$4.NumberField({ nullable: true, initial: null, integer: true, min: 0 }),
            damageMod: new fields$4.StringField({
                initial: CONFIG.DH.ACTIONS.damageOnSave.none.id,
                choices: CONFIG.DH.ACTIONS.damageOnSave,
                nullable: false,
                required: true
            })
        };
        super(saveFields, options, context);
    }

    /**
     * Reaction Roll Action Workflow part.
     * Must be called within Action context or similar.
     * @param {object} config                    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     * @param {object[]} [targets=null]     Array of targets to override pre-selected ones.
     * @param {boolean} [force=false]       If the method should be executed outside of Action workflow, for ChatMessage button for example.
     */
    static async execute(config, targets = null, force = false) {
        if (!config.hasSave) return;
        let message = config.message ?? ui.chat.collection.get(config.parent?._id);

        if (!message) {
            const roll = new CONFIG.Dice.daggerheart.DHRoll('');
            roll._evaluated = true;
            message = config.message = await CONFIG.Dice.daggerheart.DHRoll.toMessage(roll, config);
        }
        if (SaveField.getAutomation() !== CONFIG.DH.SETTINGS.actionAutomationChoices.never.id || force) {
            targets ??= config.targets.filter(t => !config.hasRoll || t.hit);
            await SaveField.rollAllSave.call(this, targets, config.event, message);
        } else return;
    }

    /**
     * Roll a Reaction Roll for all targets. Send a query to the owner if the User is not.
     * Must be called within Action context.
     * @param {object[]} targets        Array of formatted targets.
     * @param {Event} event             Triggering event
     * @param {ChatMessage} message     The ChatMessage the triggered button comes from.
     */
    static async rollAllSave(targets, event, message) {
        if (!targets) return;
        return new Promise(resolve => {
            const aPromise = [];
            targets.forEach(target => {
                aPromise.push(
                    new Promise(async subResolve => {
                        const actor = fromUuidSync(target.actorId);
                        if (actor) {
                            const rollSave =
                                game.user === actor.owner
                                    ? SaveField.rollSave.call(this, actor, event)
                                    : actor.owner.query('reactionRoll', {
                                          actionId: this.uuid,
                                          actorId: actor.uuid,
                                          event,
                                          message
                                      });
                            const result = await rollSave;
                            await SaveField.updateSaveMessage.call(this, result, message, target.id);
                            subResolve();
                        } else subResolve();
                    })
                );
            });
            Promise.all(aPromise).then(result => resolve());
        });
    }

    /**
     * Roll a Reaction Roll for the specified Actor against the Action difficulty.
     * Must be called within Action context.
     * @param {*} actor         Actor document
     * @param {Event} event     Triggering event
     * @returns {object}        Actor diceRoll config result.
     */
    static async rollSave(actor, event) {
        if (!actor) return;
        const title = actor.isNPC
                ? game.i18n.localize('DAGGERHEART.GENERAL.reactionRoll')
                : game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                      ability: game.i18n.localize(abilities[this.save.trait]?.label)
                  }),
            rollConfig = {
                event,
                title,
                roll: {
                    trait: this.save.trait,
                    difficulty: this.save.difficulty ?? this.actor?.baseSaveDifficulty,
                    type: 'trait'
                },
                actionType: 'reaction',
                hasRoll: true,
                data: actor.getRollData()
            };
        if (SaveField.getAutomation() === CONFIG.DH.SETTINGS.actionAutomationChoices.always.id)
            rollConfig.dialog = { configure: false };
        return actor.diceRoll(rollConfig);
    }

    /**
     * Update a Roll ChatMessage for a token according to his Reaction Roll result.
     * @param {object} result        Result from the Reaction Roll
     * @param {object} message       ChatMessage to update
     * @param {string} targetId      Token ID
     */
    static async updateSaveMessage(result, message, targetId) {
        if (!result) return;
        const updateMsg = async function (message, targetId, result) {
            // setTimeout(async () => {
            const chatMessage = ui.chat.collection.get(message._id),
                changes = {
                    flags: {
                        [game.system.id]: {
                            reactionRolls: {
                                [targetId]: {
                                    result: result.roll.total,
                                    success: result.roll.success
                                }
                            }
                        }
                    }
                };
            await chatMessage.update(changes);
            // }, 100);
        };
        if (game.modules.get('dice-so-nice')?.active)
            game.dice3d
                .waitFor3DAnimationByMessageID(result.message.id ?? result.message._id)
                .then(async () => await updateMsg(message, targetId, result));
        else await updateMsg(message, targetId, result);
    }

    /**
     * Return the automation setting for execute method for current user role
     * @returns {string} Id from settingsConfig.mjs actionAutomationChoices
     */
    static getAutomation() {
        return (
            (game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.save.gm) ||
            (!game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.save.players)
        );
    }

    /**
     * Send a query to an Actor owner to roll a Reaction Roll then send back the result.
     * @param {object} param0
     * @param {string} param0.actionId         Action ID
     * @param {string} param0.actorId          Actor ID
     * @param {Event} param0.event             Triggering event
     * @param {ChatMessage} param0.message     Chat Message to update
     * @returns
     */
    static rollSaveQuery({ actionId, actorId, event, message }) {
        return new Promise(async (resolve, reject) => {
            const actor = await fromUuid(actorId),
                action = await fromUuid(actionId);
            if (!actor || !actor?.isOwner) reject();
            SaveField.rollSave.call(action, actor, event, message).then(result => resolve(result));
        });
    }
}

const fields$3 = foundry.data.fields;

class BeastformField extends fields$3.SchemaField {
    /**
     * Action Workflow order
     */
    static order = 90;

    constructor(options = {}, context = {}) {
        const beastformFields = {
            tierAccess: new fields$3.SchemaField({
                exact: new fields$3.NumberField({
                    integer: true,
                    nullable: true,
                    initial: null,
                    choices: () => {
                        const settingsTiers = game.settings.get(
                            CONFIG.DH.id,
                            CONFIG.DH.SETTINGS.gameSettings.LevelTiers
                        ).tiers;
                        return Object.values(settingsTiers).reduce(
                            (acc, tier) => {
                                acc[tier.tier] = game.i18n.localize(tier.name);
                                return acc;
                            },
                            { 1: game.i18n.localize('DAGGERHEART.GENERAL.Tiers.1') }
                        );
                    },
                    hint: 'DAGGERHEART.ACTIONS.Config.beastform.exactHint'
                })
            })
        };
        super(beastformFields, options, context);
    }

    /**
     * Beastform Transformation Action Workflow part.
     * Must be called within Action context or similar.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    static async execute(config) {
        const { selected, evolved, hybrid } = await BeastformDialog.configure(config, this.item);
        if (!selected) return false;

        return await BeastformField.transform.call(this, selected, evolved, hybrid);
    }

    /**
     * Update Action Workflow config object.
     * Must be called within Action context.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    prepareConfig(config) {
        if (this.actor.effects.find(x => x.type === 'beastform')) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformAlreadyApplied'));
            return false;
        }

        const settingsTiers = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers;
        const actorLevel = this.actor.system.levelData.level.current;
        const actorTier =
            Object.values(settingsTiers).find(
                tier => actorLevel >= tier.levels.start && actorLevel <= tier.levels.end
            ) ?? 1;

        config.tierLimit = this.beastform.tierAccess.exact ?? actorTier;
    }

    /**
     * TODO by Harry
     * @param {*} selectedForm
     * @param {*} evolvedData
     * @param {*} hybridData
     * @returns
     */
    static async transform(selectedForm, evolvedData, hybridData) {
        const formData = evolvedData?.form ? evolvedData.form.toObject() : selectedForm;
        const beastformEffect = formData.effects.find(x => x.type === 'beastform');
        if (!beastformEffect) {
            ui.notifications.error('DAGGERHEART.UI.Notifications.beastformMissingEffect');
            return false;
        }

        if (evolvedData?.form) {
            const evolvedForm = selectedForm.effects.find(x => x.type === 'beastform');
            if (!evolvedForm) {
                ui.notifications.error('DAGGERHEART.UI.Notifications.beastformMissingEffect');
                return false;
            }

            beastformEffect.changes = [...beastformEffect.changes, ...evolvedForm.changes];
            formData.system.features = [...formData.system.features, ...selectedForm.system.features.map(x => x.uuid)];
        }

        if (selectedForm.system.beastformType === CONFIG.DH.ITEM.beastformTypes.hybrid.id) {
            formData.system.advantageOn = Object.values(hybridData.advantages).reduce((advantages, formCategory) => {
                Object.keys(formCategory).forEach(advantageKey => {
                    advantages[advantageKey] = formCategory[advantageKey];
                });
                return advantages;
            }, {});
            formData.system.features = [
                ...formData.system.features,
                ...Object.values(hybridData.features).flatMap(x => Object.keys(x))
            ];
        }

        this.actor.createEmbeddedDocuments('Item', [formData]);
    }

    /**
     * Remove existing beastform effect and return true if there was one
     * @returns {boolean}
     */
    static async handleActiveTransformations() {
        const beastformEffects = this.actor.effects.filter(x => x.type === 'beastform');
        const existingEffects = beastformEffects.length > 0;
        await this.actor.deleteEmbeddedDocuments(
            'ActiveEffect',
            beastformEffects.map(x => x.id)
        );
        return existingEffects;
    }
}

const fields$2 = foundry.data.fields;

class DHActionRollData extends foundry.abstract.DataModel {
    /** @override */
    static defineSchema() {
        return {
            type: new fields$2.StringField({ nullable: true, initial: null, choices: CONFIG.DH.GENERAL.rollTypes }),
            trait: new fields$2.StringField({
                nullable: true,
                initial: null,
                choices: CONFIG.DH.ACTOR.abilities,
                label: 'DAGGERHEART.GENERAL.Trait.single'
            }),
            difficulty: new fields$2.NumberField({ nullable: true, initial: null, integer: true, min: 0 }),
            bonus: new fields$2.NumberField({ nullable: true, initial: null, integer: true }),
            advState: new fields$2.StringField({
                choices: CONFIG.DH.ACTIONS.advantageState,
                initial: 'neutral',
                nullable: false,
                required: true
            }),
            diceRolling: new fields$2.SchemaField({
                multiplier: new fields$2.StringField({
                    choices: CONFIG.DH.GENERAL.diceSetNumbers,
                    initial: 'prof',
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.multiplier',
                    nullable: false,
                    required: true
                }),
                flatMultiplier: new fields$2.NumberField({
                    nullable: true,
                    initial: 1,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.flatMultiplier'
                }),
                dice: new fields$2.StringField({
                    choices: CONFIG.DH.GENERAL.diceTypes,
                    initial: CONFIG.DH.GENERAL.diceTypes.d6,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.dice',
                    nullable: false,
                    required: true
                }),
                compare: new fields$2.StringField({
                    choices: CONFIG.DH.ACTIONS.diceCompare,
                    nullable: true,
                    initial: null,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.compare'
                }),
                treshold: new fields$2.NumberField({
                    integer: true,
                    nullable: true,
                    initial: null,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.threshold'
                })
            }),
            useDefault: new fields$2.BooleanField({ initial: false })
        };
    }

    getFormula() {
        if (!this.type) return;
        let formula = '';
        switch (this.type) {
            case 'diceSet':
                const multiplier =
                    this.diceRolling.multiplier === 'flat'
                        ? this.diceRolling.flatMultiplier
                        : `@${this.diceRolling.multiplier}`;
                if (this.diceRolling.compare && this.diceRolling.treshold) {
                    formula = `${multiplier}${this.diceRolling.dice}cs${CONFIG.DH.ACTIONS.diceCompare[this.diceRolling.compare].operator}${this.diceRolling.treshold}`;
                } else {
                    formula = `${multiplier}${this.diceRolling.dice}`;
                }
                break;
            default:
                formula = '';
                break;
        }
        return formula;
    }

    getModifier() {
        const modifiers = [];
        if (!this.parent?.actor) return modifiers;
        switch (this.parent.actor.type) {
            case 'companion':
            case 'adversary':
                if (this.type === CONFIG.DH.GENERAL.rollTypes.attack.id)
                    modifiers.push({
                        label: 'Bonus to Hit',
                        value: this.bonus ?? this.parent.actor.system.attack.roll.bonus
                    });
                break;
        }
        return modifiers;
    }

    get rollTrait() {
        if (this.parent?.actor?.type !== 'character') return null;
        switch (this.type) {
            case CONFIG.DH.GENERAL.rollTypes.spellcast.id:
                return this.parent.actor?.system?.spellcastModifierTrait?.key ?? 'agility';
            case CONFIG.DH.GENERAL.rollTypes.attack.id:
            case CONFIG.DH.GENERAL.rollTypes.trait.id:
                return this.useDefault || !this.trait
                    ? (this.parent.item.system.attack?.roll?.trait ?? 'agility')
                    : this.trait;
            default:
                return null;
        }
    }
}

class RollField extends fields$2.EmbeddedDataField {
    /**
     * Action Workflow order
     */
    static order = 10;

    /** @inheritDoc */
    constructor(options, context = {}) {
        super(DHActionRollData, options, context);
    }

    /**
     * Roll Action Workflow part.
     * Must be called within Action context or similar.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    static async execute(config) {
        if (!config.hasRoll) return;
        config = await this.actor.diceRoll(config);
        if (!config) return false;
    }

    /**
     * Update Action Workflow config object.
     * Must be called within Action context.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods.
     */
    prepareConfig(config) {
        if (!config.hasRoll) return;

        config.dialog.configure = RollField.getAutomation() ? !config.dialog.configure : config.dialog.configure;

        const roll = {
            baseModifiers: this.roll.getModifier(),
            label: 'Attack',
            type: this.roll?.type,
            trait: this.roll?.rollTrait,
            difficulty: this.roll?.difficulty,
            formula: this.roll.getFormula(),
            advantage: CONFIG.DH.ACTIONS.advantageState[this.roll.advState].value
        };
        if (this.roll.type === 'diceSet' || !this.hasRoll) roll.lite = true;

        config.roll = roll;
    }

    /**
     * Return the automation setting for execute method for current user role
     * @returns {boolean} If execute should be triggered automatically
     */
    static getAutomation() {
        return (
            (game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.roll.gm) ||
            (!game.user.isGM &&
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).roll.roll.players)
        );
    }
}

const fields$1 = foundry.data.fields;

class MacroField extends fields$1.DocumentUUIDField {
    /**
     * Action Workflow order
     */
    static order = 70;

    /** @inheritDoc */
    constructor(context = {}) {
        super({ type: 'Macro' }, context);
    }

    /**
     * Macro Action Workflow part.
     * Must be called within Action context or similar or similar.
     * @param {object} config    Object that contains workflow datas. Usually made from Action Fields prepareConfig methods. Currently not used.
     */
    static async execute(config) {
        const fixUUID = !this.macro.includes('Macro.') ? `Macro.${this.macro}` : this.macro,
            macro = await fromUuid(fixUUID);
        try {
            if (!macro) throw new Error(`No macro found for the UUID: ${this.macro}.`);
            macro.execute();
        } catch (error) {
            ui.notifications.error(error);
        }
    }
}

var _module$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BeastformField: BeastformField,
    CostField: CostField,
    CountdownField: CountdownField,
    DamageField: DamageField,
    EffectsField: EffectsField,
    MacroField: MacroField,
    RangeField: RangeField,
    RollField: RollField,
    SaveField: SaveField,
    TargetField: TargetField,
    UsesField: UsesField
});

var fields = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActionCollection: ActionCollection,
    ActionFields: _module$2,
    ForeignDocumentUUIDArrayField: ForeignDocumentUUIDArrayField,
    ForeignDocumentUUIDField: ForeignDocumentUUIDField,
    FormulaField: FormulaField,
    MappingField: MappingField
});

class ItemLinkFields extends foundry.data.fields.ArrayField {
    constructor(options, context) {
        super(new ItemLinkField(), options, context);
    }
}

class ItemLinkField extends foundry.data.fields.SchemaField {
    constructor(context) {
        super(
            {
                type: new foundry.data.fields.StringField({ choices: CONFIG.DH.ITEM.featureSubTypes, nullable: true }),
                item: new ForeignDocumentUUIDField({ type: 'Item' })
            },
            context
        );
    }
}

class DHAncestry extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.ancestry',
            type: 'ancestry',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        return {
            ...super.defineSchema(),
            features: new ItemLinkFields()
        };
    }


    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/family-tree.svg';

    /* -------------------------------------------- */

    /**
     * Gets the primary feature.
     * @type {foundry.documents.Item|null} Returns the item of the first feature with type "primary" or null if none is found.
     */
    get primaryFeature() {
        return this.features.find(x => x.type === CONFIG.DH.ITEM.featureSubTypes.primary)?.item;
    }

    /**
     * Gets the secondary feature.
     * @type {foundry.documents.Item|null} Returns the item of the first feature with type "secondary" or null if none is found.
     */
    get secondaryFeature() {
        return this.features.find(x => x.type === CONFIG.DH.ITEM.featureSubTypes.secondary)?.item;
    }
}

class AttachableItem extends BaseDataItem {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            attached: new fields.ArrayField(new fields.DocumentUUIDField({ type: 'Item', nullable: true }))
        };
    }

    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        // Handle equipped status changes for attachment effects
        if (changes.system?.equipped !== undefined && changes.system.equipped !== this.equipped) {
            await this.#handleAttachmentEffectsOnEquipChange(changes.system.equipped);
        }
    }

    async #handleAttachmentEffectsOnEquipChange(newEquippedStatus) {
        const actor = this.parent.parent?.type === 'character' ? this.parent.parent : this.parent.parent?.parent;
        const parentType = this.parent.type;

        if (!actor || !this.attached?.length) {
            return;
        }

        if (newEquippedStatus) {
            // Item is being equipped - add attachment effects
            for (const attachedUuid of this.attached) {
                const attachedItem = await fromUuid(attachedUuid);
                if (attachedItem && attachedItem.effects.size > 0) {
                    await this.#copyAttachmentEffectsToActor({
                        attachedItem,
                        attachedUuid,
                        parentType
                    });
                }
            }
        } else {
            // Item is being unequipped - remove attachment effects
            await this.#removeAllAttachmentEffects(parentType);
        }
    }

    async #copyAttachmentEffectsToActor({ attachedItem, attachedUuid, parentType }) {
        const actor = this.parent.parent;
        if (!actor || !attachedItem.effects.size > 0 || !this.equipped) {
            return [];
        }

        const effectsToCreate = [];
        for (const effect of attachedItem.effects) {
            const effectData = effect.toObject();
            effectData.origin = `${this.parent.uuid}:${attachedUuid}`;

            const attachmentSource = {
                itemUuid: attachedUuid,
                originalEffectId: effect.id
            };
            attachmentSource[`${parentType}Uuid`] = this.parent.uuid;

            effectData.flags = {
                ...effectData.flags,
                [CONFIG.DH.id]: {
                    ...effectData.flags?.[CONFIG.DH.id],
                    [CONFIG.DH.FLAGS.itemAttachmentSource]: attachmentSource
                }
            };
            effectsToCreate.push(effectData);
        }

        if (effectsToCreate.length > 0) {
            return await actor.createEmbeddedDocuments('ActiveEffect', effectsToCreate);
        }

        return [];
    }

    async #removeAllAttachmentEffects(parentType) {
        const actor = this.parent.parent;
        if (!actor) return;

        const parentUuidProperty = `${parentType}Uuid`;
        const effectsToRemove = actor.effects.filter(effect => {
            const attachmentSource = effect.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.itemAttachmentSource);
            return attachmentSource && attachmentSource[parentUuidProperty] === this.parent.uuid;
        });

        if (effectsToRemove.length > 0) {
            await actor.deleteEmbeddedDocuments(
                'ActiveEffect',
                effectsToRemove.map(e => e.id)
            );
        }
    }

    /**
     * Public method for adding an attachment
     */
    async addAttachment(droppedItem) {
        const newUUID = droppedItem.uuid;

        if (this.attached.includes(newUUID)) {
            ui.notifications.warn(`${droppedItem.name} is already attached to this ${this.parent.type}.`);
            return;
        }

        const updatedAttached = [...this.attached, newUUID];
        await this.parent.update({
            'system.attached': updatedAttached
        });

        // Copy effects if equipped
        if (this.equipped && droppedItem.effects.size > 0) {
            await this.#copyAttachmentEffectsToActor({
                attachedItem: droppedItem,
                attachedUuid: newUUID,
                parentType: this.parent.type
            });
        }
    }

    /**
     * Public method for removing an attachment
     */
    async removeAttachment(attachedUuid) {
        await this.parent.update({
            'system.attached': this.attached.filter(uuid => uuid !== attachedUuid)
        });

        // Remove effects
        await this.#removeAttachmentEffects(attachedUuid);
    }

    async #removeAttachmentEffects(attachedUuid) {
        const actor = this.parent.parent;
        if (!actor) return;

        const parentType = this.parent.type;
        const parentUuidProperty = `${parentType}Uuid`;
        const effectsToRemove = actor.effects.filter(effect => {
            const attachmentSource = effect.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.itemAttachmentSource);
            return (
                attachmentSource &&
                attachmentSource[parentUuidProperty] === this.parent.uuid &&
                attachmentSource.itemUuid === attachedUuid
            );
        });

        if (effectsToRemove.length > 0) {
            await actor.deleteEmbeddedDocuments(
                'ActiveEffect',
                effectsToRemove.map(e => e.id)
            );
        }
    }
}

class DHArmor extends AttachableItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.armor',
            type: 'armor',
            hasDescription: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({ required: true, integer: true, initial: 1, min: 1 }),
            equipped: new fields.BooleanField({ initial: false }),
            baseScore: new fields.NumberField({ integer: true, initial: 0 }),
            armorFeatures: new fields.ArrayField(
                new fields.SchemaField({
                    value: new fields.StringField({
                        required: true,
                        choices: CONFIG.DH.ITEM.allArmorFeatures,
                        blank: true
                    }),
                    effectIds: new fields.ArrayField(new fields.StringField({ required: true })),
                    actionIds: new fields.ArrayField(new fields.StringField({ required: true }))
                })
            ),
            marks: new fields.SchemaField({
                value: new fields.NumberField({ initial: 0, integer: true })
            }),
            baseThresholds: new fields.SchemaField({
                major: new fields.NumberField({ integer: true, initial: 0 }),
                severe: new fields.NumberField({ integer: true, initial: 0 })
            })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/chest-armor.svg';

    /* -------------------------------------------- */

    get customActions() {
        return this.actions.filter(
            action => !this.armorFeatures.some(feature => feature.actionIds.includes(action.id))
        );
    }

    /**@inheritdoc */
    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        const changedArmorFeatures = changes.system?.armorFeatures ?? [];
        const removedFeatures = this.armorFeatures.filter(x => changedArmorFeatures.every(y => y.value !== x.value));
        if (changes.system?.armorFeatures) {
            const added = changedArmorFeatures.filter(x => this.armorFeatures.every(y => y.value !== x.value));

            const effectIds = [];
            const actionIds = [];
            for (var feature of removedFeatures) {
                effectIds.push(...feature.effectIds);
                actionIds.push(...feature.actionIds);
            }
            await this.parent.deleteEmbeddedDocuments('ActiveEffect', effectIds);
            changes.system.actions = actionIds.reduce((acc, id) => {
                acc[`-=${id}`] = null;
                return acc;
            }, {});

            const allFeatures = CONFIG.DH.ITEM.allArmorFeatures();
            for (const feature of added) {
                const featureData = allFeatures[feature.value];
                if (featureData.effects?.length > 0) {
                    const embeddedItems = await this.parent.createEmbeddedDocuments(
                        'ActiveEffect',
                        featureData.effects.map(effect => ({
                            ...effect,
                            name: game.i18n.localize(effect.name),
                            description: game.i18n.localize(effect.description)
                        }))
                    );
                    feature.effectIds = embeddedItems.map(x => x.id);
                }

                const newActions = {};
                if (featureData.actions?.length > 0 || featureData.actions?.size > 0) {
                    for (let action of featureData.actions) {
                        const embeddedEffects = await this.parent.createEmbeddedDocuments(
                            'ActiveEffect',
                            (action.effects ?? []).map(effect => ({
                                ...effect,
                                transfer: false,
                                name: game.i18n.localize(effect.name),
                                description: game.i18n.localize(effect.description)
                            }))
                        );
                        feature.effectIds = [...(feature.effectIds ?? []), ...embeddedEffects.map(x => x.id)];

                        const cls = game.system.api.models.actions.actionsTypes[action.type];
                        const actionId = foundry.utils.randomID();
                        newActions[actionId] = new cls(
                            {
                                ...cls.getSourceConfig(this),
                                ...action,
                                type: action.type,
                                _id: actionId,
                                name: game.i18n.localize(action.name),
                                description: game.i18n.localize(action.description),
                                effects: embeddedEffects.map(x => ({ _id: x.id })),
                                systemPath: 'actions'
                            },
                            { parent: this }
                        );
                    }
                }

                changes.system.actions = newActions;
                feature.actionIds = Object.keys(newActions);
            }
        }
    }

    _onUpdate(a, b, c) {
        super._onUpdate(a, b, c);

        if (this.actor?.type === 'character') {
            for (const party of this.actor.parties) {
                party.render();
            }
        }
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            `${game.i18n.localize('DAGGERHEART.ITEMS.Armor.baseScore')}: ${this.baseScore}`,
            `${game.i18n.localize('DAGGERHEART.ITEMS.Armor.baseThresholds.base')}: ${this.baseThresholds.major} / ${this.baseThresholds.severe}`
        ];

        return tags;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        if (this.baseScore)
            labels.push(`${game.i18n.localize('DAGGERHEART.ITEMS.Armor.baseScore')}: ${this.baseScore}`);
        return labels;
    }

    get itemFeatures() {
        return this.armorFeatures;
    }
}

class DHClass extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.class',
            type: 'class',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            domains: new fields.ArrayField(new fields.StringField()),
            classItems: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
            hitPoints: new fields.NumberField({
                required: true,
                integer: true,
                min: 1,
                initial: 5,
                label: 'DAGGERHEART.GENERAL.HitPoints.plural'
            }),
            evasion: new fields.NumberField({ initial: 0, integer: true, label: 'DAGGERHEART.GENERAL.evasion' }),
            features: new ItemLinkFields(),
            subclasses: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
            inventory: new fields.SchemaField({
                take: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
                choiceA: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
                choiceB: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false })
            }),
            characterGuide: new fields.SchemaField({
                suggestedTraits: new fields.SchemaField({
                    agility: new fields.NumberField({ initial: 0, integer: true }),
                    strength: new fields.NumberField({ initial: 0, integer: true }),
                    finesse: new fields.NumberField({ initial: 0, integer: true }),
                    instinct: new fields.NumberField({ initial: 0, integer: true }),
                    presence: new fields.NumberField({ initial: 0, integer: true }),
                    knowledge: new fields.NumberField({ initial: 0, integer: true })
                }),
                suggestedPrimaryWeapon: new ForeignDocumentUUIDField({ type: 'Item' }),
                suggestedSecondaryWeapon: new ForeignDocumentUUIDField({ type: 'Item' }),
                suggestedArmor: new ForeignDocumentUUIDField({ type: 'Item' })
            }),
            backgroundQuestions: new fields.ArrayField(new fields.StringField(), { initial: ['', '', ''] }),
            connections: new fields.ArrayField(new fields.StringField(), { initial: ['', '', ''] }),
            isMulticlass: new fields.BooleanField({ initial: false })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/laurel-crown.svg';

    /* -------------------------------------------- */

    get hopeFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.hope).map(x => x.item);
    }

    get classFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.class).map(x => x.item);
    }

    async _preCreate(data, options, user) {
        if (this.actor?.type === 'character') {
            const levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;
            if (levelupAuto) {
                const path = data.system.isMulticlass ? 'system.multiclass.value' : 'system.class.value';
                if (foundry.utils.getProperty(this.actor, path)) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.classAlreadySelected'));
                    return false;
                }
            } else {
                if (this.actor.system.class.value) {
                    if (this.actor.system.multiclass.value) {
                        ui.notifications.warn(
                            game.i18n.localize('DAGGERHEART.UI.Notifications.multiclassAlreadyPresent')
                        );
                        return false;
                    } else {
                        const selectedDomain =
                            await game.system.api.applications.dialogs.MulticlassChoiceDialog.configure(
                                this.actor,
                                this
                            );
                        if (!selectedDomain) return false;

                        await this.updateSource({ isMulticlass: true, domains: [selectedDomain] });
                    }
                }
            }

            if (!data.system.isMulticlass) {
                const addQuestions = (base, questions) => {
                    return `${base}${questions.map(q => `<p><strong>${q}</strong></p>`).join('<br/>')}`;
                };
                const backgroundQuestions = data.system.backgroundQuestions.filter(x => x);
                const connections = data.system.connections.filter(x => x);
                await this.actor.update({
                    'system.biography': {
                        background: addQuestions(this.actor.system.biography.background, backgroundQuestions),
                        connections: addQuestions(this.actor.system.biography.connections, connections)
                    }
                });
            }
        }

        const allowed = await super._preCreate(data, options, user);
        if (allowed === false) return;
    }

    _onDelete(options, userId) {
        super._onDelete(options, userId);

        if (options.parent?.type === 'character') {
            const path = `system.${this.isMulticlass ? 'multiclass' : 'class'}`;
            foundry.utils.getProperty(options.parent, `${path}.subclass`)?.delete();
        }
    }

    async _preUpdate(changed, options, userId) {
        const allowed = await super._preUpdate(changed, options, userId);
        if (allowed === false) return false;

        if (changed.system?.domains) {
            const maxDomains = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxDomains;
            if (changed.system.domains.length > maxDomains) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.domainMaxReached'));
                return false;
            }
        }

        const paths = [
            'subclasses',
            'characterGuide.suggestedPrimaryWeapon',
            'characterGuide.suggestedSecondaryWeapon',
            'characterGuide.suggestedArmor',
            'inventory.take',
            'inventory.choiceA',
            'inventory.choiceB'
        ];

        for (let path of paths) {
            const currentItems = [].concat(foundry.utils.getProperty(this, path) ?? []);
            const changedItems = [].concat(foundry.utils.getProperty(changed, `system.${path}`) ?? []);
            if (!changedItems.length) continue;

            addLinkedItemsDiff(changedItems, currentItems, options);
        }
    }

    _onUpdate(changed, options, userId) {
        super._onUpdate(changed, options, userId);

        updateLinkedItemApps(options, this.parent.sheet);
    }
}

class DHCommunity extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.community',
            type: 'community',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        return {
            ...super.defineSchema(),
            features: new ForeignDocumentUUIDArrayField({ type: 'Item' })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/village.svg';

}

class DHConsumable extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.consumable',
            type: 'consumable',
            hasDescription: true,
            isQuantifiable: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            consumeOnUse: new fields.BooleanField({ initial: true }),
            destroyOnEmpty: new fields.BooleanField({ initial: true })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/round-potion.svg';
}

class DHDomainCard extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.domainCard',
            type: 'domainCard',
            hasDescription: true,
            hasResource: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            domain: new fields.StringField({
                choices: CONFIG.DH.DOMAIN.allDomains,
                required: true,
                initial: CONFIG.DH.DOMAIN.domains.arcana.id
            }),
            level: new fields.NumberField({ initial: 1, integer: true }),
            recallCost: new fields.NumberField({ initial: 0, integer: true }),
            type: new fields.StringField({
                choices: CONFIG.DH.DOMAIN.cardTypes,
                required: true,
                initial: CONFIG.DH.DOMAIN.cardTypes.ability.id
            }),
            inVault: new fields.BooleanField({ initial: false })
        };
    }

    get domainLabel() {
        const allDomainData = CONFIG.DH.DOMAIN.allDomains();
        return game.i18n.localize(allDomainData[this.domain].label);
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/card-play.svg';

    /* -------------------------------------------- */

    /**@inheritdoc */
    async _preCreate(data, options, user) {
        const allowed = await super._preCreate(data, options, user);
        if (allowed === false) return;

        if (this.actor?.type === 'character') {
            const actorClasses = this.actor.items.filter(x => x.type === 'class');
            if (!actorClasses.length) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noClassSelected'));
                return false;
            }

            if (!actorClasses.some(c => c.system.domains.find(x => x === this.domain))) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.lacksDomain'));
                return false;
            }

            if (this.actor.system.domainCards.total.find(x => x.name === this.parent.name)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.duplicateDomainCard'));
                return false;
            }

            if (!this.actor.system.loadoutSlot.available) {
                data.system.inVault = true;
            }
        }
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            game.i18n.localize(`DAGGERHEART.CONFIG.DomainCardTypes.${this.type}`),
            this.domainLabel,
            `${game.i18n.localize('DAGGERHEART.GENERAL.levelShort')}: ${this.level}`,
            `${game.i18n.localize('DAGGERHEART.ITEMS.DomainCard.recallCost')}: ${this.recallCost}`
        ];

        return tags;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];

        if (this.type) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.DomainCardTypes.${this.type}`));
        if (this.domainLabel) labels.push(this.domainLabel);
        if (this.recallCost) {
            labels.push({
                value: `${this.recallCost}`, //converts the number to a string
                icons: ['fa-bolt']
            });
        }
        return labels;
    }
}

class DHLoot extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.loot',
            type: 'loot',
            hasDescription: true,
            isQuantifiable: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        return {
            ...super.defineSchema()
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/open-treasure-chest.svg';

    /* -------------------------------------------- */
}

class DHSubclass extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.subclass',
            type: 'subclass',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            spellcastingTrait: new fields.StringField({
                choices: CONFIG.DH.ACTOR.abilities,
                integer: false,
                nullable: true,
                initial: null,
                label: 'DAGGERHEART.ITEMS.Subclass.spellcastingTrait'
            }),
            features: new ItemLinkFields(),
            featureState: new fields.NumberField({ required: true, initial: 1, min: 1 }),
            isMulticlass: new fields.BooleanField({ initial: false }),
            linkedClass: new ForeignDocumentUUIDField({ type: 'Item', nullable: true, initial: null })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/laurels.svg';

    /* -------------------------------------------- */

    get foundationFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.foundation).map(x => x.item);
    }

    get specializationFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.specialization).map(x => x.item);
    }

    get masteryFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.mastery).map(x => x.item);
    }

    async _preCreate(data, options, user) {
        if (this.actor?.type === 'character') {
            const dataUuid = data.uuid ?? data._stats.compendiumSource ?? `Item.${data._id}`;
            if (this.actor.system.class.subclass) {
                if (this.actor.system.multiclass.subclass) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.subclassesAlreadyPresent'));
                    return false;
                } else {
                    const multiclass = this.actor.items.find(x => x.type === 'class' && x.system.isMulticlass);
                    if (!multiclass) {
                        ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.missingMulticlass'));
                        return false;
                    }

                    if (multiclass.system.subclasses.every(x => x.uuid !== dataUuid)) {
                        ui.notifications.error(
                            game.i18n.localize('DAGGERHEART.UI.Notifications.subclassNotInMulticlass')
                        );
                        return false;
                    }

                    await this.updateSource({ isMulticlass: true });
                }
            } else {
                const actorClass = this.actor.items.find(x => x.type === 'class' && !x.system.isMulticlass);
                if (!actorClass) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.missingClass'));
                    return false;
                }
                if (actorClass.system.subclasses.every(x => x.uuid !== dataUuid)) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.subclassNotInClass'));
                    return false;
                }
            }
        }

        const allowed = await super._preCreate(data, options, user);
        if (allowed === false) return;
    }
}

class DHWeapon extends AttachableItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.weapon',
            type: 'weapon',
            hasDescription: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                initial: 1,
                min: 1,
                label: 'DAGGERHEART.GENERAL.Tiers.singular'
            }),
            equipped: new fields.BooleanField({ initial: false }),

            //SETTINGS
            secondary: new fields.BooleanField({ initial: false, label: 'DAGGERHEART.ITEMS.Weapon.secondaryWeapon' }),
            burden: new fields.StringField({
                required: true,
                choices: CONFIG.DH.GENERAL.burden,
                initial: 'oneHanded',
                label: 'DAGGERHEART.GENERAL.burden'
            }),
            weaponFeatures: new fields.ArrayField(
                new fields.SchemaField({
                    value: new fields.StringField({
                        required: true,
                        choices: CONFIG.DH.ITEM.allWeaponFeatures,
                        blank: true
                    }),
                    effectIds: new fields.ArrayField(new fields.StringField({ required: true })),
                    actionIds: new fields.ArrayField(new fields.StringField({ required: true }))
                })
            ),
            attack: new ActionField({
                initial: {
                    name: 'Attack',
                    img: 'icons/skills/melee/blood-slash-foam-red.webp',
                    _id: foundry.utils.randomID(),
                    baseAction: true,
                    chatDisplay: false,
                    systemPath: 'attack',
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        trait: 'agility',
                        type: 'attack'
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    multiplier: 'prof',
                                    dice: 'd8'
                                }
                            }
                        ]
                    }
                }
            }),
            rules: new fields.SchemaField({
                attack: new fields.SchemaField({
                    roll: new fields.SchemaField({
                        trait: new fields.StringField({
                            required: true,
                            choices: CONFIG.DH.ACTOR.abilities,
                            nullable: true,
                            initial: null,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.roll.trait.label'
                        })
                    })
                })
            })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/battered-axe.svg';

    /* -------------------------------------------- */

    get actionsList() {
        return [this.attack, ...this.actions];
    }

    get customActions() {
        return this.actions.filter(
            action => !this.weaponFeatures.some(feature => feature.actionIds.includes(action.id))
        );
    }

    prepareDerivedData() {
        this.attack.roll.trait = this.rules.attack.roll.trait ?? this.attack.roll.trait;
    }

    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        const changedWeaponFeatures = changes.system?.weaponFeatures ?? [];
        const removedFeatures = this.weaponFeatures.filter(x => changedWeaponFeatures.every(y => y.value !== x.value));
        if (changes.system?.weaponFeatures) {
            const added = changedWeaponFeatures.filter(x => this.weaponFeatures.every(y => y.value !== x.value));

            const removedEffectsUpdate = [];
            const removedActionsUpdate = [];
            for (let weaponFeature of removedFeatures) {
                removedEffectsUpdate.push(...weaponFeature.effectIds);
                removedActionsUpdate.push(...weaponFeature.actionIds);
            }

            await this.parent.deleteEmbeddedDocuments('ActiveEffect', removedEffectsUpdate);
            changes.system.actions = removedActionsUpdate.reduce((acc, id) => {
                acc[`-=${id}`] = null;
                return acc;
            }, {});

            const allFeatures = CONFIG.DH.ITEM.allWeaponFeatures();
            for (let weaponFeature of added) {
                const featureData = allFeatures[weaponFeature.value];
                if (featureData.effects?.length > 0) {
                    const embeddedItems = await this.parent.createEmbeddedDocuments(
                        'ActiveEffect',
                        featureData.effects.map(effect => ({
                            ...effect,
                            name: game.i18n.localize(effect.name),
                            description: game.i18n.localize(effect.description)
                        }))
                    );
                    weaponFeature.effectIds = embeddedItems.map(x => x.id);
                }

                const newActions = {};
                if (featureData.actions?.length > 0 || featureData.actions?.size > 0) {
                    for (let action of featureData.actions) {
                        const embeddedEffects = await this.parent.createEmbeddedDocuments(
                            'ActiveEffect',
                            (action.effects ?? []).map(effect => ({
                                ...effect,
                                transfer: false,
                                name: game.i18n.localize(effect.name),
                                description: game.i18n.localize(effect.description)
                            }))
                        );
                        weaponFeature.effectIds = [
                            ...(weaponFeature.effectIds ?? []),
                            ...embeddedEffects.map(x => x.id)
                        ];

                        const cls = game.system.api.models.actions.actionsTypes[action.type];
                        const actionId = foundry.utils.randomID();
                        newActions[actionId] = new cls(
                            {
                                ...cls.getSourceConfig(this),
                                ...action,
                                type: action.type,
                                _id: actionId,
                                name: game.i18n.localize(action.name),
                                description: game.i18n.localize(action.description),
                                effects: embeddedEffects.map(x => ({ _id: x.id })),
                                systemPath: 'actions'
                            },
                            { parent: this }
                        );
                    }
                }

                changes.system.actions = newActions;
                weaponFeature.actionIds = Object.keys(newActions);
            }
        }
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const { attack, burden } = this;
        const tags = [
            game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${attack.roll.trait}.name`),
            game.i18n.localize(`DAGGERHEART.CONFIG.Range.${attack.range}.name`),
            game.i18n.localize(`DAGGERHEART.CONFIG.Burden.${burden}`)
        ];

        for (const { value, type } of attack.damage.parts) {
            const parts = value.custom.enabled ? [game.i18n.localize('DAGGERHEART.GENERAL.custom')] : [value.dice];
            if (!value.custom.enabled && value.bonus) parts.push(value.bonus.signedString());

            if (type.size > 0) {
                const typeTags = Array.from(type)
                    .map(t => game.i18n.localize(`DAGGERHEART.CONFIG.DamageType.${t}.abbreviation`))
                    .join(' | ');
                parts.push(` (${typeTags})`); // Add a space in front and put it inside a ().
            }

            tags.push(parts.join(''));
        }

        return tags;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        const { roll, range, damage } = this.attack;

        if (roll.trait) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${roll.trait}.short`));
        if (range) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Range.${range}.short`));

        for (const { value, type } of damage.parts) {
            const str = Roll.replaceFormulaData(value.getFormula(), this.actor?.getRollData() ?? {});

            const icons = Array.from(type)
                .map(t => CONFIG.DH.GENERAL.damageTypes[t]?.icon)
                .filter(Boolean);

            if (icons.length === 0) {
                labels.push(str);
            } else {
                labels.push({ value: str, icons });
            }
        }

        return labels;
    }

    get itemFeatures() {
        return this.weaponFeatures;
    }
}

class DHBeastform extends BaseDataItem {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ITEMS.Beastform'];

    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.beastform',
            type: 'beastform',
            hasDescription: false
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            beastformType: new fields.StringField({
                required: true,
                choices: CONFIG.DH.ITEM.beastformTypes,
                initial: CONFIG.DH.ITEM.beastformTypes.normal.id
            }),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                choices: CONFIG.DH.GENERAL.tiers,
                initial: CONFIG.DH.GENERAL.tiers[1].id
            }),
            tokenImg: new fields.FilePathField({
                initial: 'icons/svg/mystery-man.svg',
                categories: ['IMAGE'],
                wildcard: true,
                base64: false
            }),
            tokenRingImg: new fields.FilePathField({
                initial: 'icons/svg/mystery-man.svg',
                categories: ['IMAGE'],
                wildcard: true,
                base64: false
            }),
            tokenSize: new fields.SchemaField({
                height: new fields.NumberField({ integer: true, min: 1, initial: null, nullable: true }),
                width: new fields.NumberField({ integer: true, min: 1, initial: null, nullable: true })
            }),
            mainTrait: new fields.StringField({
                required: true,
                choices: CONFIG.DH.ACTOR.abilities,
                initial: CONFIG.DH.ACTOR.abilities.agility.id
            }),
            examples: new fields.StringField(),
            advantageOn: new fields.TypedObjectField(
                new fields.SchemaField({
                    value: new fields.StringField()
                })
            ),
            features: new ForeignDocumentUUIDArrayField({ type: 'Item' }),
            evolved: new fields.SchemaField({
                maximumTier: new fields.NumberField({
                    integer: true,
                    choices: CONFIG.DH.GENERAL.tiers
                }),
                mainTraitBonus: new fields.NumberField({
                    required: true,
                    integer: true,
                    min: 0,
                    initial: 0
                })
            }),
            hybrid: new fields.SchemaField({
                maximumTier: new fields.NumberField({
                    integer: true,
                    choices: CONFIG.DH.GENERAL.tiers,
                    label: 'DAGGERHEART.ITEMS.Beastform.FIELDS.evolved.maximumTier.label'
                }),
                beastformOptions: new fields.NumberField({ required: true, integer: true, initial: 2, min: 2 }),
                advantages: new fields.NumberField({ required: true, integer: true, initial: 2, min: 2 }),
                features: new fields.NumberField({ required: true, integer: true, initial: 2, min: 2 })
            })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/wolf-head.svg';

    /* -------------------------------------------- */

    get beastformAttackData() {
        const effect = this.parent.effects.find(x => x.type === 'beastform');
        if (!effect) return null;

        const traitBonus = effect.changes.find(x => x.key === `system.traits.${this.mainTrait}.value`)?.value ?? 0;
        const evasionBonus = effect.changes.find(x => x.key === 'system.evasion')?.value ?? 0;

        const damageDiceIndex = effect.changes.find(x => x.key === 'system.rules.attack.damage.diceIndex');
        const damageDice = damageDiceIndex ? Object.keys(CONFIG.DH.GENERAL.diceTypes)[damageDiceIndex.value] : null;
        const damageBonus = effect.changes.find(x => x.key === 'system.rules.attack.damage.bonus')?.value ?? 0;

        return {
            trait: game.i18n.localize(CONFIG.DH.ACTOR.abilities[this.mainTrait].label),
            traitBonus: traitBonus ? Number(traitBonus).signedString() : '',
            evasionBonus: evasionBonus ? Number(evasionBonus).signedString() : '',
            damageDice: damageDice,
            damageBonus: damageBonus ? `${Number(damageBonus).signedString()}` : ''
        };
    }

    static async getWildcardImage(actor, beastform) {
        const usesDynamicToken = actor.prototypeToken.ring.enabled && beastform.system.tokenRingImg;
        const tokenPath = usesDynamicToken ? beastform.system.tokenRingImg : beastform.system.tokenImg;
        const usesWildcard = tokenPath.includes('*');
        if (usesWildcard) {
            const filePicker = new foundry.applications.apps.FilePicker.implementation(tokenPath);
            const { files } = await foundry.applications.apps.FilePicker.implementation.browse(
                filePicker.activeSource,
                tokenPath,
                {
                    wildcard: true,
                    type: 'image'
                }
            );
            const selectedImage = await game.system.api.applications.dialogs.ImageSelectDialog.configure(
                game.i18n.localize('DAGGERHEART.APPLICATIONS.ImageSelect.title'),
                files
            );
            return { usesDynamicToken, selectedImage };
        }

        return null;
    }

    async _preCreate() {
        if (!this.actor) return;

        if (this.actor.type !== 'character') {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformInapplicable'));
            return false;
        }

        if (this.actor.items.find(x => x.type === 'beastform')) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformAlreadyApplied'));
            return false;
        }

        const beastformFeatures = [];
        for (let featureData of this.features) {
            const feature = await foundry.utils.fromUuid(featureData.uuid);
            beastformFeatures.push(feature.toObject());
        }

        const features = await this.parent.parent.createEmbeddedDocuments('Item', beastformFeatures);

        const extraEffects = await this.parent.parent.createEmbeddedDocuments(
            'ActiveEffect',
            this.parent.effects.filter(x => x.type !== 'beastform').map(x => x.toObject())
        );

        const beastformEffect = this.parent.effects.find(x => x.type === 'beastform');
        await beastformEffect.updateSource({
            changes: [
                ...beastformEffect.changes,
                {
                    key: 'system.advantageSources',
                    mode: 2,
                    value: Object.values(this.advantageOn)
                        .map(x => x.value)
                        .join(', ')
                }
            ],
            system: {
                characterTokenData: {
                    usesDynamicToken: this.parent.parent.prototypeToken.ring.enabled,
                    tokenImg: this.parent.parent.prototypeToken.texture.src,
                    tokenRingImg: this.parent.parent.prototypeToken.ring.subject.texture,
                    tokenSize: {
                        height: this.parent.parent.prototypeToken.height,
                        width: this.parent.parent.prototypeToken.width
                    }
                },
                advantageOn: this.advantageOn,
                featureIds: features.map(x => x.id),
                effectIds: extraEffects.map(x => x.id)
            }
        });

        await this.parent.parent.createEmbeddedDocuments('ActiveEffect', [beastformEffect.toObject()]);

        const prototypeTokenUpdate = {
            height: this.tokenSize.height,
            width: this.tokenSize.width,
            texture: {
                src: this.tokenImg
            },
            ring: {
                subject: {
                    texture: this.tokenRingImg
                }
            }
        };

        const tokenUpdate = token => ({
            ...prototypeTokenUpdate,
            flags: {
                daggerheart: {
                    beastformTokenImg: token.texture.src,
                    beastformSubjectTexture: token.ring.subject.texture
                }
            }
        });

        await updateActorTokens(this.parent.parent, prototypeTokenUpdate, tokenUpdate);

        return false;
    }
}

const config = {
    ancestry: DHAncestry,
    armor: DHArmor,
    attachableItem: AttachableItem,
    class: DHClass,
    community: DHCommunity,
    consumable: DHConsumable,
    domainCard: DHDomainCard,
    feature: DHFeature,
    loot: DHLoot,
    subclass: DHSubclass,
    weapon: DHWeapon,
    beastform: DHBeastform
};

var _module$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHAncestry: DHAncestry,
    DHArmor: DHArmor,
    DHAttachableItem: AttachableItem,
    DHBeastform: DHBeastform,
    DHClass: DHClass,
    DHCommunity: DHCommunity,
    DHConsumable: DHConsumable,
    DHDomainCard: DHDomainCard,
    DHFeature: DHFeature,
    DHLoot: DHLoot,
    DHSubclass: DHSubclass,
    DHWeapon: DHWeapon,
    config: config
});

class DHScene extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            rangeMeasurement: new fields.SchemaField({
                setting: new fields.StringField({
                    choices: CONFIG.DH.GENERAL.sceneRangeMeasurementSetting,
                    initial: CONFIG.DH.GENERAL.sceneRangeMeasurementSetting.default.id,
                    label: 'DAGGERHEART.SETTINGS.Scene.FIELDS.rangeMeasurement.setting.label'
                }),
                melee: new fields.NumberField({ integer: true, label: 'DAGGERHEART.CONFIG.Range.melee.name' }),
                veryClose: new fields.NumberField({ integer: true, label: 'DAGGERHEART.CONFIG.Range.veryClose.name' }),
                close: new fields.NumberField({ integer: true, label: 'DAGGERHEART.CONFIG.Range.close.name' }),
                far: new fields.NumberField({ integer: true, label: 'DAGGERHEART.CONFIG.Range.far.name' })
            })
        };
    }
}

var _module = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHScene: DHScene
});

var models = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhCombat: DhCombat,
    DhCombatant: DhCombatant$1,
    DhTagTeamRoll: DhTagTeamRoll,
    actions: _module$9,
    activeEffects: _module$3,
    actors: _module$4,
    chatMessages: _modules,
    countdowns: countdowns,
    fields: fields,
    items: _module$1,
    scenes: _module
});

class DhpCombat extends Combat {
    async startCombat() {
        this._playCombatSound('startEncounter');
        const updateData = { round: 1, turn: null };
        Hooks.callAll('combatStart', this, updateData);
        await this.update(updateData);
        return this;
    }

    _sortCombatants(a, b) {
        const aNPC = Number(a.isNPC);
        const bNPC = Number(b.isNPC);
        if (aNPC !== bNPC) {
            return aNPC - bNPC;
        }

        return a.name.localeCompare(b.name);
    }

    async toggleModifierEffects(add, actors, category, groupingKey) {
        const effectData = category && groupingKey ? [{ category, grouping: groupingKey }] : this.system.battleToggles;
        if (add) {
            const effects = effectData.reduce((acc, toggle) => {
                const grouping = CONFIG.DH.ENCOUNTER.BPModifiers[toggle.category]?.[toggle.grouping];
                if (!grouping?.effects?.length) return acc;
                acc.push(
                    ...grouping.effects.map(effect => ({
                        ...effect,
                        name: game.i18n.localize(effect.name),
                        description: game.i18n.localize(effect.description),
                        flags: {
                            [`${CONFIG.DH.id}.${CONFIG.DH.FLAGS.combatToggle}`]: {
                                category: toggle.category,
                                grouping: toggle.grouping
                            }
                        }
                    }))
                );

                return acc;
            }, []);

            if (!effects.length) return;

            for (let actor of actors) {
                await actor.createEmbeddedDocuments(
                    'ActiveEffect',
                    effects.map(effect => ({
                        ...effect,
                        name: game.i18n.localize(effect.name),
                        description: game.i18n.localize(effect.description)
                    }))
                );
            }
        } else {
            for (let actor of actors) {
                await actor.deleteEmbeddedDocuments(
                    'ActiveEffect',
                    actor.effects
                        .filter(x => {
                            const flag = x.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.combatToggle);
                            if (!flag) return false;
                            return effectData.some(
                                data => flag.category == data.category && flag.grouping === data.grouping
                            );
                        })
                        .map(x => x.id)
                );
            }
        }
    }
}

class DhCombatant extends Combatant {
    /**@inheritdoc */
    get isNPC() {
        return this.actor?.isNPC ?? (!this.actor || !this.hasPlayerOwner);
    }
}

class DhActiveEffect extends foundry.documents.ActiveEffect {
    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /**@override */
    get isSuppressed() {
        // If this is a copied effect from an attachment, never suppress it
        // (These effects have attachmentSource metadata)
        if (this.flags?.daggerheart?.attachmentSource) {
            return false;
        }

        // Then apply the standard suppression rules
        if (['weapon', 'armor'].includes(this.parent?.type)) {
            return !this.parent.system.equipped;
        }

        if (this.parent?.type === 'domainCard') {
            return this.parent.system.inVault;
        }

        return super.isSuppressed;
    }

    /**
     * Check if the parent item is currently attached to another item
     * @returns {boolean}
     */
    get isAttached() {
        if (!this.parent || !this.parent.parent) return false;

        // Check if this item's UUID is in any actor's armor or weapon attachment lists
        const actor = this.parent.parent;
        if (!actor || !actor.items) return false;

        return actor.items.some(item => {
            return (
                (item.type === 'armor' || item.type === 'weapon') &&
                item.system?.attached &&
                Array.isArray(item.system.attached) &&
                item.system.attached.includes(this.parent.uuid)
            );
        });
    }

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    /**@inheritdoc*/
    async _preCreate(data, options, user) {
        const update = {};
        if (!data.img) {
            update.img = 'icons/magic/life/heart-cross-blue.webp';
        }

        const immuneStatuses =
            data.statuses?.filter(
                status =>
                    this.parent.system.rules?.conditionImmunities &&
                    this.parent.system.rules.conditionImmunities[status]
            ) ?? [];
        if (immuneStatuses.length > 0) {
            update.statuses = data.statuses.filter(x => !immuneStatuses.includes(x));
            const conditions = CONFIG.DH.GENERAL.conditions();
            const scrollingTexts = immuneStatuses.map(status => ({
                text: game.i18n.format('DAGGERHEART.ACTIVEEFFECT.immuneStatusText', {
                    status: game.i18n.localize(conditions[status].name)
                })
            }));
            if (update.statuses.length > 0) {
                setTimeout(() => scrollingTexts, 500);
            } else {
                this.parent.queueScrollText(scrollingTexts);
            }
        }

        if (Object.keys(update).length > 0) {
            await this.updateSource(update);
        }

        await super._preCreate(data, options, user);
    }

    /** @inheritdoc */
    _onCreate(data, options, userId) {
        super._onCreate(data, options, userId);

        Hooks.callAll(RefreshType.EffectsDisplay);
    }

    /** @inheritdoc */
    _onDelete(data, options, userId) {
        super._onDelete(data, options, userId);

        Hooks.callAll(RefreshType.EffectsDisplay);
    }

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**@inheritdoc*/
    static applyField(model, change, field) {
        const isOriginTarget = change.value.toLowerCase().includes('origin.@');
        let parseModel = model;
        if (isOriginTarget && change.effect.origin) {
            change.value = change.value.replaceAll(/origin\.@/gi, '@');
            try {
                const effect = foundry.utils.fromUuidSync(change.effect.origin);
                const doc =
                    effect.parent?.parent instanceof game.system.api.documents.DhpActor
                        ? effect.parent
                        : effect.parent.parent;
                if (doc) parseModel = doc;
            } catch (_) {}
        }

        const evalValue = this.effectSafeEval(itemAbleRollParse(change.value, parseModel, change.effect.parent));
        change.value = evalValue ?? change.value;
        super.applyField(model, change, field);
    }

    /**
     * Altered Foundry safeEval to allow non-numeric return
     * @param {string} expression
     * @returns
     */
    static effectSafeEval(expression) {
        let result;
        try {
            // eslint-disable-next-line no-new-func
            const evl = new Function('sandbox', `with (sandbox) { return ${expression}}`);
            result = evl(Roll.MATH_PROXY);
        } catch (err) {
            return expression;
        }

        return result;
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            `${game.i18n.localize(this.parent.system.metadata.label)}: ${this.parent.name}`,
            game.i18n.localize(
                this.isTemporary ? 'DAGGERHEART.EFFECTS.Duration.temporary' : 'DAGGERHEART.EFFECTS.Duration.passive'
            )
        ];

        for (const statusId of this.statuses) {
            const status = CONFIG.statusEffects.find(s => s.id === statusId);
            if (status) tags.push(game.i18n.localize(status.name));
        }

        return tags;
    }

    /**
     * Create a new ChatMessage to display this documents data.
     * @param {String} origin -  uuid of a document. TODO: This needs to be reviewed.
     */
    async toChat(origin) {
        /**@type {foundry.documents.ChatMessage} */
        const cls = getDocumentClass('ChatMessage');
        const speaker = cls.getSpeaker();
        const actor = cls.getSpeakerActor(speaker);
        const systemData = {
            action: { img: this.img, name: this.name },
            actor: { name: actor?.name, img: actor?.img },
            speaker,
            origin,
            description: this.description,
            actions: []
        };
        const msg = {
            title: game.i18n.localize('DAGGERHEART.GENERAL.Effect.single'),
            user: game.user.id,
            system: systemData,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/action.hbs',
                systemData
            )
        };

        cls.create(msg);
    }

    prepareDerivedData() {
        /* Preventing subclass features from transferring to actor if they do not have the right subclass advancement */
        if (this.parent?.type === 'feature') {
            const origSubclassParent = this.parent.system.originItemType === 'subclass';
            if (origSubclassParent) {
                const subclass = this.parent.parent.items.find(
                    x =>
                        x.type === 'subclass' &&
                        x.system.isMulticlass === (this.parent.system.identifier === 'multiclass')
                );

                if (subclass) {
                    const featureState = subclass.system.featureState;

                    if (
                        (this.parent.system.identifier === CONFIG.DH.ITEM.featureSubTypes.specialization &&
                            featureState < 2) ||
                        (this.parent.system.identifier === CONFIG.DH.ITEM.featureSubTypes.mastery && featureState < 3)
                    ) {
                        this.transfer = false;
                    }
                }
            }
        }
    }
}

class DhpChatMessage extends foundry.documents.ChatMessage {
    targetHook = null;

    async renderHTML() {
        const actor = game.actors.get(this.speaker.actor);
        const actorData =
            actor && this.isContentVisible
                ? actor
                : {
                      img: this.author.avatar ? this.author.avatar : 'icons/svg/mystery-man.svg',
                      name: ''
                  };
        /* We can change to fully implementing the renderHTML function if needed, instead of augmenting it. */
        const html = await super.renderHTML({ actor: actorData, author: this.author });

        if (this.flags.core?.RollTable) {
            html.querySelector('.roll-buttons.apply-buttons')?.remove();
        }

        this.enrichChatMessage(html);
        this.addChatListeners(html);

        return html;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    prepareData() {
        if (this.isAuthor && this.targetSelection === undefined) this.targetSelection = this.system.targets?.length > 0;
        super.prepareData();
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _onCreate(data, options, userId) {
        super._onCreate(data, options, userId);
        if (this.system.registerTargetHook) this.system.registerTargetHook();
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    async _preDelete(options, user) {
        if (this.targetHook !== null) Hooks.off('targetToken', this.targetHook);
        return super._preDelete(options, user);
    }

    /** @inheritDoc */
    _onUpdate(changes, options, userId) {
        super._onUpdate(changes, options, userId);

        const lastMessage = Array.from(game.messages).sort((a, b) => b.timestamp - a.timestamp)[0];
        if (lastMessage.id === this.id && ui.chat.isAtBottom) {
            setTimeout(() => {
                ui.chat.scrollBottom();
            }, 5);
        }
    }

    enrichChatMessage(html) {
        const elements = html.querySelectorAll('[data-perm-id]');
        elements.forEach(e => {
            const uuid = e.dataset.permId,
                document = fromUuidSync(uuid);
            if (!document) return;

            e.setAttribute('data-view-perm', document.testUserPermission(game.user, 'OBSERVER'));
            e.setAttribute('data-use-perm', document.testUserPermission(game.user, 'OWNER'));
        });

        if (this.isContentVisible) {
            if (this.type === 'dualityRoll') {
                html.classList.add('duality');
                switch (this.system.roll?.result?.duality) {
                    case 1:
                        html.classList.add('hope');
                        break;
                    case -1:
                        html.classList.add('fear');
                        break;
                    default:
                        html.classList.add('critical');
                        break;
                }
            }

            const autoExpandRoll = game.settings.get(
                    CONFIG.DH.id,
                    CONFIG.DH.SETTINGS.gameSettings.appearance
                ).expandRollMessage,
                rollSections = html.querySelectorAll('.roll-part'),
                itemDesc = html.querySelector('.domain-card-move');
            rollSections.forEach(s => {
                if (s.classList.contains('roll-section')) {
                    const toExpand = s.querySelector('[data-action="expandRoll"]');
                    toExpand.classList.toggle('expanded', autoExpandRoll.roll);
                } else if (s.classList.contains('damage-section'))
                    s.classList.toggle('expanded', autoExpandRoll.damage);
                else if (s.classList.contains('target-section')) s.classList.toggle('expanded', autoExpandRoll.target);
            });
            if (itemDesc && autoExpandRoll.desc) itemDesc.setAttribute('open', '');
        }

        if (!this.isAuthor && !this.speakerActor?.isOwner) {
            const applyButtons = html.querySelector('.apply-buttons');
            applyButtons?.remove();
            const buttons = html.querySelectorAll('.ability-card-footer > .ability-use-button');
            buttons.forEach(b => b.remove());
        }
    }

    addChatListeners(html) {
        html.querySelectorAll('.duality-action-damage').forEach(element =>
            element.addEventListener('click', this.onRollDamage.bind(this))
        );

        html.querySelectorAll('.damage-button').forEach(element =>
            element.addEventListener('click', this.onApplyDamage.bind(this))
        );

        html.querySelectorAll('.target-save').forEach(element =>
            element.addEventListener('click', this.onRollSave.bind(this))
        );

        html.querySelectorAll('.roll-all-save-button').forEach(element =>
            element.addEventListener('click', this.onRollAllSave.bind(this))
        );

        html.querySelectorAll('.duality-action-effect').forEach(element =>
            element.addEventListener('click', this.onApplyEffect.bind(this))
        );

        html.querySelectorAll('.roll-target').forEach(element => {
            element.addEventListener('mouseenter', this.hoverTarget);
            element.addEventListener('mouseleave', this.unhoverTarget);
            element.addEventListener('click', this.clickTarget);
        });

        html.querySelectorAll('.button-target-selection').forEach(element => {
            element.addEventListener('click', this.onTargetSelection.bind(this));
        });

        html.querySelectorAll('.token-target-container').forEach(element => {
            if (element.dataset.token) {
                element.addEventListener('pointerover', this.hoverTarget);
                element.addEventListener('pointerout', this.unhoverTarget);
                element.addEventListener('click', this.clickTarget);
            }
        });
    }

    async onRollDamage(event) {
        event.stopPropagation();
        const config = foundry.utils.deepClone(this.system);
        config.event = event;
        await this.system.action?.workflow.get('damage')?.execute(config, this._id, true);

        Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.TagTeamRoll });
        await game.socket.emit(`system.${CONFIG.DH.id}`, {
            action: socketEvent.Refresh,
            data: {
                refreshType: RefreshType.TagTeamRoll
            }
        });
    }

    async onApplyDamage(event) {
        event.stopPropagation();
        const targets = this.filterPermTargets(this.system.hitTargets),
            config = foundry.utils.deepClone(this.system);
        config.event = event;

        if (this.system.onSave) {
            const pendingingSaves = targets.filter(t => t.saved.success === null);
            if (pendingingSaves.length) {
                const confirm = await foundry.applications.api.DialogV2.confirm({
                    window: { title: 'Pending Reaction Rolls found' },
                    content: `<p>Some Tokens still need to roll their Reaction Roll.</p><p>Are you sure you want to continue ?</p><p><i>Undone reaction rolls will be considered as failed</i></p>`
                });
                if (!confirm) return;
            }
        }

        if (targets.length === 0)
            return ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noTargetsSelectedOrPerm'));

        this.consumeOnSuccess();
        this.system.action?.workflow.get('applyDamage')?.execute(config, targets, true);
    }

    async onRollSave(event) {
        event.stopPropagation();
        const tokenId = event.target.closest('[data-token]')?.dataset.token,
            token = game.canvas.tokens.get(tokenId);
        if (!token?.actor || !token.isOwner) return true;
        if (this.system.source.item && this.system.source.action) {
            const action = this.system.action;
            if (!action || !action?.hasSave) return;
            game.system.api.fields.ActionFields.SaveField.rollSave.call(action, token.actor, event).then(result =>
                emitAsGM(
                    GMUpdateEvent.UpdateSaveMessage,
                    game.system.api.fields.ActionFields.SaveField.updateSaveMessage.bind(
                        action,
                        result,
                        this,
                        token.id
                    ),
                    {
                        action: action.uuid,
                        message: this._id,
                        token: token.id,
                        result
                    }
                )
            );
        }
    }

    async onRollAllSave(event) {
        event.stopPropagation();
        if (!game.user.isGM) return;
        const targets = this.system.hitTargets,
            config = foundry.utils.deepClone(this.system);
        config.event = event;
        this.system.action?.workflow.get('save')?.execute(config, targets, true);
    }

    async onApplyEffect(event) {
        event.stopPropagation();
        const targets = this.filterPermTargets(this.system.hitTargets),
            config = foundry.utils.deepClone(this.system);
        config.event = event;
        if (targets.length === 0)
            ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noTargetsSelectedOrPerm'));
        this.consumeOnSuccess();
        this.system.action?.workflow.get('effects')?.execute(config, targets, true);
    }

    filterPermTargets(targets) {
        return targets.filter(t => fromUuidSync(t.actorId)?.canUserModify(game.user, 'update'));
    }

    consumeOnSuccess() {
        if (!this.system.successConsumed && !this.targetSelection) this.system.action?.consume(this.system, true);
    }

    hoverTarget(event) {
        event.stopPropagation();
        const token = canvas.tokens.get(event.currentTarget.dataset.token);
        if (token && !token?.controlled) token._onHoverIn(event, { hoverOutOthers: true });
    }

    unhoverTarget(event) {
        const token = canvas.tokens.get(event.currentTarget.dataset.token);
        if (token && !token?.controlled) token._onHoverOut(event);
    }

    clickTarget(event) {
        event.stopPropagation();
        const token = canvas.tokens.get(event.currentTarget.dataset.token);
        if (!token) {
            ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.attackTargetDoesNotExist'));
            return;
        }
        game.canvas.pan(token);
    }

    onTargetSelection(event) {
        event.stopPropagation();
        if (!event.target.classList.contains('target-selected'))
            this.system.targetMode = Boolean(event.target.dataset.targetHit);
    }
}

class DHToken extends TokenDocument {
    /**
     * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar.
     * @param {object} attributes       The tracked attributes which can be chosen from
     * @returns {object}                A nested object of attribute choices to display
     */
    static getTrackedAttributeChoices(attributes, model) {
        attributes = attributes || this.getTrackedAttributes();
        const barGroup = game.i18n.localize('TOKEN.BarAttributes');
        const valueGroup = game.i18n.localize('TOKEN.BarValues');

        const bars = attributes.bar.map(v => {
            const a = v.join('.');
            const modelLabel = model ? game.i18n.localize(model.schema.getField(`${a}.value`).label) : null;
            return { group: barGroup, value: a, label: modelLabel ? modelLabel : a };
        });
        bars.sort((a, b) => a.label.compare(b.label));

        const invalidAttributes = [
            'gold',
            'levelData',
            'actions',
            'biography',
            'class',
            'multiclass',
            'companion',
            'notes',
            'partner',
            'description',
            'impulses',
            'tier',
            'type'
        ];
        const values = attributes.value.reduce((acc, v) => {
            const a = v.join('.');
            if (invalidAttributes.some(x => a.startsWith(x))) return acc;

            const field = model ? model.schema.getField(a) : null;
            const modelLabel = field ? game.i18n.localize(field.label) : null;
            const hint = field ? game.i18n.localize(field.hint) : null;
            acc.push({ group: valueGroup, value: a, label: modelLabel ? modelLabel : a, hint: hint });

            return acc;
        }, []);
        values.sort((a, b) => a.label.compare(b.label));

        return bars.concat(values);
    }

    static _getTrackedAttributesFromSchema(schema, _path = []) {
        const attributes = { bar: [], value: [] };
        for (const [name, field] of Object.entries(schema.fields)) {
            const p = _path.concat([name]);
            if (field instanceof foundry.data.fields.NumberField) attributes.value.push(p);
            if (field instanceof foundry.data.fields.BooleanField && field.options.isAttributeChoice)
                attributes.value.push(p);
            if (field instanceof foundry.data.fields.StringField) attributes.value.push(p);
            if (field instanceof foundry.data.fields.ArrayField) attributes.value.push(p);
            const isSchema = field instanceof foundry.data.fields.SchemaField;
            const isModel = field instanceof foundry.data.fields.EmbeddedDataField;

            if (isSchema || isModel) {
                const schema = isModel ? field.model.schema : field;
                const isBar = schema.has && schema.has('value') && schema.has('max');
                if (isBar) attributes.bar.push(p);
                else {
                    const inner = this.getTrackedAttributes(schema, p);
                    attributes.bar.push(...inner.bar);
                    attributes.value.push(...inner.value);
                }
            }
        }
        return attributes;
    }

    _shouldRecordMovementHistory() {
        return false;
    }

    /**@inheritdoc */
    static async createCombatants(tokens, combat) {
        combat ??= game.combats.viewed;
        if (combat?.system?.battleToggles?.length) {
            await combat.toggleModifierEffects(
                true,
                tokens.map(x => x.actor)
            );
        }
        super.createCombatants(tokens, combat ?? {});
    }

    /**@inheritdoc */
    static async deleteCombatants(tokens, { combat } = {}) {
        combat ??= game.combats.viewed;
        if (combat?.system?.battleToggles?.length) {
            await combat.toggleModifierEffects(
                false,
                tokens.map(x => x.actor)
            );
        }
        super.deleteCombatants(tokens, combat ?? {});
    }
}

class DhTooltipManager extends foundry.helpers.interaction.TooltipManager {
    #wide = false;
    #bordered = false;

    async activate(element, options = {}) {
        const { TextEditor } = foundry.applications.ux;

        let html = options.html;
        if (element.dataset.tooltip?.startsWith('#battlepoints#')) {
            this.#wide = true;

            html = await this.getBattlepointHTML(element.dataset.combatId);
            options.direction = this._determineItemTooltipDirection(element);
            super.activate(element, { ...options, html: html });

            const lockedTooltip = this.lockTooltip();
            lockedTooltip.querySelectorAll('.battlepoint-toggle-container input').forEach(element => {
                element.addEventListener('input', this.toggleModifier.bind(this));
            });
            return;
        } else {
            this.#wide = false;
        }

        if (element.dataset.tooltip === '#effect-display#') {
            this.#bordered = true;
            let effect = {};
            if (element.dataset.uuid) {
                const effectData = (await foundry.utils.fromUuid(element.dataset.uuid)).toObject();
                effect = {
                    ...effectData,
                    name: game.i18n.localize(effectData.name),
                    description: game.i18n.localize(effectData.description ?? effectData.parent.system.description)
                };
            } else {
                const conditions = CONFIG.DH.GENERAL.conditions();
                const condition = conditions[element.dataset.condition];
                effect = {
                    ...condition,
                    name: game.i18n.localize(condition.name),
                    description: game.i18n.localize(condition.description),
                    appliedBy: element.dataset.appliedBy,
                    isLockedCondition: true
                };
            }

            html = await foundry.applications.handlebars.renderTemplate(
                `systems/daggerheart/templates/ui/tooltip/effect-display.hbs`,
                {
                    effect
                }
            );

            this.tooltip.innerHTML = html;
            options.direction = this._determineItemTooltipDirection(element);
        } else {
            this.#bordered = false;
        }

        if (element.dataset.tooltip?.startsWith('#item#')) {
            const itemUuid = element.dataset.tooltip.slice(6);
            const item = await foundry.utils.fromUuid(itemUuid);
            if (item) {
                const isAction = item instanceof game.system.api.models.actions.actionsTypes.base;
                const isEffect = item instanceof ActiveEffect;
                await this.enrichText(item, isAction || isEffect);

                const type = isAction ? 'action' : isEffect ? 'effect' : item.type;
                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/${type}.hbs`,
                    {
                        item: item,
                        description: item.system?.enrichedDescription ?? item.enrichedDescription,
                        config: CONFIG.DH
                    }
                );

                this.tooltip.innerHTML = html;
                options.direction = this._determineItemTooltipDirection(element);
            }
        } else {
            const attack = element.dataset.tooltip?.startsWith('#attack#');
            if (attack) {
                const actorUuid = element.dataset.tooltip.slice(8);
                const actor = await foundry.utils.fromUuid(actorUuid);
                const attack = actor.system.attack;

                const description = await TextEditor.enrichHTML(attack.description);
                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/attack.hbs`,
                    {
                        attack: attack,
                        description: description,
                        parent: actor,
                        config: CONFIG.DH
                    }
                );

                this.tooltip.innerHTML = html;
            }

            const shortRest = element.dataset.tooltip?.startsWith('#shortRest#');
            const longRest = element.dataset.tooltip?.startsWith('#longRest#');
            if (shortRest || longRest) {
                const key = element.dataset.tooltip.slice(shortRest ? 11 : 10);

                const moves = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).restMoves[
                    element.dataset.restType
                ].moves;
                const move = moves[key];
                const description = await TextEditor.enrichHTML(move.description);
                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/downtime.hbs`,
                    {
                        move: move,
                        description: description
                    }
                );

                this.tooltip.innerHTML = html;
                options.direction = this._determineItemTooltipDirection(
                    element,
                    this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                );
            }

            const isAdvantage = element.dataset.tooltip?.startsWith('#advantage#');
            const isDisadvantage = element.dataset.tooltip?.startsWith('#disadvantage#');
            if (isAdvantage || isDisadvantage) {
                const actorUuid = element.dataset.tooltip.slice(isAdvantage ? 11 : 14);
                const actor = await foundry.utils.fromUuid(actorUuid);

                if (actor) {
                    html = await foundry.applications.handlebars.renderTemplate(
                        `systems/daggerheart/templates/ui/tooltip/advantage.hbs`,
                        {
                            sources: isAdvantage ? actor.system.advantageSources : actor.system.disadvantageSources
                        }
                    );

                    this.tooltip.innerHTML = html;
                }
            }

            const deathMove = element.dataset.tooltip?.startsWith('#deathMove#');
            if (deathMove) {
                const name = element.dataset.deathName;
                const img = element.dataset.deathImg;
                const description = element.dataset.deathDescription;

                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/death-move.hbs`,
                    {
                        move: { name: name, img: img, description: description }
                    }
                );

                this.tooltip.innerHTML = html;
                options.direction = this._determineItemTooltipDirection(
                    element,
                    this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                );
            }
        }

        super.activate(element, { ...options, html: html });
    }

    _setStyle(position = {}) {
        super._setStyle(position);

        if (this.#bordered) {
            this.tooltip.classList.add('bordered-tooltip');
        }
    }

    _determineItemTooltipDirection(element, prefered = this.constructor.TOOLTIP_DIRECTIONS.LEFT) {
        const pos = element.getBoundingClientRect();
        const dirs = this.constructor.TOOLTIP_DIRECTIONS;
        switch (prefered) {
            case this.constructor.TOOLTIP_DIRECTIONS.LEFT:
                return dirs[
                    pos.x - this.tooltip.offsetWidth < 0
                        ? this.constructor.TOOLTIP_DIRECTIONS.DOWN
                        : this.constructor.TOOLTIP_DIRECTIONS.LEFT
                ];
            case this.constructor.TOOLTIP_DIRECTIONS.UP:
                return dirs[
                    pos.y - this.tooltip.offsetHeight < 0
                        ? this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                        : this.constructor.TOOLTIP_DIRECTIONS.UP
                ];
            case this.constructor.TOOLTIP_DIRECTIONS.RIGHT:
                return dirs[
                    pos.x + this.tooltip.offsetWidth > document.body.clientWidth
                        ? this.constructor.TOOLTIP_DIRECTIONS.DOWN
                        : this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                ];
            case this.constructor.TOOLTIP_DIRECTIONS.DOWN:
                return dirs[
                    pos.y + this.tooltip.offsetHeight > document.body.clientHeight
                        ? this.constructor.TOOLTIP_DIRECTIONS.LEFT
                        : this.constructor.TOOLTIP_DIRECTIONS.DOWN
                ];
        }
    }

    async enrichText(item, flatStructure) {
        const { TextEditor } = foundry.applications.ux;
        const enrichPaths = [
            { path: flatStructure ? '' : 'system', name: 'description' },
            { path: 'system', name: 'features' },
            { path: 'system', name: 'actions' },
            { path: 'system', name: 'customActions' }
        ];

        for (let data of enrichPaths) {
            const basePath = `${data.path ? `${data.path}.` : ''}${data.name}`;
            const pathValue = foundry.utils.getProperty(item, basePath);
            if (!pathValue) continue;

            if (Array.isArray(pathValue) || pathValue.size) {
                for (const [index, itemValue] of pathValue.entries()) {
                    const itemIsAction = itemValue instanceof game.system.api.models.actions.actionsTypes.base;
                    const value = itemIsAction || !itemValue?.item ? itemValue : itemValue.item;
                    const enrichedValue = await TextEditor.enrichHTML(value.system?.description ?? value.description);
                    if (itemIsAction) value.enrichedDescription = enrichedValue;
                    else foundry.utils.setProperty(item, `${basePath}.${index}.enrichedDescription`, enrichedValue);
                }
            } else {
                const enrichedValue = await TextEditor.enrichHTML(pathValue);
                foundry.utils.setProperty(
                    item,
                    `${data.path ? `${data.path}.` : ''}enriched${data.name.capitalize()}`,
                    enrichedValue
                );
            }
        }
    }

    /**@inheritdoc */
    _setStyle(position = {}) {
        super._setStyle(position);

        if (this.#wide) {
            this.tooltip.classList.add('wide');
        }
    }

    /**@inheritdoc */
    lockTooltip() {
        const clone = super.lockTooltip();
        clone.classList.add('wide');

        return clone;
    }

    /** Get HTML for Battlepoints tooltip */
    async getBattlepointHTML(combatId) {
        const combat = game.combats.get(combatId);
        const adversaries =
            combat.turns?.filter(x => x.actor?.isNPC)?.map(x => ({ ...x.actor, type: x.actor.system.type })) ?? [];
        const characters = combat.turns?.filter(x => !x.isNPC) ?? [];

        const nrCharacters = characters.length;
        const currentBP = AdversaryBPPerEncounter(adversaries, characters);
        const maxBP = combat.system.extendedBattleToggles.reduce(
            (acc, toggle) => acc + toggle.category,
            BaseBPPerEncounter(nrCharacters)
        );

        const categories = combat.combatants.reduce((acc, combatant) => {
            if (combatant.actor.type === 'adversary') {
                const keyData = Object.keys(acc).reduce((identifiers, categoryKey) => {
                    if (identifiers) return identifiers;
                    const category = acc[categoryKey];
                    const groupingIndex = category.findIndex(grouping =>
                        grouping.types.includes(combatant.actor.system.type)
                    );
                    if (groupingIndex !== -1) identifiers = { categoryKey, groupingIndex };

                    return identifiers;
                }, null);
                if (keyData) {
                    const { categoryKey, groupingIndex } = keyData;
                    const grouping = acc[categoryKey][groupingIndex];
                    const partyAmount = CONFIG.DH.ACTOR.adversaryTypes[combatant.actor.system.type].partyAmountPerBP;
                    grouping.individuals = (grouping.individuals ?? 0) + 1;

                    const currentNr = grouping.nr ?? 0;
                    grouping.nr = partyAmount ? Math.ceil(grouping.individuals / (nrCharacters ?? 0)) : currentNr + 1;
                }
            }

            return acc;
        }, foundry.utils.deepClone(CONFIG.DH.ENCOUNTER.adversaryTypeCostBrackets));

        const extendedBattleToggles = combat.system.extendedBattleToggles;
        const toggles = Object.keys(CONFIG.DH.ENCOUNTER.BPModifiers)
            .reduce((acc, categoryKey) => {
                const category = CONFIG.DH.ENCOUNTER.BPModifiers[categoryKey];
                acc.push(
                    ...Object.keys(category).reduce((acc, toggleKey) => {
                        const grouping = category[toggleKey];
                        acc.push({
                            ...grouping,
                            categoryKey: Number(categoryKey),
                            toggleKey,
                            checked: extendedBattleToggles.find(
                                x => x.category == categoryKey && x.grouping === toggleKey
                            ),
                            disabled: grouping.automatic
                        });

                        return acc;
                    }, [])
                );
                return acc;
            }, [])
            .sort((a, b) => {
                if (a.categoryKey < b.categoryKey) return -1;
                if (a.categoryKey > b.categoryKey) return 1;
                else return a.toggleKey.localeCompare(b.toggleKey);
            });

        return await foundry.applications.handlebars.renderTemplate(
            `systems/daggerheart/templates/ui/tooltip/battlepoints.hbs`,
            {
                combatId: combat.id,
                nrCharacters,
                currentBP,
                maxBP,
                categories,
                toggles
            }
        );
    }

    /** Enable/disable a BP modifier */
    async toggleModifier(event) {
        const { combatId, category, grouping } = event.target.dataset;
        const combat = game.combats.get(combatId);
        await combat.update({
            system: {
                battleToggles: combat.system.battleToggles.some(x => x.category == category && x.grouping === grouping)
                    ? combat.system.battleToggles.filter(x => x.category != category && x.grouping !== grouping)
                    : [...combat.system.battleToggles, { category: Number(category), grouping }]
            }
        });

        await combat.toggleModifierEffects(
            event.target.checked,
            combat.combatants.filter(x => x.actor.type === 'adversary').map(x => x.actor),
            category,
            grouping
        );

        this.tooltip.innerHTML = await this.getBattlepointHTML(combatId);
        const lockedTooltip = this.lockTooltip();
        lockedTooltip.querySelectorAll('.battlepoint-toggle-container input').forEach(element => {
            element.addEventListener('input', this.toggleModifier.bind(this));
        });
    }
}

/**
 * A singleton class that handles preview templates.
 */

class DhTemplateManager {
    #activePreview;

    /**
     * Create a template preview, deactivating any existing ones.
     * @param {object} data
     */
    async createPreview(data) {
        const template = await canvas.templates._createPreview(data, { renderSheet: false });

        this.#activePreview = {
            document: template.document,
            object: template,
            origin: { x: template.document.x, y: template.document.y }
        };

        this.#activePreview.events = {
            contextmenu: this.#cancelTemplate.bind(this),
            mousedown: this.#confirmTemplate.bind(this),
            mousemove: this.#onDragMouseMove.bind(this),
            wheel: this.#onMouseWheel.bind(this)
        };
        canvas.stage.on('mousemove', this.#activePreview.events.mousemove);
        canvas.stage.on('mousedown', this.#activePreview.events.mousedown);

        canvas.app.view.addEventListener('wheel', this.#activePreview.events.wheel, true);
        canvas.app.view.addEventListener('contextmenu', this.#activePreview.events.contextmenu);
    }

    /**
     * Handles the movement of the temlate preview on mousedrag.
     * @param {mousemove Event} event
     */
    #onDragMouseMove(event) {
        event.stopPropagation();
        const { moveTime, object } = this.#activePreview;
        const update = {};

        const now = Date.now();
        if (now - (moveTime || 0) <= 16) return;
        this.#activePreview.moveTime = now;

        let cursor = event.getLocalPosition(canvas.templates);

        Object.assign(update, canvas.grid.getCenterPoint(cursor));

        object.document.updateSource(update);
        object.renderFlags.set({ refresh: true });
    }

    /**
     * Handles the rotation of the preview template on scrolling.
     * @param {wheel Event} event
     */
    #onMouseWheel(event) {
        if (!this.#activePreview) {
            return;
        }
        if (!event.shiftKey && !event.ctrlKey) return;
        event.stopPropagation();
        event.preventDefault();
        const { moveTime, object } = this.#activePreview;

        const now = Date.now();
        if (now - (moveTime || 0) <= 16) return;
        this.#activePreview.moveTime = now;

        const multiplier = event.shiftKey ? 0.2 : 0.1;

        object.document.updateSource({
            direction: object.document.direction + event.deltaY * multiplier
        });
        object.renderFlags.set({ refresh: true });
    }

    /**
     * Cancels the preview template on right-click.
     * @param {contextmenu Event} event
     */
    #cancelTemplate(event) {
        const { mousemove, mousedown, contextmenu, wheel } = this.#activePreview.events;
        canvas.templates._onDragLeftCancel(event);

        canvas.stage.off('mousemove', mousemove);
        canvas.stage.off('mousedown', mousedown);
        canvas.app.view.removeEventListener('contextmenu', contextmenu);
        canvas.app.view.removeEventListener('wheel', wheel);
    }

    /**
     * Creates a real MeasuredTemplate at the preview location and cancels the preview.
     * @param {click Event} event
     */
    #confirmTemplate(event) {
        event.stopPropagation();
        this.#cancelTemplate(event);

        canvas.scene.createEmbeddedDocuments('MeasuredTemplate', [this.#activePreview.document.toObject()]);
        this.#activePreview = undefined;
    }
}

var documents = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHCombatant: DhCombatant,
    DHItem: DHItem,
    DhActiveEffect: DhActiveEffect,
    DhChatMessage: DhpChatMessage,
    DhTemplateManager: DhTemplateManager,
    DhToken: DHToken,
    DhTooltipManager: DhTooltipManager,
    DhpActor: DhpActor,
    DhpCombat: DhpCombat
});

class BaseRoll extends Roll {
    /** @inheritdoc */
    static CHAT_TEMPLATE = 'systems/daggerheart/templates/ui/chat/foundryRoll.hbs';

    /** @inheritdoc */
    static TOOLTIP_TEMPLATE = 'systems/daggerheart/templates/ui/chat/foundryRollTooltip.hbs';
}

class DHRoll extends Roll {
    baseTerms = [];
    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
        if (!this.data || !Object.keys(this.data).length) this.data = options.data;
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.GENERAL.Roll.basic');
    }

    static messageType = 'adversaryRoll';

    static CHAT_TEMPLATE = 'systems/daggerheart/templates/ui/chat/roll.hbs';

    static DefaultDialog = D20RollDialog;

    static async build(config = {}, message = {}) {
        const roll = await this.buildConfigure(config, message);
        if (!roll) return;
        await this.buildEvaluate(roll, config, (message = {}));
        await this.buildPost(roll, config, (message = {}));
        return config;
    }

    static async buildConfigure(config = {}, message = {}) {
        config.hooks = [...this.getHooks(), ''];
        config.dialog ??= {};

        const actorIdSplit = config.source?.actor?.split('.');
        if (actorIdSplit) {
            const tagTeamSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
            config.tagTeamSelected = Boolean(tagTeamSettings.members[actorIdSplit[actorIdSplit.length - 1]]);
        }

        for (const hook of config.hooks) {
            if (Hooks.call(`${CONFIG.DH.id}.preRoll${hook.capitalize()}`, config, message) === false) return null;
        }

        this.applyKeybindings(config);

        this.temporaryModifierBuilder(config);

        let roll = new this(config.roll.formula, config.data, config);
        if (config.dialog.configure !== false) {
            // Open Roll Dialog
            const DialogClass = config.dialog?.class ?? this.DefaultDialog;
            const configDialog = await DialogClass.configure(roll, config, message);
            if (!configDialog) return;
        }

        for (const hook of config.hooks) {
            if (
                Hooks.call(`${CONFIG.DH.id}.post${hook.capitalize()}RollConfiguration`, roll, config, message) === false
            )
                return [];
        }
        return roll;
    }

    static async buildEvaluate(roll, config = {}, message = {}) {
        if (config.evaluate !== false) {
            await roll.evaluate();
            config.roll = this.postEvaluate(roll, config);
        }
    }

    static async buildPost(roll, config, message) {
        for (const hook of config.hooks) {
            if (Hooks.call(`${CONFIG.DH.id}.postRoll${hook.capitalize()}`, config, message) === false) return null;
        }

        if (config.skips?.createMessage) {
            if (game.modules.get('dice-so-nice')?.active) {
                await game.dice3d.showForRoll(roll, game.user, true);
            }
        } else if (!config.source?.message) {
            config.message = await this.toMessage(roll, config);
        }
    }

    static postEvaluate(roll, config = {}) {
        return {
            total: roll.total,
            formula: roll.formula,
            dice: roll.dice.map(d => ({
                dice: d.denomination,
                total: d.total,
                formula: d.formula,
                results: d.results
            }))
        };
    }

    static async toMessage(roll, config) {
        const cls = getDocumentClass('ChatMessage'),
            msgData = {
                type: this.messageType,
                user: game.user.id,
                title: roll.title,
                speaker: cls.getSpeaker({ actor: roll.data?.parent }),
                sound: config.mute ? null : CONFIG.sounds.dice,
                system: config,
                rolls: [roll]
            };

        config.selectedRollMode ??= game.settings.get('core', 'rollMode');

        if (roll._evaluated) {
            const message = await cls.create(msgData, { rollMode: config.selectedRollMode });

            if (config.tagTeamSelected) {
                game.system.api.applications.dialogs.TagTeamDialog.assignRoll(message.speakerActor, message);
            }

            if (roll.formula !== '' && game.modules.get('dice-so-nice')?.active) {
                await game.dice3d.waitFor3DAnimationByMessageID(message.id);
            }

            return message;
        } else return msgData;
    }

    /** @inheritDoc */
    async render({ flavor, template = this.constructor.CHAT_TEMPLATE, isPrivate = false, ...options } = {}) {
        if (!this._evaluated) return;
        const chatData = await this._prepareChatRenderContext({ flavor, isPrivate, ...options });
        return foundry.applications.handlebars.renderTemplate(template, chatData);
    }

    /** @inheritDoc */
    async _prepareChatRenderContext({ flavor, isPrivate = false, ...options } = {}) {
        if (isPrivate) {
            return {
                user: game.user.id,
                flavor: null,
                title: '???',
                roll: {
                    total: '??'
                },
                hasRoll: true,
                isPrivate
            };
        } else {
            options.message.system.user = game.user.id;
            return options.message.system;
        }
    }

    static applyKeybindings(config) {
        if (config.event)
            config.dialog.configure ??= !(config.event.shiftKey || config.event.altKey || config.event.ctrlKey);
    }

    static getHooks(hooks) {
        return hooks ?? [];
    }

    formatModifier(modifier) {
        if (Array.isArray(modifier)) {
            return [
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(modifier.join(' + '), this.options.data)
            ];
        } else {
            const numTerm = modifier < 0 ? '-' : '+';
            return [
                new foundry.dice.terms.OperatorTerm({ operator: numTerm }),
                new foundry.dice.terms.NumericTerm({ number: Math.abs(modifier) })
            ];
        }
    }

    applyBaseBonus() {
        return [];
    }

    addModifiers(roll) {
        roll = roll ?? this.options.roll;
        roll.modifiers?.forEach(m => {
            this.terms.push(...this.formatModifier(m.value));
        });
    }

    getBonus(path, label) {
        const bonus = foundry.utils.getProperty(this.data.bonuses, path),
            modifiers = [];
        if (bonus?.bonus)
            modifiers.push({
                label: label,
                value: bonus?.bonus
            });
        if (bonus?.dice?.length)
            modifiers.push({
                label: label,
                value: bonus?.dice
            });
        return modifiers;
    }

    getFaces(faces) {
        return Number(faces.startsWith('d') ? faces.replace('d', '') : faces);
    }

    constructFormula(config) {
        this.terms = Roll.parse(this.options.roll.formula, config.data);

        this.options.roll.modifiers = this.applyBaseBonus();
        this.addModifiers();

        if (this.options.extraFormula) {
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(this.options.extraFormula, this.options.data)
            );
        }
        return (this._formula = this.constructor.getFormula(this.terms));
    }

    static calculateTotalModifiers(roll) {
        let modifierTotal = 0;
        for (let i = 0; i < roll.terms.length; i++) {
            if (
                roll.terms[i] instanceof foundry.dice.terms.NumericTerm &&
                !!roll.terms[i - 1] &&
                roll.terms[i - 1] instanceof foundry.dice.terms.OperatorTerm
            )
                modifierTotal += Number(`${roll.terms[i - 1].operator}${roll.terms[i].total}`);
        }
        return modifierTotal;
    }

    static temporaryModifierBuilder(config) {
        return {};
    }
}

const registerRollDiceHooks = () => {
    Hooks.on(`${CONFIG.DH.id}.postRollDuality`, async (config, message) => {
        const automationSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation);
        if (
            automationSettings.countdownAutomation &&
            config.actionType !== CONFIG.DH.ITEM.actionTypes.reaction.id &&
            !config.tagTeamSelected &&
            !config.skips?.updateCountdowns
        ) {
            const { updateCountdowns } = game.system.api.applications.ui.DhCountdowns;
            await updateCountdowns(CONFIG.DH.GENERAL.countdownProgressionTypes.actionRoll.id);

            if (config.roll.result.duality === -1) {
                await updateCountdowns(CONFIG.DH.GENERAL.countdownProgressionTypes.fear.id);
            }
        }

        const hopeFearAutomation = automationSettings.hopeFear;
        if (
            !config.source?.actor ||
            (game.user.isGM ? !hopeFearAutomation.gm : !hopeFearAutomation.players) ||
            config.actionType === 'reaction' ||
            config.tagTeamSelected ||
            config.skips?.resources
        )
            return;
        const actor = await fromUuid(config.source.actor);
        let updates = [];
        if (!actor) return;
        if (config.roll.isCritical || config.roll.result.duality === 1)
            updates.push({ key: 'hope', value: 1, total: -1, enabled: true });
        if (config.roll.isCritical) updates.push({ key: 'stress', value: 1, total: -1, enabled: true });
        if (config.roll.result.duality === -1) updates.push({ key: 'fear', value: 1, total: -1, enabled: true });

        if (config.rerolledRoll) {
            if (config.rerolledRoll.isCritical || config.rerolledRoll.result.duality === 1)
                updates.push({ key: 'hope', value: -1, total: 1, enabled: true });
            if (config.rerolledRoll.isCritical) updates.push({ key: 'stress', value: -1, total: 1, enabled: true });
            if (config.rerolledRoll.result.duality === -1)
                updates.push({ key: 'fear', value: -1, total: 1, enabled: true });
        }

        if (updates.length) {
            const target = actor.system.partner ?? actor;
            if (!['dead', 'defeated', 'unconscious'].some(x => actor.statuses.has(x))) {
                if (config.rerolledRoll) target.modifyResource(updates);
                else config.costs = [...(config.costs ?? []), ...updates];
            }
        }

        if (!config.roll.hasOwnProperty('success') && !config.targets?.length) return;

        const rollResult = config.roll.success || config.targets.some(t => t.hit),
            looseSpotlight = !rollResult || config.roll.result.duality === -1;

        if (looseSpotlight && game.combat?.active) {
            const currentCombatant = game.combat.combatants.get(game.combat.current?.combatantId);
            if (currentCombatant?.actorId == actor.id) ui.combat.setCombatantSpotlight(currentCombatant.id);
        }

        return;
    });
};

class D20Roll extends DHRoll {
    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
        this.constructFormula();
    }

    static ADV_MODE = {
        NORMAL: 0,
        ADVANTAGE: 1,
        DISADVANTAGE: -1
    };

    static DefaultDialog = D20RollDialog;

    get title() {
        return game.i18n.localize('DAGGERHEART.GENERAL.d20Roll');
    }

    get d20() {
        if (!(this.terms[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        return this.terms[0];
    }

    set d20(faces) {
        if (!(this.terms[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        this.terms[0].faces = this.getFaces(faces);
    }

    get dAdvantage() {
        return this.dice[2];
    }

    get isCritical() {
        if (!this.d20._evaluated) return;
        return this.d20.total >= this.data.system.criticalThreshold;
    }

    get hasAdvantage() {
        const adv = this.options.roll.advantage.type ?? this.options.roll.advantage;
        return adv === this.constructor.ADV_MODE.ADVANTAGE;
    }

    get hasDisadvantage() {
        const adv = this.options.roll.advantage.type ?? this.options.roll.advantage;
        return adv === this.constructor.ADV_MODE.DISADVANTAGE;
    }

    static applyKeybindings(config) {
        let keys = {
            normal: true,
            advantage: false,
            disadvantage: false
        };

        if (config.event) {
            keys = {
                normal: config.event.shiftKey || config.event.altKey || config.event.ctrlKey,
                advantage: config.event.altKey,
                disadvantage: config.event.ctrlKey
            };
        }

        // Should the roll configuration dialog be displayed?
        config.dialog.configure ??= !Object.values(keys).some(k => k);

        // Determine advantage mode
        const advantage = config.roll.advantage === this.ADV_MODE.ADVANTAGE || keys.advantage || config.advantage;
        const disadvantage =
            config.roll.advantage === this.ADV_MODE.DISADVANTAGE || keys.disadvantage || config.disadvantage;
        if (advantage && !disadvantage) config.roll.advantage = this.ADV_MODE.ADVANTAGE;
        else if (!advantage && disadvantage) config.roll.advantage = this.ADV_MODE.DISADVANTAGE;
        else config.roll.advantage = this.ADV_MODE.NORMAL;
    }

    constructFormula(config) {
        this.createBaseDice();
        this.configureModifiers();
        this.resetFormula();
        return this._formula;
    }

    createBaseDice() {
        if (this.terms[0] instanceof foundry.dice.terms.Die) {
            this.terms = [this.terms[0]];
            return;
        }
        this.terms[0] = new foundry.dice.terms.Die({ faces: 20 });
    }

    configureModifiers() {
        this.applyAdvantage();

        this.baseTerms = foundry.utils.deepClone(this.dice);

        this.options.roll.modifiers = this.applyBaseBonus();

        this.options.experiences?.forEach(m => {
            if (this.options.data.experiences?.[m])
                this.options.roll.modifiers.push({
                    label: this.options.data.experiences[m].name,
                    value: this.options.data.experiences[m].value
                });
        });

        this.addModifiers();
        if (this.options.extraFormula) {
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(this.options.extraFormula, this.options.data)
            );
        }
    }

    applyAdvantage() {
        this.d20.modifiers.findSplice(m => ['kh', 'kl'].includes(m));
        if (!this.hasAdvantage && !this.hasDisadvantage) this.d20.number = 1;
        else {
            this.d20.number = 2;
            this.d20.modifiers.push(this.hasAdvantage ? 'kh' : 'kl');
        }
    }

    applyBaseBonus() {
        const modifiers = foundry.utils.deepClone(this.options.roll.baseModifiers) ?? [];

        modifiers.push(
            ...this.getBonus(`roll.${this.options.actionType}`, `${this.options.actionType?.capitalize()} Bonus`)
        );
        modifiers.push(
            ...this.getBonus(`roll.${this.options.roll.type}`, `${this.options.roll.type?.capitalize()} Bonus`)
        );

        return modifiers;
    }

    static postEvaluate(roll, config = {}) {
        const data = super.postEvaluate(roll, config);
        data.type = config.actionType;
        data.difficulty = config.roll.difficulty;
        if (config.targets?.length) {
            config.targets.forEach(target => {
                const difficulty = config.roll.difficulty ?? target.difficulty ?? target.evasion;
                target.hit = roll.isCritical || roll.total >= difficulty;
            });
            data.success = config.targets.some(target => target.hit);
        } else if (config.roll.difficulty) data.success = roll.isCritical || roll.total >= config.roll.difficulty;
        config.successConsumed = data.success;

        data.advantage = {
            type: config.roll.advantage,
            dice: roll.dAdvantage?.denomination,
            value: roll.dAdvantage?.total
        };
        data.dice = data.dice.map(dice => ({
            ...dice,
            results: dice.results.filter(x => !x.rerolled),
            rerolled: {
                any: dice.results.some(x => x.rerolled),
                rerolls: dice.results.filter(x => x.rerolled)
            }
        }));
        data.isCritical = config.isCritical = roll.isCritical;
        data.extra = roll.dice
            .filter(d => !roll.baseTerms.includes(d))
            .map(d => {
                return {
                    dice: d.denomination,
                    value: d.total,
                    results: d.results
                };
            });
        data.modifierTotal = this.calculateTotalModifiers(roll);
        return data;
    }

    resetFormula() {
        return (this._formula = this.constructor.getFormula(this.terms));
    }

    static async reroll(rollString, _target, message) {
        let parsedRoll = game.system.api.dice.D20Roll.fromData(rollString);
        parsedRoll = await parsedRoll.reroll();
        const newRoll = game.system.api.dice.D20Roll.postEvaluate(parsedRoll, {
            targets: message.system.targets,
            roll: {
                advantage: message.system.roll.advantage?.type,
                difficulty: message.system.roll.difficulty ? Number(message.system.roll.difficulty) : null
            }
        });

        if (game.modules.get('dice-so-nice')?.active) {
            await game.dice3d.showForRoll(parsedRoll, game.user, true);
        }

        const rerolled = {
            any: true,
            rerolls: [
                ...(message.system.roll.dice[0].rerolled?.rerolls?.length > 0
                    ? [message.system.roll.dice[0].rerolled?.rerolls]
                    : []),
                rollString.terms[0].results
            ]
        };
        return {
            newRoll: {
                ...newRoll,
                dice: [
                    {
                        ...newRoll.dice[0],
                        rerolled: rerolled
                    }
                ]
            },
            parsedRoll
        };
    }
}

class DamageRoll extends DHRoll {
    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
    }

    static DefaultDialog = DamageDialog;

    static async buildEvaluate(roll, config = {}, message = {}) {
        if (config.dialog.configure === false) roll.constructFormula(config);
        if (config.evaluate !== false) for (const roll of config.roll) await roll.roll.evaluate();

        roll._evaluated = true;
        const parts = config.roll.map(r => this.postEvaluate(r));

        config.damage = this.unifyDamageRoll(parts);
    }

    static postEvaluate(roll, config = {}) {
        return {
            ...roll,
            ...super.postEvaluate(roll.roll, config),
            damageTypes: [...(roll.damageTypes ?? [])],
            roll: roll.roll,
            type: config.type,
            modifierTotal: this.calculateTotalModifiers(roll.roll)
        };
    }

    static async buildPost(roll, config, message) {
        const chatMessage = config.source?.message
            ? ui.chat.collection.get(config.source.message)
            : getDocumentClass('ChatMessage').applyRollMode({}, config.rollMode);
        if (game.modules.get('dice-so-nice')?.active) {
            const pool = foundry.dice.terms.PoolTerm.fromRolls(
                    Object.values(config.damage).flatMap(r => r.parts.map(p => p.roll))
                ),
                diceRoll = Roll.fromTerms([pool]);
            await game.dice3d.showForRoll(
                diceRoll,
                game.user,
                true,
                chatMessage.whisper?.length > 0 ? chatMessage.whisper : null,
                chatMessage.blind
            );
        }
        await super.buildPost(roll, config, message);
        if (config.source?.message) chatMessage.update({ 'system.damage': config.damage });
    }

    static unifyDamageRoll(rolls) {
        const unified = {};
        rolls.forEach(r => {
            const resource = unified[r.applyTo] ?? { formula: '', total: 0, parts: [] };
            resource.formula += `${resource.formula !== '' ? ' + ' : ''}${r.formula}`;
            resource.total += r.total;
            resource.parts.push(r);
            unified[r.applyTo] = resource;
        });
        return unified;
    }

    static formatGlobal(rolls) {
        let formula, total;
        const applyTo = new Set(rolls.flatMap(r => r.applyTo));
        if (applyTo.size > 1) {
            const data = {};
            rolls.forEach(r => {
                if (data[r.applyTo]) {
                    data[r.applyTo].formula += ` + ${r.formula}`;
                    data[r.applyTo].total += r.total;
                } else {
                    data[r.applyTo] = {
                        formula: r.formula,
                        total: r.total
                    };
                }
            });
            formula = Object.entries(data).reduce((a, [k, v]) => a + ` ${k}: ${v.formula}`, '');
            total = Object.entries(data).reduce((a, [k, v]) => a + ` ${k}: ${v.total}`, '');
        } else {
            formula = rolls.map(r => r.formula).join(' + ');
            total = rolls.reduce((a, c) => a + c.total, 0);
        }
        return { formula, total };
    }

    applyBaseBonus(part) {
        const modifiers = [],
            type = this.options.messageType ?? (this.options.hasHealing ? 'healing' : 'damage'),
            options = part ?? this.options;

        modifiers.push(...this.getBonus(`${type}`, `${type.capitalize()} Bonus`));
        if (!this.options.hasHealing) {
            options.damageTypes?.forEach(t => {
                modifiers.push(...this.getBonus(`${type}.${t}`, `${t.capitalize()} ${type.capitalize()} Bonus`));
            });
            const weapons = ['primaryWeapon', 'secondaryWeapon'];
            weapons.forEach(w => {
                if (this.options.source.item && this.options.source.item === this.data[w]?.id)
                    modifiers.push(...this.getBonus(`${type}.${w}`, 'Weapon Bonus'));
            });
        }

        return modifiers;
    }

    constructFormula(config) {
        this.options.roll.forEach((part, index) => {
            part.roll = new Roll(Roll.replaceFormulaData(part.formula, config.data));
            this.constructFormulaPart(config, part, index);
        });
        return this.options.roll;
    }

    constructFormulaPart(config, part, index) {
        part.roll.terms = Roll.parse(part.roll.formula, config.data);

        if (part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            part.modifiers = this.applyBaseBonus(part);
            this.addModifiers(part);
            part.modifiers?.forEach(m => {
                part.roll.terms.push(...this.formatModifier(m.value));
            });
        }

        /* To Remove When Reaction System */
        if (index === 0 && part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            for (const mod in config.modifiers) {
                const modifier = config.modifiers[mod];
                if (modifier.beforeCrit === true && (modifier.enabled || modifier.value)) modifier.callback(part);
            }
        }

        if (part.extraFormula) {
            part.roll.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(part.extraFormula, this.options.data)
            );
        }

        if (config.isCritical && part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            const total = part.roll.dice.reduce((acc, term) => acc + term._faces * term._number, 0);
            if (total > 0) {
                part.roll.terms.push(...this.formatModifier(total));
            }
        }

        /* To Remove When Reaction System */
        if (index === 0 && part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            for (const mod in config.modifiers) {
                const modifier = config.modifiers[mod];
                if (!modifier.beforeCrit && (modifier.enabled || modifier.value)) modifier.callback(part);
            }
        }

        return (part.roll._formula = this.constructor.getFormula(part.roll.terms));
    }

    /* To Remove When Reaction System */
    static temporaryModifierBuilder(config) {
        const mods = {};
        if (config.data?.parent) {
            if (config.data.parent.appliedEffects) {
                // Bardic Rally
                const rallyChoices = config.data?.parent?.appliedEffects.reduce((a, c) => {
                    const change = c.changes.find(ch => ch.key === 'system.bonuses.rally');
                    if (change) a.push({ value: c.id, label: change.value });
                    return a;
                }, []);
                if (rallyChoices.length) {
                    mods.rally = {
                        label: 'DAGGERHEART.CLASS.Feature.rallyDice',
                        values: rallyChoices,
                        value: null,
                        beforeCrit: true,
                        callback: part => {
                            const rallyFaces = config.modifiers.rally.values.find(
                                r => r.value === config.modifiers.rally.value
                            )?.label;
                            part.roll.terms.push(
                                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                                ...this.parse(`1${rallyFaces}`)
                            );
                        }
                    };
                }
            }

            const item = config.data.parent.items?.get(config.source.item);
            if (item) {
                // Massive (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'massive'))
                    mods.massive = {
                        label: CONFIG.DH.ITEM.weaponFeatures.massive.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`kh${part.roll.terms[0].number}`);
                            part.roll.terms[0].number += 1;
                        }
                    };

                // Powerful (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'powerful'))
                    mods.powerful = {
                        label: CONFIG.DH.ITEM.weaponFeatures.powerful.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`kh${part.roll.terms[0].number}`);
                            part.roll.terms[0].number += 1;
                        }
                    };

                // Brutal (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'brutal'))
                    mods.brutal = {
                        label: CONFIG.DH.ITEM.weaponFeatures.brutal.label,
                        enabled: true,
                        beforeCrit: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`x${part.roll.terms[0].faces}`);
                        }
                    };

                // Serrated (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'serrated'))
                    mods.serrated = {
                        label: CONFIG.DH.ITEM.weaponFeatures.serrated.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`sc8`);
                        }
                    };

                // Self-Correcting (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'selfCorrecting'))
                    mods.selfCorrecting = {
                        label: CONFIG.DH.ITEM.weaponFeatures.selfCorrecting.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`sc6`);
                        }
                    };
            }
        }

        config.modifiers = mods;
        return mods;
    }

    static async reroll(target, message) {
        const { damageType, part, dice, result } = target.dataset;
        const rollPart = message.system.damage[damageType].parts[part];

        let diceIndex = 0;
        let parsedRoll = game.system.api.dice.DamageRoll.fromData({
            ...rollPart.roll,
            terms: rollPart.roll.terms.map(term => {
                const isDie = term.class === 'Die';
                const fixedTerm = {
                    ...term,
                    ...(isDie ? { results: rollPart.dice[diceIndex].results } : {})
                };

                if (isDie) diceIndex++;
                return fixedTerm;
            }),
            class: 'DamageRoll',
            evaluated: false
        });

        const parsedDiceTerms = Object.keys(parsedRoll.terms).reduce((acc, key) => {
            const term = parsedRoll.terms[key];
            if (term instanceof CONFIG.Dice.termTypes.DiceTerm) acc[Object.keys(acc).length] = term;
            return acc;
        }, {});
        const term = parsedDiceTerms[dice];
        const termResult = parsedDiceTerms[dice].results[result];

        const newIndex = parsedDiceTerms[dice].results.length;
        await term.reroll(`/r1=${termResult.result}`);

        if (game.modules.get('dice-so-nice')?.active) {
            const newResult = parsedDiceTerms[dice].results[newIndex];
            const diceSoNiceRoll = {
                _evaluated: true,
                dice: [
                    new foundry.dice.terms.Die({
                        ...term,
                        total: newResult.result,
                        faces: term._faces,
                        results: [newResult]
                    })
                ],
                options: { appearance: {} }
            };

            await game.dice3d.showForRoll(diceSoNiceRoll, game.user, true);
        }

        await parsedRoll.evaluate();

        const results = parsedRoll.dice[dice].results.map(result => ({
            ...result,
            discarded: !result.active
        }));
        const newResult = results.splice(results.length - 1, 1);
        results.splice(Number(result) + 1, 0, newResult[0]);

        const rerolledDice = parsedRoll.dice.map((x, index) => {
            const isRerollDice = index === Number(dice);
            if (!isRerollDice) return { ...x, dice: x.denomination };
            return {
                dice: parsedRoll.dice[dice].denomination,
                total: parsedRoll.dice[dice].total,
                results: results.map(result => ({
                    ...result,
                    hasRerolls: result.hasRerolls || isRerollDice
                }))
            };
        });

        const updateMessage = game.messages.get(message._id);
        const damageParts = updateMessage.system.damage[damageType].parts.map((damagePart, index) => {
            if (index !== Number(part)) return damagePart;
            return {
                ...rollPart,
                total: parsedRoll.total,
                dice: rerolledDice
            };
        });
        await updateMessage.update({
            [`system.damage.${damageType}`]: {
                ...updateMessage,
                total: parsedRoll.total,
                parts: damageParts
            }
        });

        Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.TagTeamRoll });
        await game.socket.emit(`system.${CONFIG.DH.id}`, {
            action: socketEvent.Refresh,
            data: {
                refreshType: RefreshType.TagTeamRoll
            }
        });
    }
}

class DualityRoll extends D20Roll {
    _advantageFaces = 6;
    _advantageNumber = 1;
    _rallyIndex;

    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
        this.rallyChoices = this.setRallyChoices();
    }

    static messageType = 'dualityRoll';

    static DefaultDialog = D20RollDialog;

    get title() {
        return game.i18n.localize(
            `DAGGERHEART.GENERAL.${this.options?.actionType === CONFIG.DH.ITEM.actionTypes.reaction.id ? 'reactionRoll' : 'dualityRoll'}`
        );
    }

    get dHope() {
        // if ( !(this.terms[0] instanceof foundry.dice.terms.Die) ) return;
        if (!(this.dice[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        return this.dice[0];
        // return this.#hopeDice;
    }

    set dHope(faces) {
        if (!(this.dice[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        this.terms[0].faces = this.getFaces(faces);
        // this.#hopeDice = `d${face}`;
    }

    get dFear() {
        // if ( !(this.terms[1] instanceof foundry.dice.terms.Die) ) return;
        if (!(this.dice[1] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        return this.dice[1];
        // return this.#fearDice;
    }

    set dFear(faces) {
        if (!(this.dice[1] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        this.dice[1].faces = this.getFaces(faces);
        // this.#fearDice = `d${face}`;
    }

    get dAdvantage() {
        return this.dice[2];
    }

    get advantageFaces() {
        return this._advantageFaces;
    }

    set advantageFaces(faces) {
        this._advantageFaces = this.getFaces(faces);
    }

    get advantageNumber() {
        return this._advantageNumber;
    }

    set advantageNumber(value) {
        this._advantageNumber = Number(value);
    }

    setRallyChoices() {
        return this.data?.parent?.appliedEffects.reduce((a, c) => {
            const change = c.changes.find(ch => ch.key === 'system.bonuses.rally');
            if (change) a.push({ value: c.id, label: change.value });
            return a;
        }, []);
    }

    get dRally() {
        if (!this.rallyFaces) return null;
        if (this.hasDisadvantage || this.hasAdvantage) return this.dice[3];
        else return this.dice[2];
    }

    get rallyFaces() {
        const rallyChoice = this.rallyChoices?.find(r => r.value === this._rallyIndex)?.label;
        return rallyChoice ? this.getFaces(rallyChoice) : null;
    }

    get isCritical() {
        if (!this.dHope._evaluated || !this.dFear._evaluated) return;
        return this.dHope.total === this.dFear.total;
    }

    get withHope() {
        if (!this._evaluated) return;
        return this.dHope.total > this.dFear.total;
    }

    get withFear() {
        if (!this._evaluated) return;
        return this.dHope.total < this.dFear.total;
    }

    get totalLabel() {
        const label = this.withHope
            ? 'DAGGERHEART.GENERAL.hope'
            : this.withFear
              ? 'DAGGERHEART.GENERAL.fear'
              : 'DAGGERHEART.GENERAL.criticalSuccess';

        return game.i18n.localize(label);
    }

    static getHooks(hooks) {
        return [...(hooks ?? []), 'Duality'];
    }

    /** @inheritDoc */
    static fromData(data) {
        data.terms[0].class = foundry.dice.terms.Die.name;
        data.terms[2].class = foundry.dice.terms.Die.name;
        return super.fromData(data);
    }

    createBaseDice() {
        if (this.dice[0] instanceof foundry.dice.terms.Die && this.dice[1] instanceof foundry.dice.terms.Die) {
            this.terms = [this.terms[0], this.terms[1], this.terms[2]];
            return;
        }
        this.terms[0] = new foundry.dice.terms.Die({ faces: 12 });
        this.terms[1] = new foundry.dice.terms.OperatorTerm({ operator: '+' });
        this.terms[2] = new foundry.dice.terms.Die({ faces: 12 });
    }

    applyAdvantage() {
        if (this.hasAdvantage || this.hasDisadvantage) {
            const dieFaces = this.advantageFaces,
                advDie = new foundry.dice.terms.Die({ faces: dieFaces, number: this.advantageNumber });
            if (this.advantageNumber > 1) advDie.modifiers = ['kh'];
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: this.hasDisadvantage ? '-' : '+' }),
                advDie
            );
        }
        if (this.rallyFaces)
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: this.hasDisadvantage ? '-' : '+' }),
                new foundry.dice.terms.Die({ faces: this.rallyFaces })
            );
    }

    applyBaseBonus() {
        const modifiers = super.applyBaseBonus();

        if (this.options.roll.trait && this.data.traits?.[this.options.roll.trait])
            modifiers.unshift({
                label:
                    this.options.roll.type === CONFIG.DH.GENERAL.rollTypes.spellcast.id
                        ? 'DAGGERHEART.CONFIG.RollTypes.spellcast.name'
                        : `DAGGERHEART.CONFIG.Traits.${this.options.roll.trait}.name`,
                value: this.data.traits[this.options.roll.trait].value
            });

        const weapons = ['primaryWeapon', 'secondaryWeapon'];
        weapons.forEach(w => {
            if (this.options.source.item && this.options.source.item === this.data[w]?.id)
                modifiers.push(...this.getBonus(`roll.${w}`, 'Weapon Bonus'));
        });

        return modifiers;
    }

    static async buildEvaluate(roll, config = {}, message = {}) {
        await super.buildEvaluate(roll, config, message);

        await setDiceSoNiceForDualityRoll(
            roll,
            config.roll.advantage.type,
            config.roll.hope.dice,
            config.roll.fear.dice,
            config.roll.advantage.dice
        );
    }

    static postEvaluate(roll, config = {}) {
        const data = super.postEvaluate(roll, config);

        data.hope = {
            dice: roll.dHope.denomination,
            value: roll.dHope.total,
            rerolled: {
                any: roll.dHope.results.some(x => x.rerolled),
                rerolls: roll.dHope.results.filter(x => x.rerolled)
            }
        };
        data.fear = {
            dice: roll.dFear.denomination,
            value: roll.dFear.total,
            rerolled: {
                any: roll.dFear.results.some(x => x.rerolled),
                rerolls: roll.dFear.results.filter(x => x.rerolled)
            }
        };
        data.rally = {
            dice: roll.dRally?.denomination,
            value: roll.dRally?.total
        };
        data.result = {
            duality: roll.withHope ? 1 : roll.withFear ? -1 : 0,
            total: roll.dHope.total + roll.dFear.total,
            label: roll.totalLabel
        };

        if (roll._rallyIndex && roll.data?.parent)
            roll.data.parent.deleteEmbeddedDocuments('ActiveEffect', [roll._rallyIndex]);

        return data;
    }

    static async reroll(rollString, target, message) {
        let parsedRoll = game.system.api.dice.DualityRoll.fromData({ ...rollString, evaluated: false });
        const term = parsedRoll.terms[target.dataset.dieIndex];
        await term.reroll(`/r1=${term.total}`);
        if (game.modules.get('dice-so-nice')?.active) {
            const diceSoNiceRoll = {
                _evaluated: true,
                dice: [
                    new foundry.dice.terms.Die({
                        ...term,
                        faces: term._faces,
                        results: term.results.filter(x => !x.rerolled)
                    })
                ],
                options: { appearance: {} }
            };

            const diceSoNicePresets = await getDiceSoNicePresets(`d${term._faces}`, `d${term._faces}`);
            const type = target.dataset.type;
            if (diceSoNicePresets[type]) {
                diceSoNiceRoll.dice[0].options = diceSoNicePresets[type];
            }

            await game.dice3d.showForRoll(diceSoNiceRoll, game.user, true);
        }

        await parsedRoll.evaluate();

        const newRoll = game.system.api.dice.DualityRoll.postEvaluate(parsedRoll, {
            targets: message.system.targets,
            roll: {
                advantage: message.system.roll.advantage?.type,
                difficulty: message.system.roll.difficulty ? Number(message.system.roll.difficulty) : null
            }
        });
        newRoll.extra = newRoll.extra.slice(2);

        const tagTeamSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
        Hooks.call(`${CONFIG.DH.id}.postRollDuality`, {
            source: { actor: message.system.source.actor ?? '' },
            targets: message.system.targets,
            tagTeamSelected: Object.values(tagTeamSettings.members).some(x => x.messageId === message._id),
            roll: newRoll,
            rerolledRoll:
                newRoll.result.duality !== message.system.roll.result.duality ? message.system.roll : undefined
        });
        return { newRoll, parsedRoll };
    }
}

var dice = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaseRoll: BaseRoll,
    D20Roll: D20Roll,
    DHRoll: DHRoll,
    DamageRoll: DamageRoll,
    DualityRoll: DualityRoll
});

class RegisterHandlebarsHelpers {
    static registerHelpers() {
        Handlebars.registerHelper({
            add: this.add,
            includes: this.includes,
            times: this.times,
            damageFormula: this.damageFormula,
            formulaValue: this.formulaValue,
            damageSymbols: this.damageSymbols,
            rollParsed: this.rollParsed,
            hasProperty: foundry.utils.hasProperty,
            getProperty: foundry.utils.getProperty,
            setVar: this.setVar,
            empty: this.empty,
            pluralize: this.pluralize,
            positive: this.positive,
            isNullish: this.isNullish
        });
    }
    static add(a, b) {
        const aNum = Number.parseInt(a);
        const bNum = Number.parseInt(b);
        return (Number.isNaN(aNum) ? 0 : aNum) + (Number.isNaN(bNum) ? 0 : bNum);
    }

    static includes(list, item) {
        return list.includes(item);
    }

    static times(nr, block) {
        var accum = '';
        for (var i = 0; i < nr; ++i) accum += block.fn(i);
        return accum;
    }

    static damageFormula(attack) {
        return attack.getDamageFormula();
    }

    static formulaValue(formula, item) {
        if (isNaN(formula)) {
            const data = item.getRollData.bind(item)(),
                roll = new Roll(Roll.replaceFormulaData(formula, data)).evaluateSync();
            formula = roll.total;
        }
        return formula;
    }

    static damageSymbols(damageParts) {
        const symbols = [...new Set(damageParts.reduce((a, c) => a.concat([...c.type]), []))].map(
            p => CONFIG.DH.GENERAL.damageTypes[p].icon
        );
        return new Handlebars.SafeString(Array.from(symbols).map(symbol => `<i class="fa-solid ${symbol}"></i>`));
    }

    static rollParsed(value, actor, item, numerical) {
        const isNumerical = typeof numerical === 'boolean' ? numerical : false;
        const result = itemAbleRollParse(value, actor?.getRollData() ?? {}, item);
        return isNumerical ? (!result ? 0 : Number(result)) : result;
    }

    static setVar(name, value) {
        this[name] = value;
    }

    static empty(object) {
        if (!(typeof object === 'object')) return true;
        return Object.keys(object).length === 0;
    }

    /**
     * Pluralize helper that returns the appropriate localized string based on count
     * @param {number} count - The number to check for plurality
     * @param {string} baseKey - The base localization key (e.g., "DAGGERHEART.GENERAL.Target")
     * @returns {string} The localized singular or plural string
     *
     * Usage: {{pluralize currentTargets.length "DAGGERHEART.GENERAL.Target"}}
     * Returns: "Target" if count is exactly 1, "Targets" if count is 0, 2+, or invalid
     */
    static pluralize(count, baseKey) {
        const numericCount = Number(count);
        const isSingular = !isNaN(numericCount) && numericCount === 1;
        const key = isSingular ? `${baseKey}.single` : `${baseKey}.plural`;
        return game.i18n.localize(key);
    }

    static positive(a) {
        return Math.abs(Number(a));
    }

    static isNullish(a) {
        return a === null || a === undefined;
    }
}

/**
 * @param {string} paramString The parameter inside the brackets of something like @Template[] to parse
 * @param {Object} options
 * @param {string} options.first If set, the first parameter is treated as a value with this as its key
 * @returns {Record<string, string | undefined> | null}
 */
function parseInlineParams(paramString, { first } = {}) {
    const parts = paramString.split('|').map(x => x.trim());
    const params = {};
    for (const [idx, param] of parts.entries()) {
        if (first && idx === 0) {
            params[first] = param;
        } else {
            const parts = param.split(':');
            params[parts[0]] = parts.length > 1 ? parts[1] : true;
        }
    }

    return params;
}

function DhDamageEnricher(match, _options) {
    const { value, type, inline } = parseInlineParams(match[1]);
    if (!value || !type) return match[0];
    return getDamageMessage(value, type, inline, match[0]);
}

function getDamageMessage(damage, type, inline, defaultElement) {
    const typeIcons = type
        .replace('[', '')
        .replace(']', '')
        .split(',')
        .map(x => x.trim())
        .map(x => {
            return CONFIG.DH.GENERAL.damageTypes[x]?.icon ?? null;
        })
        .filter(x => x);

    if (!typeIcons.length) return defaultElement;

    const iconNodes = typeIcons.map(x => `<i class="fa-solid ${x}"></i>`).join('');

    const dualityElement = document.createElement('span');
    dualityElement.innerHTML = `
        <button type="button" class="enriched-damage-button${inline ? ' inline' : ''}" 
            data-value="${damage}"
            data-type="${type}"
            data-tooltip="${game.i18n.localize('DAGGERHEART.GENERAL.damage')}"
        >
            ${damage}
            ${iconNodes}
        </button>
    `;

    return dualityElement;
}

const renderDamageButton = async event => {
    const button = event.currentTarget,
        value = button.dataset.value,
        type = button.dataset.type
            .replace('[', '')
            .replace(']', '')
            .split(',')
            .map(x => x.trim());

    const config = {
        event: event,
        title: game.i18n.localize('Damage Roll'),
        data: { bonuses: [] },
        source: {},
        hasDamage: true,
        hasTarget: true,
        targets: Array.from(game.user.targets).map(t =>
            game.system.api.fields.ActionFields.TargetField.formatTarget(t)
        ),
        roll: [
            {
                formula: value,
                applyTo: CONFIG.DH.GENERAL.healingTypes.hitPoints.id,
                type: type
            }
        ]
    };

    CONFIG.Dice.daggerheart.DamageRoll.build(config);
};

function DhDualityRollEnricher(match, _options) {
    const roll = rollCommandToJSON(match[1], match[0]);
    if (!roll) return match[0];

    return getDualityMessage(roll.result, roll.flavor);
}

function getDualityMessage(roll, flavor) {
    const trait = roll?.trait && abilities[roll.trait] ? game.i18n.localize(abilities[roll.trait].label) : null;
    const label =
        flavor ??
        (roll?.trait
            ? game.i18n.format('DAGGERHEART.GENERAL.rollWith', { roll: trait })
            : roll?.reaction
              ? game.i18n.localize('DAGGERHEART.GENERAL.reactionRoll')
              : game.i18n.localize('DAGGERHEART.GENERAL.duality'));

    const dataLabel = trait
        ? game.i18n.localize(abilities[roll.trait].label)
        : game.i18n.localize('DAGGERHEART.GENERAL.duality');

    const advantage = roll?.advantage
        ? CONFIG.DH.ACTIONS.advantageState.advantage.value
        : roll?.disadvantage
          ? CONFIG.DH.ACTIONS.advantageState.disadvantage.value
          : undefined;
    const advantageLabel =
        advantage === CONFIG.DH.ACTIONS.advantageState.advantage.value
            ? 'Advantage'
            : advantage === CONFIG.DH.ACTIONS.advantageState.disadvantage.value
              ? 'Disadvantage'
              : undefined;

    const dualityElement = document.createElement('span');
    dualityElement.innerHTML = `
        <button type="button" class="duality-roll-button${roll?.inline ? ' inline' : ''}" 
            data-title="${label}"
            data-label="${dataLabel}"
            data-reaction="${roll?.reaction ? 'true' : 'false'}"
            data-hope="${roll?.hope ?? 'd12'}" 
            data-fear="${roll?.fear ?? 'd12'}"
            ${advantage ? `data-advantage="${advantage}"` : ''}
            ${roll?.difficulty !== undefined ? `data-difficulty="${roll.difficulty}"` : ''}
            ${roll?.trait && abilities[roll.trait] ? `data-trait="${roll.trait}"` : ''}
            ${roll?.advantage ? 'data-advantage="true"' : ''}
            ${roll?.disadvantage ? 'data-disadvantage="true"' : ''}
        >
            ${roll?.reaction ? '<i class="fa-solid fa-reply"></i>' : '<i class="fa-solid fa-circle-half-stroke"></i>'}
            ${label}
            ${!flavor && (roll?.difficulty || advantageLabel) ? `(${[roll.difficulty, advantageLabel ? game.i18n.localize(`DAGGERHEART.GENERAL.${advantageLabel}.short`) : null].filter(x => x).join(' ')})` : ''}
        </button>
    `;

    return dualityElement;
}

const renderDualityButton = async event => {
    const button = event.currentTarget,
        reaction = button.dataset.reaction === 'true',
        traitValue = button.dataset.trait?.toLowerCase(),
        target = getCommandTarget({ allowNull: true }),
        difficulty = button.dataset.difficulty,
        advantage = button.dataset.advantage ? Number(button.dataset.advantage) : undefined;

    await enrichedDualityRoll(
        {
            reaction,
            traitValue,
            target,
            difficulty,
            title: button.dataset.title,
            label: button.dataset.label,
            advantage
        },
        event
    );
};

const enrichedDualityRoll = async (
    { reaction, traitValue, target, difficulty, title, label, advantage },
    event
) => {
    const config = {
        event: event ?? {},
        title: title,
        roll: {
            trait: traitValue && target ? traitValue : null,
            label: label,
            difficulty: difficulty,
            advantage,
            type: reaction ? 'reaction' : null
        },
        type: 'trait',
        hasRoll: true
    };

    if (target) {
        await target.diceRoll(config);
    } else {
        // For no target, call DualityRoll directly with basic data
        config.data = { experiences: {}, traits: {} };
        config.source = { actor: null };
        await CONFIG.Dice.daggerheart.DualityRoll.build(config);
    }
};

async function DhEffectEnricher(match, _options) {
    const effect = await foundry.utils.fromUuid(match[1]);
    if (!effect) return match[0];

    const dualityElement = document.createElement('span');
    dualityElement.innerHTML = `
        <a class="flexrow enriched-effect" 
            data-link
            draggable="true"
            data-uuid="${match[1]}"
            data-tooltip="${game.i18n.localize('DAGGERHEART.UI.Tooltip.dragApplyEffect')}"
        >
            <img src="icons/svg/aura.svg" style="width: 24px;" />
            <span>${effect.name}</span>
        </a>
    `;

    return dualityElement;
}

function DhTemplateEnricher(match, _options) {
    const params = parseInlineParams(match[1]);
    const { type, angle = CONFIG.MeasuredTemplate.defaults.angle, inline = false } = params;
    const direction = Number(params.direction) || 0;
    const range =
        params.range && Number.isNaN(Number(params.range))
            ? Object.values(CONFIG.DH.GENERAL.templateRanges).find(
                  x => x.id.toLowerCase() === params.range || x.short === params.range
              )?.id
            : params.range;

    if (!Object.values(CONFIG.DH.GENERAL.templateTypes).find(x => x === type) || !range) return match[0];

    const label = game.i18n.localize(`DAGGERHEART.CONFIG.TemplateTypes.${type}`);
    const rangeDisplay = Number.isNaN(Number(range))
        ? game.i18n.localize(`DAGGERHEART.CONFIG.Range.${range}.name`)
        : range;

    let angleDisplay = '';
    if (angle != CONFIG.MeasuredTemplate.defaults.angle) {
        angleDisplay = 'angle:' + angle;
    }
    let directionDisplay = '';
    if (direction != 0) {
        directionDisplay = 'direction:' + direction;
    }

    let extraDisplay = '';
    if (angleDisplay != '' && directionDisplay != '') {
        extraDisplay = ' (' + angleDisplay + '|' + directionDisplay + ')';
    } else if (angleDisplay != '') {
        extraDisplay = ' (' + angleDisplay + ')';
    } else if (directionDisplay != '') {
        extraDisplay = ' (' + directionDisplay + ')';
    }

    const templateElement = document.createElement('span');
    templateElement.innerHTML = `
        <button type="button" class="measured-template-button${inline ? ' inline' : ''}" 
            data-type="${type}" data-range="${range}" data-angle="${angle}" data-direction="${direction}">
            ${label} - ${rangeDisplay}${extraDisplay}
        </button>
    `;

    return templateElement;
}

const renderMeasuredTemplate = async event => {
    const button = event.currentTarget,
        type = button.dataset.type,
        range = button.dataset.range,
        angle = button.dataset.angle,
        direction = button.dataset.direction;

    if (!type || !range || !game.canvas.scene) return;

    const usedType = type === 'inFront' ? 'cone' : type === 'emanation' ? 'circle' : type;
    const usedAngle =
        type === CONST.MEASURED_TEMPLATE_TYPES.CONE
            ? (angle ?? CONFIG.MeasuredTemplate.defaults.angle)
            : type === CONFIG.DH.GENERAL.templateTypes.INFRONT
              ? '180'
              : undefined;

    let baseDistance = range;
    if (Number.isNaN(Number(range))) {
        baseDistance = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).rangeMeasurement[
            range
        ];
    }
    const distance = type === CONFIG.DH.GENERAL.templateTypes.EMANATION ? baseDistance + 2.5 : baseDistance;

    const { width, height } = game.canvas.scene.dimensions;
    const data = {
        x: width / 2,
        y: height / 2,
        t: usedType,
        distance: distance,
        width: type === CONST.MEASURED_TEMPLATE_TYPES.RAY ? 5 : undefined,
        angle: usedAngle,
        direction: direction
    };

    CONFIG.ux.TemplateManager.createPreview(data);
};

function DhLookupEnricher(match, { rollData }) {
    const results = parseInlineParams(match[1], { first: 'formula' });
    const element = document.createElement('span');
    element.textContent = Roll.replaceFormulaData(String(results.formula), rollData);
    return element;
}

const enricherConfig = [
    {
        pattern: /@Damage\[([^\[\]]*)\]({[^}]*})?/g,
        enricher: DhDamageEnricher
    },
    {
        pattern: /\[\[\/dr\s?(.*?)\]\]({[^}]*})?/g,
        enricher: DhDualityRollEnricher
    },
    {
        pattern: /@Effect\[([^\[\]]*)\]({[^}]*})?/g,
        enricher: DhEffectEnricher
    },
    {
        pattern: /@Template\[([^\[\]]*)\]({[^}]*})?/g,
        enricher: DhTemplateEnricher
    },
    {
        pattern: /@Lookup\[([^\[\]]*)\]({[^}]*})?/g,
        enricher: DhLookupEnricher
    }
];

const enricherRenderSetup = element => {
    element
        .querySelectorAll('.enriched-damage-button')
        .forEach(element => element.addEventListener('click', renderDamageButton));

    element
        .querySelectorAll('.duality-roll-button')
        .forEach(element => element.addEventListener('click', renderDualityButton));

    element
        .querySelectorAll('.measured-template-button')
        .forEach(element => element.addEventListener('click', renderMeasuredTemplate));

    // element
    //     .querySelectorAll('.enriched-effect')
    //     .forEach(element => element.addEventListener('dragstart', dragEnrichedEffect));
};

const preloadHandlebarsTemplates = async function () {
    foundry.applications.handlebars.loadTemplates({
        'daggerheart.inventory-item-compact':
            'systems/daggerheart/templates/sheets/global/partials/inventory-item-compact.hbs',
        'daggerheart.inventory-items':
            'systems/daggerheart/templates/sheets/global/partials/inventory-fieldset-items-V2.hbs',
        'daggerheart.inventory-item': 'systems/daggerheart/templates/sheets/global/partials/inventory-item-V2.hbs'
    });
    return foundry.applications.handlebars.loadTemplates([
        'templates/generic/tab-navigation.hbs',
        'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs',
        'systems/daggerheart/templates/sheets/global/partials/action-item.hbs',
        'systems/daggerheart/templates/sheets/global/partials/domain-card-item.hbs',
        'systems/daggerheart/templates/sheets/global/partials/item-resource.hbs',
        'systems/daggerheart/templates/sheets/global/partials/resource-section/resource-section.hbs',
        'systems/daggerheart/templates/sheets/global/partials/resource-section/simple.hbs',
        'systems/daggerheart/templates/sheets/global/partials/resource-section/dice-value.hbs',
        'systems/daggerheart/templates/sheets/global/partials/resource-section/die.hbs',
        'systems/daggerheart/templates/sheets/global/partials/resource-bar.hbs',
        'systems/daggerheart/templates/components/card-preview.hbs',
        'systems/daggerheart/templates/levelup/parts/selectable-card-preview.hbs',
        'systems/daggerheart/templates/sheets/global/partials/feature-section-item.hbs',
        'systems/daggerheart/templates/ui/combatTracker/combatTrackerSection.hbs',
        'systems/daggerheart/templates/actionTypes/damage.hbs',
        'systems/daggerheart/templates/actionTypes/resource.hbs',
        'systems/daggerheart/templates/actionTypes/macro.hbs',
        'systems/daggerheart/templates/actionTypes/uses.hbs',
        'systems/daggerheart/templates/actionTypes/roll.hbs',
        'systems/daggerheart/templates/actionTypes/save.hbs',
        'systems/daggerheart/templates/actionTypes/cost.hbs',
        'systems/daggerheart/templates/actionTypes/range-target.hbs',
        'systems/daggerheart/templates/actionTypes/effect.hbs',
        'systems/daggerheart/templates/actionTypes/beastform.hbs',
        'systems/daggerheart/templates/actionTypes/countdown.hbs',
        'systems/daggerheart/templates/settings/components/settings-item-line.hbs',
        'systems/daggerheart/templates/ui/tooltip/parts/tooltipChips.hbs',
        'systems/daggerheart/templates/ui/tooltip/parts/tooltipTags.hbs',
        'systems/daggerheart/templates/dialogs/downtime/activities.hbs',
        'systems/daggerheart/templates/dialogs/dice-roll/costSelection.hbs',
        'systems/daggerheart/templates/ui/chat/parts/roll-part.hbs',
        'systems/daggerheart/templates/ui/chat/parts/damage-part.hbs',
        'systems/daggerheart/templates/ui/chat/parts/target-part.hbs',
        'systems/daggerheart/templates/ui/chat/parts/button-part.hbs',
        'systems/daggerheart/templates/ui/itemBrowser/itemContainer.hbs',
        'systems/daggerheart/templates/scene/dh-config.hbs'
    ]);
};

const registerDHSettings = () => {
    registerMenuSettings();
    registerMenus();
    registerNonConfigSettings();
};

const registerMenuSettings = () => {
    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules, {
        scope: 'world',
        config: false,
        type: DhVariantRules
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation, {
        scope: 'world',
        config: false,
        type: DhAutomation
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew, {
        scope: 'world',
        config: false,
        type: DhHomebrew,
        onChange: value => {
            if (value.maxFear) {
                if (ui.resources) ui.resources.render({ force: true });
            }
        }
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance, {
        scope: 'client',
        config: false,
        type: DhAppearance,
        onChange: value => {
            if (value.displayFear) {
                if (ui.resources) {
                    if (value.displayFear === 'hide') ui.resources.close({ allowed: true });
                    else ui.resources.render({ force: true });
                }
            }
        }
    });
};

const registerMenus = () => {
    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.menu.Automation.Name, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.automation.name'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.automation.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.automation.hint'),
        icon: CONFIG.DH.SETTINGS.menu.Automation.Icon,
        type: DhAutomationSettings,
        restricted: true
    });
    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.menu.Homebrew.Name, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.name'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.hint'),
        icon: CONFIG.DH.SETTINGS.menu.Homebrew.Icon,
        type: DhHomebrewSettings,
        restricted: true
    });

    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.appearance.label'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.appearance.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.appearance.hint'),
        icon: 'fa-solid fa-palette',
        type: DHAppearanceSettings,
        restricted: false
    });

    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.menu.VariantRules.Name, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.variantRules.title'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.variantRules.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.variantRules.hint'),
        icon: CONFIG.DH.SETTINGS.menu.VariantRules.Icon,
        type: DHVariantRuleSettings,
        restricted: true
    });
};

const registerNonConfigSettings = () => {
    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LastMigrationVersion, {
        scope: 'world',
        config: false,
        type: String
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers, {
        scope: 'world',
        config: false,
        type: DhLevelTiers,
        default: defaultLevelTiers
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Resources.fear.name'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Resources.fear.hint'),
        scope: 'world',
        config: false,
        type: Number,
        default: 0,
        onChange: () => {
            if (ui.resources) ui.resources.render({ force: true });
            ui.combat.render({ force: true });
        }
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, {
        scope: 'world',
        config: false,
        type: DhCountdowns$1
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll, {
        scope: 'world',
        config: false,
        type: DhTagTeamRoll
    });
};

async function runMigrations() {
    let lastMigrationVersion = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LastMigrationVersion);
    if (!lastMigrationVersion) lastMigrationVersion = game.system.version;

    //#region old migrations
    if (foundry.utils.isNewerVersion('1.1.0', lastMigrationVersion)) {
        const lockedPacks = [];
        const compendiumActors = [];
        for (let pack of game.packs) {
            if (pack.locked) {
                lockedPacks.push(pack.collection);
                await pack.configure({ locked: false });
            }
            const documents = await pack.getDocuments();
            compendiumActors.push(...documents.filter(x => x.type === 'character'));
        }

        [...compendiumActors, ...game.actors].forEach(actor => {
            const items = actor.items.reduce((acc, item) => {
                if (item.type === 'feature') {
                    const { originItemType, isMulticlass, identifier } = item.system;
                    const base = originItemType
                        ? actor.items.find(
                              x => x.type === originItemType && Boolean(isMulticlass) === Boolean(x.system.isMulticlass)
                          )
                        : null;
                    if (base) {
                        const feature = base.system.features.find(x => x.item && x.item.uuid === item.uuid);
                        if (feature && identifier !== 'multiclass') {
                            acc.push({ _id: item.id, system: { identifier: feature.type } });
                        }
                    }
                }

                return acc;
            }, []);

            actor.updateEmbeddedDocuments('Item', items);
        });

        for (let packId of lockedPacks) {
            const pack = game.packs.get(packId);
            await pack.configure({ locked: true });
        }

        lastMigrationVersion = '1.1.0';
    }

    if (foundry.utils.isNewerVersion('1.1.1', lastMigrationVersion)) {
        const lockedPacks = [];
        const compendiumClasses = [];
        const compendiumActors = [];
        for (let pack of game.packs) {
            if (pack.locked) {
                lockedPacks.push(pack.collection);
                await pack.configure({ locked: false });
            }
            const documents = await pack.getDocuments();
            compendiumClasses.push(...documents.filter(x => x.type === 'class'));
            compendiumActors.push(...documents.filter(x => x.type === 'character'));
        }

        [...compendiumActors, ...game.actors.filter(x => x.type === 'character')].forEach(char => {
            const multiclass = char.items.find(x => x.type === 'class' && x.system.isMulticlass);
            const multiclassSubclass =
                multiclass?.system?.subclasses?.length > 0 ? multiclass.system.subclasses[0] : null;
            char.items.forEach(item => {
                if (item.type === 'feature' && item.system.identifier === 'multiclass') {
                    const base = item.system.originItemType === 'class' ? multiclass : multiclassSubclass;
                    if (base) {
                        const baseFeature = base.system.features.find(x => x.item.name === item.name);
                        if (baseFeature) {
                            item.update({
                                system: {
                                    multiclassOrigin: true,
                                    identifier: baseFeature.type
                                }
                            });
                        }
                    }
                }
            });
        });

        const worldClasses = game.items.filter(x => x.type === 'class');
        for (let classVal of [...compendiumClasses, ...worldClasses]) {
            for (let subclass of classVal.system.subclasses) {
                await subclass.update({ 'system.linkedClass': classVal.uuid });
            }
        }

        for (let packId of lockedPacks) {
            const pack = game.packs.get(packId);
            await pack.configure({ locked: true });
        }

        lastMigrationVersion = '1.1.1';
    }

    if (foundry.utils.isNewerVersion('1.2.0', lastMigrationVersion)) {
        /* Migrate old action costs */
        const lockedPacks = [];
        const compendiumItems = [];
        for (let pack of game.packs) {
            if (pack.locked) {
                lockedPacks.push(pack.collection);
                await pack.configure({ locked: false });
            }
            const documents = await pack.getDocuments();

            compendiumItems.push(...documents.filter(x => x.system?.metadata?.hasActions));
            compendiumItems.push(
                ...documents
                    .filter(x => x.items)
                    .flatMap(actor => actor.items.filter(x => x.system?.metadata?.hasActions))
            );
        }

        const worldItems = game.items.filter(x => x.system.metadata.hasActions);
        const worldActorItems = Array.from(game.actors).flatMap(actor =>
            actor.items.filter(x => x.system.metadata.hasActions)
        );

        const validCostKeys = Object.keys(CONFIG.DH.GENERAL.abilityCosts);
        for (let item of [...worldItems, ...worldActorItems, ...compendiumItems]) {
            for (let action of item.system.actions) {
                const resourceCostIndexes = Object.keys(action.cost).reduce(
                    (acc, index) => (!validCostKeys.includes(action.cost[index].key) ? [...acc, Number(index)] : acc),
                    []
                );
                if (resourceCostIndexes.length === 0) continue;

                await action.update({
                    cost: action.cost.map((cost, index) => {
                        const { keyIsID, ...rest } = cost;
                        if (!resourceCostIndexes.includes(index)) return { ...rest };

                        return {
                            ...rest,
                            key: 'resource',
                            itemId: cost.key
                        };
                    })
                });
            }
        }

        for (let packId of lockedPacks) {
            const pack = game.packs.get(packId);
            await pack.configure({ locked: true });
        }

        /* Migrate old countdown structure */
        const countdownSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        const getCountdowns = (data, type) => {
            return Object.keys(data.countdowns).reduce((acc, key) => {
                const countdown = data.countdowns[key];
                acc[key] = {
                    ...countdown,
                    type: type,
                    ownership: Object.keys(countdown.ownership.players).reduce((acc, key) => {
                        acc[key] =
                            countdown.ownership.players[key].type === 1 ? 2 : countdown.ownership.players[key].type;
                        return acc;
                    }, {}),
                    progress: {
                        ...countdown.progress,
                        type: countdown.progress.type.value
                    }
                };

                return acc;
            }, {});
        };

        await countdownSettings.updateSource({
            countdowns: {
                ...getCountdowns(countdownSettings.narrative, CONFIG.DH.GENERAL.countdownBaseTypes.narrative.id),
                ...getCountdowns(countdownSettings.encounter, CONFIG.DH.GENERAL.countdownBaseTypes.encounter.id)
            }
        });
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, countdownSettings);

        game.socket.emit(`system.${CONFIG.DH.id}`, {
            action: socketEvent.Refresh,
            data: { refreshType: RefreshType.Countdown }
        });
        Hooks.callAll(socketEvent.Refresh, { refreshType: RefreshType.Countdown });

        lastMigrationVersion = '1.2.0';
    }

    if (foundry.utils.isNewerVersion('1.2.7', lastMigrationVersion)) {
        const tagTeam = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll);
        const initatorMissing = tagTeam.initiator && !game.actors.some(actor => actor.id === tagTeam.initiator);
        const missingMembers = Object.keys(tagTeam.members).reduce((acc, id) => {
            if (!game.actors.some(actor => actor.id === id)) {
                acc[`-=${id}`] = null;
            }
            return acc;
        }, {});

        await tagTeam.updateSource({
            initiator: initatorMissing ? null : tagTeam.initiator,
            members: missingMembers
        });
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.TagTeamRoll, tagTeam);

        lastMigrationVersion = '1.2.7';
    }
    //#endregion

    await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LastMigrationVersion, lastMigrationVersion);
}

class DhMeasuredTemplate extends foundry.canvas.placeables.MeasuredTemplate {
    _refreshRulerText() {
        super._refreshRulerText();

        const rangeMeasurementSettings = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.variantRules
        ).rangeMeasurement;
        if (rangeMeasurementSettings.enabled) {
            const splitRulerText = this.ruler.text.split(' ');
            if (splitRulerText.length > 0) {
                const rulerValue = Number(splitRulerText[0]);
                const result = DhMeasuredTemplate.getRangeLabels(rulerValue, rangeMeasurementSettings);
                this.ruler.text = result.distance + (result.units ? ' ' + result.units : '');
            }
        }
    }

    static getRangeLabels(distanceValue, settings) {
        let result = { distance: distanceValue, units: '' };
        const sceneRangeMeasurement = canvas.scene.flags.daggerheart?.rangeMeasurement;

        const { disable, custom } = CONFIG.DH.GENERAL.sceneRangeMeasurementSetting;
        if (sceneRangeMeasurement?.setting === disable.id) {
            result.distance = distanceValue;
            result.units = canvas.scene?.grid?.units;
            return result;
        }

        const melee = sceneRangeMeasurement?.setting === custom.id ? sceneRangeMeasurement.melee : settings.melee;
        const veryClose =
            sceneRangeMeasurement?.setting === custom.id ? sceneRangeMeasurement.veryClose : settings.veryClose;
        const close = sceneRangeMeasurement?.setting === custom.id ? sceneRangeMeasurement.close : settings.close;
        const far = sceneRangeMeasurement?.setting === custom.id ? sceneRangeMeasurement.far : settings.far;
        if (distanceValue <= melee) {
            result.distance = game.i18n.localize('DAGGERHEART.CONFIG.Range.melee.name');
            return result;
        }
        if (distanceValue <= veryClose) {
            result.distance = game.i18n.localize('DAGGERHEART.CONFIG.Range.veryClose.name');
            return result;
        }
        if (distanceValue <= close) {
            result.distance = game.i18n.localize('DAGGERHEART.CONFIG.Range.close.name');
            return result;
        }
        if (distanceValue <= far) {
            result.distance = game.i18n.localize('DAGGERHEART.CONFIG.Range.far.name');
            return result;
        }
        if (distanceValue > far) {
            result.distance = game.i18n.localize('DAGGERHEART.CONFIG.Range.veryFar.name');
        }

        return result;
    }
}

class DhpRuler extends foundry.canvas.interaction.Ruler {
    _getWaypointLabelContext(waypoint, state) {
        const context = super._getWaypointLabelContext(waypoint, state);
        if (!context) return;

        const range = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).rangeMeasurement;

        if (range.enabled) {
            const result = DhMeasuredTemplate.getRangeLabels(waypoint.measurement.distance.toNearest(0.01), range);
            context.cost = { total: result.distance, units: result.units };
            context.distance = { total: result.distance, units: result.units };
        }

        return context;
    }
}

class DhTemplateLayer extends foundry.canvas.layers.TemplateLayer {
    static prepareSceneControls() {
        const sc = foundry.applications.ui.SceneControls;
        return {
            name: 'templates',
            order: 2,
            title: 'CONTROLS.GroupMeasure',
            icon: 'fa-solid fa-ruler-combined',
            visible: game.user.can('TEMPLATE_CREATE'),
            onChange: (event, active) => {
                if (active) canvas.templates.activate();
            },
            onToolChange: () => canvas.templates.setAllRenderFlags({ refreshState: true }),
            tools: {
                circle: {
                    name: 'circle',
                    order: 1,
                    title: 'CONTROLS.MeasureCircle',
                    icon: 'fa-regular fa-circle',
                    toolclip: {
                        src: 'toolclips/tools/measure-circle.webm',
                        heading: 'CONTROLS.MeasureCircle',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete'])
                    }
                },
                cone: {
                    name: 'cone',
                    order: 2,
                    title: 'CONTROLS.MeasureCone',
                    icon: 'fa-solid fa-angle-left',
                    toolclip: {
                        src: 'toolclips/tools/measure-cone.webm',
                        heading: 'CONTROLS.MeasureCone',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                inFront: {
                    name: 'inFront',
                    order: 3,
                    title: 'CONTROLS.inFront',
                    icon: 'fa-solid fa-eye',
                    toolclip: {
                        src: 'toolclips/tools/measure-cone.webm',
                        heading: 'CONTROLS.inFront',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                rect: {
                    name: 'rect',
                    order: 4,
                    title: 'CONTROLS.MeasureRect',
                    icon: 'fa-regular fa-square',
                    toolclip: {
                        src: 'toolclips/tools/measure-rect.webm',
                        heading: 'CONTROLS.MeasureRect',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                ray: {
                    name: 'ray',
                    order: 5,
                    title: 'CONTROLS.MeasureRay',
                    icon: 'fa-solid fa-up-down',
                    toolclip: {
                        src: 'toolclips/tools/measure-ray.webm',
                        heading: 'CONTROLS.MeasureRay',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                clear: {
                    name: 'clear',
                    order: 6,
                    title: 'CONTROLS.MeasureClear',
                    icon: 'fa-solid fa-trash',
                    visible: game.user.isGM,
                    onChange: () => canvas.templates.deleteAll(),
                    button: true
                }
            },
            activeTool: 'circle'
        };
    }

    _onDragLeftStart(event) {
        const interaction = event.interactionData;

        // Snap the origin to the grid
        if (!event.shiftKey) interaction.origin = this.getSnappedPoint(interaction.origin);

        // Create a pending MeasuredTemplateDocument
        const tool = game.activeTool === 'inFront' ? 'cone' : game.activeTool;
        const previewData = {
            user: game.user.id,
            t: tool,
            x: interaction.origin.x,
            y: interaction.origin.y,
            sort: Math.max(this.getMaxSort() + 1, 0),
            distance: 1,
            direction: 0,
            fillColor: game.user.color || '#FF0000',
            hidden: event.altKey
        };
        const defaults = CONFIG.MeasuredTemplate.defaults;
        if (game.activeTool === 'cone') previewData.angle = defaults.angle;
        else if (game.activeTool === 'inFront') previewData.angle = 180;
        else if (game.activeTool === 'ray') previewData.width = defaults.width * canvas.dimensions.distance;
        const cls = foundry.utils.getDocumentClass('MeasuredTemplate');
        const doc = new cls(previewData, { parent: canvas.scene });

        // Create a preview MeasuredTemplate object
        const template = new this.constructor.placeableClass(doc);
        doc._object = template;
        interaction.preview = this.preview.addChild(template);
        template.draw();
    }
}

class DhTokenPlaceable extends foundry.canvas.placeables.Token {
    /** @inheritDoc */
    async _drawEffects() {
        this.effects.renderable = false;

        // Clear Effects Container
        this.effects.removeChildren().forEach(c => c.destroy());
        this.effects.bg = this.effects.addChild(new PIXI.Graphics());
        this.effects.bg.zIndex = -1;
        this.effects.overlay = null;

        // Categorize effects
        const activeEffects = this.actor?.getActiveEffects() ?? [];
        const overlayEffect = activeEffects.findLast(e => e.img && e.getFlag?.('core', 'overlay'));

        // Draw effects
        const promises = [];
        for (const [i, effect] of activeEffects.entries()) {
            if (!effect.img) continue;
            const promise =
                effect === overlayEffect
                    ? this._drawOverlay(effect.img, effect.tint)
                    : this._drawEffect(effect.img, effect.tint);
            promises.push(
                promise.then(e => {
                    if (e) e.zIndex = i;
                })
            );
        }
        await Promise.allSettled(promises);

        this.effects.sortChildren();
        this.effects.renderable = true;
        this.renderFlags.set({ refreshEffects: true });
    }

    /** @inheritDoc */
    _drawBar(number, bar, data) {
        const val = Number(data.value);
        Math.clamp(val, 0, data.max) / data.max;

        // Determine sizing
        const { width, height } = this.document.getSize();
        const s = canvas.dimensions.uiScale;
        const bw = width;
        const bh = 8 * (this.document.height >= 2 ? 1.5 : 1) * s;

        // Determine the color to use
        const fillColor =
            number === 0 ? foundry.utils.Color.fromRGB([1, 0, 0]) : foundry.utils.Color.fromString('#0032b1');

        // Draw the bar
        const widthUnit = bw / data.max;
        bar.clear().lineStyle(s, 0x000000, 1.0);
        const sections = [...Array(data.max).keys()];
        for (let mark of sections) {
            const x = mark * widthUnit;
            const marked = mark + 1 <= data.value;
            const color = marked ? fillColor : foundry.utils.Color.fromRGB([0, 0, 0]);
            if (mark === 0 || mark === sections.length - 1) {
                bar.beginFill(color, marked ? 1.0 : 0.5).drawRect(x, 0, widthUnit, bh, 2 * s); // Would like drawRoundedRect, but it's very troublsome with the corners. Leaving for now.
            } else {
                bar.beginFill(color, marked ? 1.0 : 0.5).drawRect(x, 0, widthUnit, bh, 2 * s);
            }
        }

        // Set position
        const posY = number === 0 ? height - bh : 0;
        bar.position.set(0, posY);
        return true;
    }
}

class DhpTokenRuler extends foundry.canvas.placeables.tokens.TokenRuler {
    _getWaypointLabelContext(waypoint, state) {
        const context = super._getWaypointLabelContext(waypoint, state);
        if (!context) return;

        const range = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).rangeMeasurement;

        if (range.enabled) {
            const result = DhMeasuredTemplate.getRangeLabels(waypoint.measurement.distance.toNearest(0.01), range);
            context.cost = { total: result.distance, units: result.units };
            context.distance = { total: result.distance, units: result.units };
        }

        return context;
    }
}

CONFIG.DH = SYSTEM;
CONFIG.TextEditor.enrichers.push(...enricherConfig);

CONFIG.Dice.rolls = [BaseRoll, DHRoll, DualityRoll, D20Roll, DamageRoll];
CONFIG.Dice.daggerheart = {
    DHRoll: DHRoll,
    DualityRoll: DualityRoll,
    D20Roll: D20Roll,
    DamageRoll: DamageRoll
};

CONFIG.Actor.documentClass = DhpActor;
CONFIG.Actor.dataModels = config$3;

CONFIG.Item.documentClass = DHItem;
CONFIG.Item.dataModels = config;

CONFIG.ActiveEffect.documentClass = DhActiveEffect;
CONFIG.ActiveEffect.dataModels = config$2;

CONFIG.Combat.documentClass = DhpCombat;
CONFIG.Combat.dataModels = { base: DhCombat };
CONFIG.Combatant.documentClass = DhCombatant;
CONFIG.Combatant.dataModels = { base: DhCombatant$1 };

CONFIG.ChatMessage.dataModels = config$1;
CONFIG.ChatMessage.documentClass = DhpChatMessage;
CONFIG.ChatMessage.template = 'systems/daggerheart/templates/ui/chat/chat-message.hbs';

CONFIG.Canvas.rulerClass = DhpRuler;
CONFIG.Canvas.layers.templates.layerClass = DhTemplateLayer;
CONFIG.MeasuredTemplate.objectClass = DhMeasuredTemplate;

CONFIG.Token.documentClass = DHToken;
CONFIG.Token.prototypeSheetClass = DhPrototypeTokenConfig;
CONFIG.Token.objectClass = DhTokenPlaceable;
CONFIG.Token.rulerClass = DhpTokenRuler;
CONFIG.Token.hudClass = DHTokenHUD;

CONFIG.ui.combat = DhCombatTracker;
CONFIG.ui.chat = DhpChatLog;
CONFIG.ui.effectsDisplay = DhEffectsDisplay;
CONFIG.ui.hotbar = DhHotbar;
CONFIG.ui.sidebar = DhSidebar;
CONFIG.ui.actors = DhActorDirectory;
CONFIG.ui.daggerheartMenu = DaggerheartMenu;
CONFIG.ui.resources = FearTracker;
CONFIG.ui.countdowns = DhCountdowns;
CONFIG.ux.ContextMenu = DHContextMenu;
CONFIG.ux.TooltipManager = DhTooltipManager;
CONFIG.ux.TemplateManager = new DhTemplateManager();

Hooks.once('init', () => {
    game.system.api = {
        applications,
        data: models,
        models,
        documents,
        dice,
        fields
    };

    const { DocumentSheetConfig } = foundry.applications.apps;
    DocumentSheetConfig.unregisterSheet(TokenDocument, 'core', foundry.applications.sheets.TokenConfig);
    DocumentSheetConfig.registerSheet(TokenDocument, SYSTEM.id, DhTokenConfig, {
        makeDefault: true
    });

    const { Items, Actors } = foundry.documents.collections;
    Items.unregisterSheet('core', foundry.applications.sheets.ItemSheetV2);
    Items.registerSheet(SYSTEM.id, AncestrySheet, { types: ['ancestry'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, CommunitySheet, { types: ['community'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, ClassSheet, { types: ['class'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, SubclassSheet, { types: ['subclass'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, FeatureSheet, { types: ['feature'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, DomainCardSheet, { types: ['domainCard'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, LootSheet, {
        types: ['loot'],
        makeDefault: true
    });
    Items.registerSheet(SYSTEM.id, ConsumableSheet, { types: ['consumable'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, WeaponSheet, { types: ['weapon'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, ArmorSheet, { types: ['armor'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, BeastformSheet, { types: ['beastform'], makeDefault: true });

    Actors.unregisterSheet('core', foundry.applications.sheets.ActorSheetV2);
    Actors.registerSheet(SYSTEM.id, CharacterSheet, { types: ['character'], makeDefault: true });
    Actors.registerSheet(SYSTEM.id, DhCompanionSheet, { types: ['companion'], makeDefault: true });
    Actors.registerSheet(SYSTEM.id, AdversarySheet, { types: ['adversary'], makeDefault: true });
    Actors.registerSheet(SYSTEM.id, DhpEnvironment, {
        types: ['environment'],
        makeDefault: true
    });
    Actors.registerSheet(SYSTEM.id, Party, {
        types: ['party'],
        makeDefault: true
    });

    DocumentSheetConfig.unregisterSheet(
        CONFIG.ActiveEffect.documentClass,
        'core',
        foundry.applications.sheets.ActiveEffectConfig
    );
    DocumentSheetConfig.registerSheet(
        CONFIG.ActiveEffect.documentClass,
        SYSTEM.id,
        DhActiveEffectConfig,
        {
            makeDefault: true
        }
    );

    game.socket.on(`system.${SYSTEM.id}`, handleSocketEvent);

    // Make Compendium Dialog resizable
    foundry.applications.sidebar.apps.Compendium.DEFAULT_OPTIONS.window.resizable = true;

    DocumentSheetConfig.registerSheet(foundry.documents.Scene, SYSTEM.id, DhSceneConfigSettings, {
        makeDefault: true,
        label: 'Daggerheart'
    });

    registerDHSettings();
    RegisterHandlebarsHelpers.registerHelpers();

    return preloadHandlebarsTemplates();
});

Hooks.on('setup', () => {
    CONFIG.statusEffects = [
        ...CONFIG.statusEffects.filter(x => !['dead', 'unconscious'].includes(x.id)),
        ...Object.values(SYSTEM.GENERAL.conditions()).map(x => ({
            ...x,
            name: game.i18n.localize(x.name),
            systemEffect: true
        }))
    ];
});

Hooks.on('ready', async () => {
    const appearanceSettings = game.settings.get(SYSTEM.id, SYSTEM.SETTINGS.gameSettings.appearance);
    ui.resources = new CONFIG.ui.resources();
    if (appearanceSettings.displayFear !== 'hide') ui.resources.render({ force: true });

    if (appearanceSettings.displayCountdownUI) {
        ui.countdowns = new CONFIG.ui.countdowns();
        ui.countdowns.render({ force: true });
    }

    ui.effectsDisplay = new CONFIG.ui.effectsDisplay();
    ui.effectsDisplay.render({ force: true });

    if (!(ui.compendiumBrowser instanceof ItemBrowser))
        ui.compendiumBrowser = new ItemBrowser();

    registerSocketHooks();
    registerRollDiceHooks();
    registerUserQueries();

    if (!game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.welcomeMessage)) {
        const welcomeMessage = await foundry.utils.fromUuid(CONFIG.DH.GENERAL.compendiumJournals.welcome);
        if (welcomeMessage) {
            welcomeMessage.sheet.render({ force: true });
            game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.welcomeMessage, true);
        }
    }

    runMigrations();
});

Hooks.once('dicesoniceready', () => {});

Hooks.on('renderChatMessageHTML', (_, element, message) => {
    enricherRenderSetup(element);
    const cssClass = message.message.flags?.daggerheart?.cssClass;
    if (cssClass) cssClass.split(' ').forEach(cls => element.classList.add(cls));
});

Hooks.on('renderJournalEntryPageProseMirrorSheet', (_, element) => {
    enricherRenderSetup(element);
});

Hooks.on('renderHandlebarsApplication', (_, element) => {
    enricherRenderSetup(element);
});

Hooks.on('chatMessage', (_, message) => {
    if (message.startsWith('/dr')) {
        const result =
            message.trim().toLowerCase() === '/dr' ? { result: {} } : rollCommandToJSON(message.replace(/\/dr\s?/, ''));
        if (!result) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.dualityParsing'));
            return false;
        }

        const { result: rollCommand, flavor } = result;

        const reaction = rollCommand.reaction;
        const traitValue = rollCommand.trait?.toLowerCase();
        const advantage = rollCommand.advantage
            ? CONFIG.DH.ACTIONS.advantageState.advantage.value
            : rollCommand.disadvantage
              ? CONFIG.DH.ACTIONS.advantageState.disadvantage.value
              : undefined;
        const difficulty = rollCommand.difficulty;

        const target = getCommandTarget({ allowNull: true });
        const title = traitValue
            ? game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                  ability: game.i18n.localize(SYSTEM.ACTOR.abilities[traitValue].label)
              })
            : game.i18n.localize('DAGGERHEART.GENERAL.duality');

        enrichedDualityRoll({
            reaction,
            traitValue,
            target,
            difficulty,
            title,
            label: 'test',
            advantage
        });
        return false;
    }
});

Hooks.on('moveToken', async (movedToken, data) => {
    const effectsAutomation = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).effects;
    if (!effectsAutomation.rangeDependent) return;

    const rangeDependantEffects = movedToken.actor.effects.filter(effect => effect.system.rangeDependence?.enabled);

    const updateEffects = async (disposition, token, effects, effectUpdates) => {
        const rangeMeasurement = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.variantRules
        ).rangeMeasurement;

        for (let effect of effects.filter(x => x.system.rangeDependence?.enabled)) {
            const { target, range, type } = effect.system.rangeDependence;
            if ((target === 'friendly' && disposition !== 1) || (target === 'hostile' && disposition !== -1))
                return false;

            const distanceBetween = canvas.grid.measurePath([
                { ...movedToken.toObject(), x: data.destination.x, y: data.destination.y },
                token
            ]).distance;
            const distance = rangeMeasurement[range];

            const reverse = type === CONFIG.DH.GENERAL.rangeInclusion.outsideRange.id;
            const newDisabled = reverse ? distanceBetween <= distance : distanceBetween > distance;
            const oldDisabled = effectUpdates[effect.uuid] ? effectUpdates[effect.uuid].disabled : newDisabled;
            effectUpdates[effect.uuid] = {
                disabled: oldDisabled || newDisabled,
                value: effect
            };
        }
    };

    const effectUpdates = {};
    for (let token of game.scenes.find(x => x.active).tokens) {
        if (token.id !== movedToken.id) {
            await updateEffects(token.disposition, token, rangeDependantEffects, effectUpdates);
        }

        if (token.actor) await updateEffects(movedToken.disposition, token, token.actor.effects, effectUpdates);
    }

    for (let key in effectUpdates) {
        const effect = effectUpdates[key];
        await effect.value.update({ disabled: effect.disabled });
    }
});

Hooks.on('renderCompendiumDirectory', (app, html) => ItemBrowser.injectSidebarButton(html));
Hooks.on('renderDocumentDirectory', (app, html) => ItemBrowser.injectSidebarButton(html));
//# sourceMappingURL=daggerheart.js.map
